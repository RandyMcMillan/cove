// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(coveFFI)
    import coveFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_cove_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_cove_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol AddressProtocol: AnyObject {
    func string() -> String
}

open class Address:
    AddressProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_address(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_address(pointer, $0) }
    }

    public static func previewNew() -> Address {
        return try! FfiConverterTypeAddress.lift(try! rustCall {
            uniffi_cove_fn_constructor_address_preview_new($0
            )
        })
    }

    open func string() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_address_string(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Address

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
        return Address(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Address) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
    return try FfiConverterTypeAddress.lift(pointer)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddress.lower(value)
}

public protocol AddressInfoProtocol: AnyObject {
    func address() -> Address

    func adressString() -> String

    func index() -> UInt32
}

open class AddressInfo:
    AddressInfoProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_addressinfo(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_addressinfo(pointer, $0) }
    }

    open func address() -> Address {
        return try! FfiConverterTypeAddress.lift(try! rustCall {
            uniffi_cove_fn_method_addressinfo_address(self.uniffiClonePointer(), $0)
        })
    }

    open func adressString() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_addressinfo_adress_string(self.uniffiClonePointer(), $0)
        })
    }

    open func index() -> UInt32 {
        return try! FfiConverterUInt32.lift(try! rustCall {
            uniffi_cove_fn_method_addressinfo_index(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeAddressInfo: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AddressInfo

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AddressInfo {
        return AddressInfo(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AddressInfo) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressInfo {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AddressInfo, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeAddressInfo_lift(_ pointer: UnsafeMutableRawPointer) throws -> AddressInfo {
    return try FfiConverterTypeAddressInfo.lift(pointer)
}

public func FfiConverterTypeAddressInfo_lower(_ value: AddressInfo) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddressInfo.lower(value)
}

public protocol AmountProtocol: AnyObject {
    func asBtc() -> Double

    func asSats() -> UInt64

    func btcString() -> String

    func fmtString(unit: Unit) -> String

    func satsString() -> String
}

open class Amount:
    AmountProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_amount(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_amount(pointer, $0) }
    }

    public static func fromSat(sats: UInt64) -> Amount {
        return try! FfiConverterTypeAmount.lift(try! rustCall {
            uniffi_cove_fn_constructor_amount_from_sat(
                FfiConverterUInt64.lower(sats), $0
            )
        })
    }

    public static func oneBtc() -> Amount {
        return try! FfiConverterTypeAmount.lift(try! rustCall {
            uniffi_cove_fn_constructor_amount_one_btc($0
            )
        })
    }

    public static func oneSat() -> Amount {
        return try! FfiConverterTypeAmount.lift(try! rustCall {
            uniffi_cove_fn_constructor_amount_one_sat($0
            )
        })
    }

    open func asBtc() -> Double {
        return try! FfiConverterDouble.lift(try! rustCall {
            uniffi_cove_fn_method_amount_as_btc(self.uniffiClonePointer(), $0)
        })
    }

    open func asSats() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_cove_fn_method_amount_as_sats(self.uniffiClonePointer(), $0)
        })
    }

    open func btcString() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_amount_btc_string(self.uniffiClonePointer(), $0)
        })
    }

    open func fmtString(unit: Unit) -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_amount_fmt_string(self.uniffiClonePointer(),
                                                    FfiConverterTypeUnit.lower(unit), $0)
        })
    }

    open func satsString() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_amount_sats_string(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeAmount: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Amount

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
        return Amount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Amount) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeAmount_lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(pointer)
}

public func FfiConverterTypeAmount_lower(_ value: Amount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAmount.lower(value)
}

public protocol AutoComplete: AnyObject {
    func autocomplete(word: String) -> [String]

    func isValidWord(word: String) -> Bool
}

open class AutoCompleteImpl:
    AutoComplete
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_autocomplete(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_autocomplete(pointer, $0) }
    }

    open func autocomplete(word: String) -> [String] {
        return try! FfiConverterSequenceString.lift(try! rustCall {
            uniffi_cove_fn_method_autocomplete_autocomplete(self.uniffiClonePointer(),
                                                            FfiConverterString.lower(word), $0)
        })
    }

    open func isValidWord(word: String) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_autocomplete_is_valid_word(self.uniffiClonePointer(),
                                                             FfiConverterString.lower(word), $0)
        })
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceAutoComplete {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceAutoComplete = .init(
        autocomplete: { (
            uniffiHandle: UInt64,
            word: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> [String] in
                guard let uniffiObj = try? FfiConverterTypeAutoComplete.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.autocomplete(
                    word: FfiConverterString.lift(word)
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterSequenceString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        isValidWord: { (
            uniffiHandle: UInt64,
            word: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeAutoComplete.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.isValidWord(
                    word: FfiConverterString.lift(word)
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeAutoComplete.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface AutoComplete: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitAutoComplete() {
    uniffi_cove_fn_init_callback_vtable_autocomplete(&UniffiCallbackInterfaceAutoComplete.vtable)
}

public struct FfiConverterTypeAutoComplete: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<AutoComplete>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AutoComplete

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AutoComplete {
        return AutoCompleteImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AutoComplete) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AutoComplete {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AutoComplete, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeAutoComplete_lift(_ pointer: UnsafeMutableRawPointer) throws -> AutoComplete {
    return try FfiConverterTypeAutoComplete.lift(pointer)
}

public func FfiConverterTypeAutoComplete_lower(_ value: AutoComplete) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAutoComplete.lower(value)
}

public protocol Bip39AutoCompleteProtocol: AnyObject {
    func autocomplete(word: String) -> [String]

    func isValidWord(word: String) -> Bool
}

open class Bip39AutoComplete:
    Bip39AutoCompleteProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_bip39autocomplete(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_bip39autocomplete_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_bip39autocomplete(pointer, $0) }
    }

    open func autocomplete(word: String) -> [String] {
        return try! FfiConverterSequenceString.lift(try! rustCall {
            uniffi_cove_fn_method_bip39autocomplete_autocomplete(self.uniffiClonePointer(),
                                                                 FfiConverterString.lower(word), $0)
        })
    }

    open func isValidWord(word: String) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_bip39autocomplete_is_valid_word(self.uniffiClonePointer(),
                                                                  FfiConverterString.lower(word), $0)
        })
    }
}

public struct FfiConverterTypeBip39AutoComplete: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bip39AutoComplete

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bip39AutoComplete {
        return Bip39AutoComplete(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bip39AutoComplete) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39AutoComplete {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bip39AutoComplete, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeBip39AutoComplete_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bip39AutoComplete {
    return try FfiConverterTypeBip39AutoComplete.lift(pointer)
}

public func FfiConverterTypeBip39AutoComplete_lower(_ value: Bip39AutoComplete) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBip39AutoComplete.lower(value)
}

public protocol Bip39WordSpecificAutocompleteProtocol: AnyObject {
    func autocomplete(word: String, allWords: [[String]]) -> [String]

    func isValidWord(word: String, allWords: [[String]]) -> Bool
}

open class Bip39WordSpecificAutocomplete:
    Bip39WordSpecificAutocompleteProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_bip39wordspecificautocomplete(self.pointer, $0) }
    }

    public convenience init(wordNumber: UInt16, numberOfWords: NumberOfBip39Words) {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_bip39wordspecificautocomplete_new(
                    FfiConverterUInt16.lower(wordNumber),
                    FfiConverterTypeNumberOfBip39Words.lower(numberOfWords), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_bip39wordspecificautocomplete(pointer, $0) }
    }

    open func autocomplete(word: String, allWords: [[String]]) -> [String] {
        return try! FfiConverterSequenceString.lift(try! rustCall {
            uniffi_cove_fn_method_bip39wordspecificautocomplete_autocomplete(self.uniffiClonePointer(),
                                                                             FfiConverterString.lower(word),
                                                                             FfiConverterSequenceSequenceString.lower(allWords), $0)
        })
    }

    open func isValidWord(word: String, allWords: [[String]]) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_bip39wordspecificautocomplete_is_valid_word(self.uniffiClonePointer(),
                                                                              FfiConverterString.lower(word),
                                                                              FfiConverterSequenceSequenceString.lower(allWords), $0)
        })
    }
}

public struct FfiConverterTypeBip39WordSpecificAutocomplete: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bip39WordSpecificAutocomplete

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bip39WordSpecificAutocomplete {
        return Bip39WordSpecificAutocomplete(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bip39WordSpecificAutocomplete) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39WordSpecificAutocomplete {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bip39WordSpecificAutocomplete, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeBip39WordSpecificAutocomplete_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bip39WordSpecificAutocomplete {
    return try FfiConverterTypeBip39WordSpecificAutocomplete.lift(pointer)
}

public func FfiConverterTypeBip39WordSpecificAutocomplete_lower(_ value: Bip39WordSpecificAutocomplete) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBip39WordSpecificAutocomplete.lower(value)
}

public protocol ChainPositionProtocol: AnyObject {}

open class ChainPosition:
    ChainPositionProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_chainposition(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_chainposition(pointer, $0) }
    }
}

public struct FfiConverterTypeChainPosition: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ChainPosition

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ChainPosition {
        return ChainPosition(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ChainPosition) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainPosition {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ChainPosition, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeChainPosition_lift(_ pointer: UnsafeMutableRawPointer) throws -> ChainPosition {
    return try FfiConverterTypeChainPosition.lift(pointer)
}

public func FfiConverterTypeChainPosition_lower(_ value: ChainPosition) -> UnsafeMutableRawPointer {
    return FfiConverterTypeChainPosition.lower(value)
}

public protocol ConfirmedTransactionProtocol: AnyObject {
    func blockHeight() -> UInt32

    func blockHeightFmt() -> String

    func confirmedAt() -> UInt64

    func confirmedAtFmt() -> String

    func confirmedAtFmtWithTime() -> String

    func id() -> TxId

    func label() -> String

    func sentAndReceived() -> SentAndReceived
}

open class ConfirmedTransaction:
    ConfirmedTransactionProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_confirmedtransaction(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_confirmedtransaction(pointer, $0) }
    }

    open func blockHeight() -> UInt32 {
        return try! FfiConverterUInt32.lift(try! rustCall {
            uniffi_cove_fn_method_confirmedtransaction_block_height(self.uniffiClonePointer(), $0)
        })
    }

    open func blockHeightFmt() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_confirmedtransaction_block_height_fmt(self.uniffiClonePointer(), $0)
        })
    }

    open func confirmedAt() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_cove_fn_method_confirmedtransaction_confirmed_at(self.uniffiClonePointer(), $0)
        })
    }

    open func confirmedAtFmt() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_confirmedtransaction_confirmed_at_fmt(self.uniffiClonePointer(), $0)
        })
    }

    open func confirmedAtFmtWithTime() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_confirmedtransaction_confirmed_at_fmt_with_time(self.uniffiClonePointer(), $0)
        })
    }

    open func id() -> TxId {
        return try! FfiConverterTypeTxId.lift(try! rustCall {
            uniffi_cove_fn_method_confirmedtransaction_id(self.uniffiClonePointer(), $0)
        })
    }

    open func label() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_confirmedtransaction_label(self.uniffiClonePointer(), $0)
        })
    }

    open func sentAndReceived() -> SentAndReceived {
        return try! FfiConverterTypeSentAndReceived.lift(try! rustCall {
            uniffi_cove_fn_method_confirmedtransaction_sent_and_received(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeConfirmedTransaction: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ConfirmedTransaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ConfirmedTransaction {
        return ConfirmedTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ConfirmedTransaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmedTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ConfirmedTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeConfirmedTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> ConfirmedTransaction {
    return try FfiConverterTypeConfirmedTransaction.lift(pointer)
}

public func FfiConverterTypeConfirmedTransaction_lower(_ value: ConfirmedTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeConfirmedTransaction.lower(value)
}

public protocol DatabaseProtocol: AnyObject {
    func globalConfig() -> GlobalConfigTable

    func wallets() -> WalletTable
}

open class Database:
    DatabaseProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_database(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_database_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_database(pointer, $0) }
    }

    open func globalConfig() -> GlobalConfigTable {
        return try! FfiConverterTypeGlobalConfigTable.lift(try! rustCall {
            uniffi_cove_fn_method_database_global_config(self.uniffiClonePointer(), $0)
        })
    }

    open func wallets() -> WalletTable {
        return try! FfiConverterTypeWalletTable.lift(try! rustCall {
            uniffi_cove_fn_method_database_wallets(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeDatabase: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Database

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Database {
        return Database(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Database) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Database {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Database, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeDatabase_lift(_ pointer: UnsafeMutableRawPointer) throws -> Database {
    return try FfiConverterTypeDatabase.lift(pointer)
}

public func FfiConverterTypeDatabase_lower(_ value: Database) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDatabase.lower(value)
}

public protocol FeeRateProtocol: AnyObject {}

open class FeeRate:
    FeeRateProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_feerate(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_feerate(pointer, $0) }
    }
}

public struct FfiConverterTypeFeeRate: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
        return FeeRate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFeeRate_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
    return try FfiConverterTypeFeeRate.lift(pointer)
}

public func FfiConverterTypeFeeRate_lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRate.lower(value)
}

/**
 * Representation of our app over FFI. Essentially a wrapper of [`App`].
 */
public protocol FfiAppProtocol: AnyObject {
    /**
     * Frontend calls this method to send events to the rust application logic
     */
    func dispatch(action: AppAction)

    /**
     * Get the selected wallet
     */
    func goToSelectedWallet() -> WalletId?

    /**
     * Check if there's any wallets
     */
    func hasWallets() -> Bool

    /**
     * call an async function on app load so it initializes the async runtime
     */
    func initAsyncRuntime() async

    func listenForUpdates(updater: FfiReconcile)

    func network() -> Network

    /**
     * Number of wallets
     */
    func numWallets() -> UInt16

    /**
     * Change the default route, and reset the routes
     */
    func resetDefaultRouteTo(route: Route)

    /**
     * Select a wallet
     */
    func selectWallet(id: WalletId) throws

    func state() -> AppState
}

/**
 * Representation of our app over FFI. Essentially a wrapper of [`App`].
 */
open class FfiApp:
    FfiAppProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_ffiapp(self.pointer, $0) }
    }

    /**
     * FFI constructor which wraps in an Arc
     */
    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_ffiapp_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_ffiapp(pointer, $0) }
    }

    /**
     * Frontend calls this method to send events to the rust application logic
     */
    open func dispatch(action: AppAction) { try! rustCall {
        uniffi_cove_fn_method_ffiapp_dispatch(self.uniffiClonePointer(),
                                              FfiConverterTypeAppAction.lower(action), $0)
    }
    }

    /**
     * Get the selected wallet
     */
    open func goToSelectedWallet() -> WalletId? {
        return try! FfiConverterOptionTypeWalletId.lift(try! rustCall {
            uniffi_cove_fn_method_ffiapp_go_to_selected_wallet(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Check if there's any wallets
     */
    open func hasWallets() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_ffiapp_has_wallets(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * call an async function on app load so it initializes the async runtime
     */
    open func initAsyncRuntime() async {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_ffiapp_init_async_runtime(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_void,
                completeFunc: ffi_cove_rust_future_complete_void,
                freeFunc: ffi_cove_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: nil
            )
    }

    open func listenForUpdates(updater: FfiReconcile) { try! rustCall {
        uniffi_cove_fn_method_ffiapp_listen_for_updates(self.uniffiClonePointer(),
                                                        FfiConverterCallbackInterfaceFfiReconcile.lower(updater), $0)
    }
    }

    open func network() -> Network {
        return try! FfiConverterTypeNetwork.lift(try! rustCall {
            uniffi_cove_fn_method_ffiapp_network(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Number of wallets
     */
    open func numWallets() -> UInt16 {
        return try! FfiConverterUInt16.lift(try! rustCall {
            uniffi_cove_fn_method_ffiapp_num_wallets(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Change the default route, and reset the routes
     */
    open func resetDefaultRouteTo(route: Route) { try! rustCall {
        uniffi_cove_fn_method_ffiapp_reset_default_route_to(self.uniffiClonePointer(),
                                                            FfiConverterTypeRoute.lower(route), $0)
    }
    }

    /**
     * Select a wallet
     */
    open func selectWallet(id: WalletId) throws { try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
        uniffi_cove_fn_method_ffiapp_select_wallet(self.uniffiClonePointer(),
                                                   FfiConverterTypeWalletId.lower(id), $0)
    }
    }

    open func state() -> AppState {
        return try! FfiConverterTypeAppState.lift(try! rustCall {
            uniffi_cove_fn_method_ffiapp_state(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeFfiApp: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiApp

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiApp {
        return FfiApp(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiApp) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiApp {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiApp, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiApp_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiApp {
    return try FfiConverterTypeFfiApp.lift(pointer)
}

public func FfiConverterTypeFfiApp_lower(_ value: FfiApp) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiApp.lower(value)
}

public protocol FiatClientProtocol: AnyObject {}

open class FiatClient:
    FiatClientProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_fiatclient(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_fiatclient(pointer, $0) }
    }
}

public struct FfiConverterTypeFiatClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FiatClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FiatClient {
        return FiatClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FiatClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FiatClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFiatClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> FiatClient {
    return try FfiConverterTypeFiatClient.lift(pointer)
}

public func FfiConverterTypeFiatClient_lower(_ value: FiatClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFiatClient.lower(value)
}

public protocol FingerprintProtocol: AnyObject {
    func toLowercase() -> String

    func toUppercase() -> String
}

open class Fingerprint:
    FingerprintProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_fingerprint(self.pointer, $0) }
    }

    public convenience init(id: WalletId) throws {
        let pointer =
            try rustCallWithError(FfiConverterTypeFingerprintError.lift) {
                uniffi_cove_fn_constructor_fingerprint_new(
                    FfiConverterTypeWalletId.lower(id), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_fingerprint(pointer, $0) }
    }

    open func toLowercase() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_fingerprint_to_lowercase(self.uniffiClonePointer(), $0)
        })
    }

    open func toUppercase() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_fingerprint_to_uppercase(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeFingerprint: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Fingerprint

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Fingerprint {
        return Fingerprint(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Fingerprint) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fingerprint {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Fingerprint, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFingerprint_lift(_ pointer: UnsafeMutableRawPointer) throws -> Fingerprint {
    return try FfiConverterTypeFingerprint.lift(pointer)
}

public func FfiConverterTypeFingerprint_lower(_ value: Fingerprint) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFingerprint.lower(value)
}

public protocol GlobalConfigTableProtocol: AnyObject {
    func clearSelectedWallet() throws

    func colorScheme() -> ColorSchemeSelection

    func delete(key: GlobalConfigKey) throws

    func get(key: GlobalConfigKey) throws -> String?

    func selectWallet(id: WalletId) throws

    func selectedNetwork() -> Network

    func selectedNode() -> Node

    func selectedWallet() -> WalletId?

    func set(key: GlobalConfigKey, value: String) throws

    func setColorScheme(colorScheme: ColorSchemeSelection) throws

    func setSelectedNetwork(network: Network) throws

    func setSelectedNode(node: Node) throws
}

open class GlobalConfigTable:
    GlobalConfigTableProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_globalconfigtable(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_globalconfigtable(pointer, $0) }
    }

    open func clearSelectedWallet() throws { try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
        uniffi_cove_fn_method_globalconfigtable_clear_selected_wallet(self.uniffiClonePointer(), $0)
    }
    }

    open func colorScheme() -> ColorSchemeSelection {
        return try! FfiConverterTypeColorSchemeSelection.lift(try! rustCall {
            uniffi_cove_fn_method_globalconfigtable_color_scheme(self.uniffiClonePointer(), $0)
        })
    }

    open func delete(key: GlobalConfigKey) throws { try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
        uniffi_cove_fn_method_globalconfigtable_delete(self.uniffiClonePointer(),
                                                       FfiConverterTypeGlobalConfigKey.lower(key), $0)
    }
    }

    open func get(key: GlobalConfigKey) throws -> String? {
        return try FfiConverterOptionString.lift(rustCallWithError(FfiConverterTypeDatabaseError.lift) {
            uniffi_cove_fn_method_globalconfigtable_get(self.uniffiClonePointer(),
                                                        FfiConverterTypeGlobalConfigKey.lower(key), $0)
        })
    }

    open func selectWallet(id: WalletId) throws { try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
        uniffi_cove_fn_method_globalconfigtable_select_wallet(self.uniffiClonePointer(),
                                                              FfiConverterTypeWalletId.lower(id), $0)
    }
    }

    open func selectedNetwork() -> Network {
        return try! FfiConverterTypeNetwork.lift(try! rustCall {
            uniffi_cove_fn_method_globalconfigtable_selected_network(self.uniffiClonePointer(), $0)
        })
    }

    open func selectedNode() -> Node {
        return try! FfiConverterTypeNode.lift(try! rustCall {
            uniffi_cove_fn_method_globalconfigtable_selected_node(self.uniffiClonePointer(), $0)
        })
    }

    open func selectedWallet() -> WalletId? {
        return try! FfiConverterOptionTypeWalletId.lift(try! rustCall {
            uniffi_cove_fn_method_globalconfigtable_selected_wallet(self.uniffiClonePointer(), $0)
        })
    }

    open func set(key: GlobalConfigKey, value: String) throws { try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
        uniffi_cove_fn_method_globalconfigtable_set(self.uniffiClonePointer(),
                                                    FfiConverterTypeGlobalConfigKey.lower(key),
                                                    FfiConverterString.lower(value), $0)
    }
    }

    open func setColorScheme(colorScheme: ColorSchemeSelection) throws { try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
        uniffi_cove_fn_method_globalconfigtable_set_color_scheme(self.uniffiClonePointer(),
                                                                 FfiConverterTypeColorSchemeSelection.lower(colorScheme), $0)
    }
    }

    open func setSelectedNetwork(network: Network) throws { try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
        uniffi_cove_fn_method_globalconfigtable_set_selected_network(self.uniffiClonePointer(),
                                                                     FfiConverterTypeNetwork.lower(network), $0)
    }
    }

    open func setSelectedNode(node: Node) throws { try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
        uniffi_cove_fn_method_globalconfigtable_set_selected_node(self.uniffiClonePointer(),
                                                                  FfiConverterTypeNode.lower(node), $0)
    }
    }
}

public struct FfiConverterTypeGlobalConfigTable: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GlobalConfigTable

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GlobalConfigTable {
        return GlobalConfigTable(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GlobalConfigTable) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalConfigTable {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GlobalConfigTable, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeGlobalConfigTable_lift(_ pointer: UnsafeMutableRawPointer) throws -> GlobalConfigTable {
    return try FfiConverterTypeGlobalConfigTable.lift(pointer)
}

public func FfiConverterTypeGlobalConfigTable_lower(_ value: GlobalConfigTable) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGlobalConfigTable.lower(value)
}

public protocol GlobalFlagTableProtocol: AnyObject {
    func get(key: GlobalFlagKey) throws -> Bool

    func set(key: GlobalFlagKey, value: Bool) throws

    func toggleBoolConfig(key: GlobalFlagKey) throws
}

open class GlobalFlagTable:
    GlobalFlagTableProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_globalflagtable(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_globalflagtable(pointer, $0) }
    }

    open func get(key: GlobalFlagKey) throws -> Bool {
        return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeDatabaseError.lift) {
            uniffi_cove_fn_method_globalflagtable_get(self.uniffiClonePointer(),
                                                      FfiConverterTypeGlobalFlagKey.lower(key), $0)
        })
    }

    open func set(key: GlobalFlagKey, value: Bool) throws { try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
        uniffi_cove_fn_method_globalflagtable_set(self.uniffiClonePointer(),
                                                  FfiConverterTypeGlobalFlagKey.lower(key),
                                                  FfiConverterBool.lower(value), $0)
    }
    }

    open func toggleBoolConfig(key: GlobalFlagKey) throws { try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
        uniffi_cove_fn_method_globalflagtable_toggle_bool_config(self.uniffiClonePointer(),
                                                                 FfiConverterTypeGlobalFlagKey.lower(key), $0)
    }
    }
}

public struct FfiConverterTypeGlobalFlagTable: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GlobalFlagTable

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GlobalFlagTable {
        return GlobalFlagTable(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GlobalFlagTable) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalFlagTable {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GlobalFlagTable, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeGlobalFlagTable_lift(_ pointer: UnsafeMutableRawPointer) throws -> GlobalFlagTable {
    return try FfiConverterTypeGlobalFlagTable.lift(pointer)
}

public func FfiConverterTypeGlobalFlagTable_lower(_ value: GlobalFlagTable) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGlobalFlagTable.lower(value)
}

public protocol HeaderIconPresenterProtocol: AnyObject {
    func ringColor(state: TransactionState, colorScheme: FfiColorScheme, direction: TransactionDirection, confirmations: Int32, ringNumber: Int32) -> FfiColor
}

open class HeaderIconPresenter:
    HeaderIconPresenterProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_headericonpresenter(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_headericonpresenter_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_headericonpresenter(pointer, $0) }
    }

    open func ringColor(state: TransactionState, colorScheme: FfiColorScheme, direction: TransactionDirection, confirmations: Int32, ringNumber: Int32) -> FfiColor {
        return try! FfiConverterTypeFfiColor.lift(try! rustCall {
            uniffi_cove_fn_method_headericonpresenter_ring_color(self.uniffiClonePointer(),
                                                                 FfiConverterTypeTransactionState.lower(state),
                                                                 FfiConverterTypeFfiColorScheme.lower(colorScheme),
                                                                 FfiConverterTypeTransactionDirection.lower(direction),
                                                                 FfiConverterInt32.lower(confirmations),
                                                                 FfiConverterInt32.lower(ringNumber), $0)
        })
    }
}

public struct FfiConverterTypeHeaderIconPresenter: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HeaderIconPresenter

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HeaderIconPresenter {
        return HeaderIconPresenter(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HeaderIconPresenter) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HeaderIconPresenter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HeaderIconPresenter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeHeaderIconPresenter_lift(_ pointer: UnsafeMutableRawPointer) throws -> HeaderIconPresenter {
    return try FfiConverterTypeHeaderIconPresenter.lift(pointer)
}

public func FfiConverterTypeHeaderIconPresenter_lower(_ value: HeaderIconPresenter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHeaderIconPresenter.lower(value)
}

public protocol KeychainProtocol: AnyObject {}

open class Keychain:
    KeychainProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_keychain(self.pointer, $0) }
    }

    public convenience init(keychain: KeychainAccess) {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_keychain_new(
                    FfiConverterCallbackInterfaceKeychainAccess.lower(keychain), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_keychain(pointer, $0) }
    }
}

public struct FfiConverterTypeKeychain: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Keychain

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Keychain {
        return Keychain(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Keychain) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Keychain {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Keychain, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeKeychain_lift(_ pointer: UnsafeMutableRawPointer) throws -> Keychain {
    return try FfiConverterTypeKeychain.lift(pointer)
}

public func FfiConverterTypeKeychain_lower(_ value: Keychain) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKeychain.lower(value)
}

public protocol MnemonicProtocol: AnyObject {
    func allWords() -> [GroupedWord]
}

open class Mnemonic:
    MnemonicProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_mnemonic(self.pointer, $0) }
    }

    public convenience init(id: WalletId) throws {
        let pointer =
            try rustCallWithError(FfiConverterTypeMnemonicError.lift) {
                uniffi_cove_fn_constructor_mnemonic_new(
                    FfiConverterTypeWalletId.lower(id), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_mnemonic(pointer, $0) }
    }

    public static func preview(numberOfBip39Words: NumberOfBip39Words) -> Mnemonic {
        return try! FfiConverterTypeMnemonic.lift(try! rustCall {
            uniffi_cove_fn_constructor_mnemonic_preview(
                FfiConverterTypeNumberOfBip39Words.lower(numberOfBip39Words), $0
            )
        })
    }

    open func allWords() -> [GroupedWord] {
        return try! FfiConverterSequenceTypeGroupedWord.lift(try! rustCall {
            uniffi_cove_fn_method_mnemonic_all_words(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeMnemonic: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Mnemonic

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Mnemonic {
        return Mnemonic(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Mnemonic) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeMnemonic_lift(_ pointer: UnsafeMutableRawPointer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(pointer)
}

public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMnemonic.lower(value)
}

public protocol NodeSelectorProtocol: AnyObject {
    /**
     * Check the node url and set it as selected node if it is valid
     */
    func checkAndSaveNode(node: Node) async throws

    func checkSelectedNode(node: Node) async throws

    func nodeList() -> [NodeSelection]

    /**
     * Use the url and name of the custom node to set it as the selected node
     */
    func parseCustomNode(url: String, name: String, enteredName: String) throws -> Node

    func selectPresetNode(name: String) throws -> Node

    func selectedNode() -> NodeSelection
}

open class NodeSelector:
    NodeSelectorProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_nodeselector(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_nodeselector_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_nodeselector(pointer, $0) }
    }

    /**
     * Check the node url and set it as selected node if it is valid
     */
    open func checkAndSaveNode(node: Node) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_nodeselector_check_and_save_node(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNode.lower(node)
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_void,
                completeFunc: ffi_cove_rust_future_complete_void,
                freeFunc: ffi_cove_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeNodeSelectorError.lift
            )
    }

    open func checkSelectedNode(node: Node) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_nodeselector_check_selected_node(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNode.lower(node)
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_void,
                completeFunc: ffi_cove_rust_future_complete_void,
                freeFunc: ffi_cove_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeNodeSelectorError.lift
            )
    }

    open func nodeList() -> [NodeSelection] {
        return try! FfiConverterSequenceTypeNodeSelection.lift(try! rustCall {
            uniffi_cove_fn_method_nodeselector_node_list(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Use the url and name of the custom node to set it as the selected node
     */
    open func parseCustomNode(url: String, name: String, enteredName: String) throws -> Node {
        return try FfiConverterTypeNode.lift(rustCallWithError(FfiConverterTypeNodeSelectorError.lift) {
            uniffi_cove_fn_method_nodeselector_parse_custom_node(self.uniffiClonePointer(),
                                                                 FfiConverterString.lower(url),
                                                                 FfiConverterString.lower(name),
                                                                 FfiConverterString.lower(enteredName), $0)
        })
    }

    open func selectPresetNode(name: String) throws -> Node {
        return try FfiConverterTypeNode.lift(rustCallWithError(FfiConverterTypeNodeSelectorError.lift) {
            uniffi_cove_fn_method_nodeselector_select_preset_node(self.uniffiClonePointer(),
                                                                  FfiConverterString.lower(name), $0)
        })
    }

    open func selectedNode() -> NodeSelection {
        return try! FfiConverterTypeNodeSelection.lift(try! rustCall {
            uniffi_cove_fn_method_nodeselector_selected_node(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeNodeSelector: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NodeSelector

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NodeSelector {
        return NodeSelector(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NodeSelector) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeSelector {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NodeSelector, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeNodeSelector_lift(_ pointer: UnsafeMutableRawPointer) throws -> NodeSelector {
    return try FfiConverterTypeNodeSelector.lift(pointer)
}

public func FfiConverterTypeNodeSelector_lower(_ value: NodeSelector) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNodeSelector.lower(value)
}

public protocol OutPointProtocol: AnyObject {}

open class OutPoint:
    OutPointProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_outpoint(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_outpoint(pointer, $0) }
    }
}

public struct FfiConverterTypeOutPoint: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OutPoint

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OutPoint {
        return OutPoint(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OutPoint) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeOutPoint_lift(_ pointer: UnsafeMutableRawPointer) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(pointer)
}

public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOutPoint.lower(value)
}

public protocol PendingWalletProtocol: AnyObject {}

open class PendingWallet:
    PendingWalletProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_pendingwallet(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_pendingwallet(pointer, $0) }
    }
}

public struct FfiConverterTypePendingWallet: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PendingWallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PendingWallet {
        return PendingWallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PendingWallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PendingWallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypePendingWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> PendingWallet {
    return try FfiConverterTypePendingWallet.lift(pointer)
}

public func FfiConverterTypePendingWallet_lower(_ value: PendingWallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypePendingWallet.lower(value)
}

public protocol RouteFactoryProtocol: AnyObject {
    func hotWallet(route: HotWalletRoute) -> Route

    func isSameParentRoute(route: Route, routeToCheck: Route) -> Bool

    func newColdWallet() -> Route

    func newHotWallet() -> Route

    func newWalletSelect() -> Route

    func secretWords(walletId: WalletId) -> Route
}

open class RouteFactory:
    RouteFactoryProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_routefactory(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_routefactory_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_routefactory(pointer, $0) }
    }

    open func hotWallet(route: HotWalletRoute) -> Route {
        return try! FfiConverterTypeRoute.lift(try! rustCall {
            uniffi_cove_fn_method_routefactory_hot_wallet(self.uniffiClonePointer(),
                                                          FfiConverterTypeHotWalletRoute.lower(route), $0)
        })
    }

    open func isSameParentRoute(route: Route, routeToCheck: Route) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_routefactory_is_same_parent_route(self.uniffiClonePointer(),
                                                                    FfiConverterTypeRoute.lower(route),
                                                                    FfiConverterTypeRoute.lower(routeToCheck), $0)
        })
    }

    open func newColdWallet() -> Route {
        return try! FfiConverterTypeRoute.lift(try! rustCall {
            uniffi_cove_fn_method_routefactory_new_cold_wallet(self.uniffiClonePointer(), $0)
        })
    }

    open func newHotWallet() -> Route {
        return try! FfiConverterTypeRoute.lift(try! rustCall {
            uniffi_cove_fn_method_routefactory_new_hot_wallet(self.uniffiClonePointer(), $0)
        })
    }

    open func newWalletSelect() -> Route {
        return try! FfiConverterTypeRoute.lift(try! rustCall {
            uniffi_cove_fn_method_routefactory_new_wallet_select(self.uniffiClonePointer(), $0)
        })
    }

    open func secretWords(walletId: WalletId) -> Route {
        return try! FfiConverterTypeRoute.lift(try! rustCall {
            uniffi_cove_fn_method_routefactory_secret_words(self.uniffiClonePointer(),
                                                            FfiConverterTypeWalletId.lower(walletId), $0)
        })
    }
}

public struct FfiConverterTypeRouteFactory: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RouteFactory

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RouteFactory {
        return RouteFactory(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RouteFactory) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteFactory {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RouteFactory, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeRouteFactory_lift(_ pointer: UnsafeMutableRawPointer) throws -> RouteFactory {
    return try FfiConverterTypeRouteFactory.lift(pointer)
}

public func FfiConverterTypeRouteFactory_lower(_ value: RouteFactory) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRouteFactory.lower(value)
}

public protocol RustImportWalletViewModelProtocol: AnyObject {
    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: ImportWalletViewModelAction)

    /**
     * Import wallet view from entered words
     */
    func importWallet(enteredWords: [[String]]) throws -> WalletMetadata

    func listenForUpdates(reconciler: ImportWalletViewModelReconciler)
}

open class RustImportWalletViewModel:
    RustImportWalletViewModelProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_rustimportwalletviewmodel(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_rustimportwalletviewmodel_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustimportwalletviewmodel(pointer, $0) }
    }

    /**
     * Action from the frontend to change the state of the view model
     */
    open func dispatch(action: ImportWalletViewModelAction) { try! rustCall {
        uniffi_cove_fn_method_rustimportwalletviewmodel_dispatch(self.uniffiClonePointer(),
                                                                 FfiConverterTypeImportWalletViewModelAction.lower(action), $0)
    }
    }

    /**
     * Import wallet view from entered words
     */
    open func importWallet(enteredWords: [[String]]) throws -> WalletMetadata {
        return try FfiConverterTypeWalletMetadata.lift(rustCallWithError(FfiConverterTypeImportWalletError.lift) {
            uniffi_cove_fn_method_rustimportwalletviewmodel_import_wallet(self.uniffiClonePointer(),
                                                                          FfiConverterSequenceSequenceString.lower(enteredWords), $0)
        })
    }

    open func listenForUpdates(reconciler: ImportWalletViewModelReconciler) { try! rustCall {
        uniffi_cove_fn_method_rustimportwalletviewmodel_listen_for_updates(self.uniffiClonePointer(),
                                                                           FfiConverterCallbackInterfaceImportWalletViewModelReconciler.lower(reconciler), $0)
    }
    }
}

public struct FfiConverterTypeRustImportWalletViewModel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustImportWalletViewModel

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustImportWalletViewModel {
        return RustImportWalletViewModel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustImportWalletViewModel) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustImportWalletViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustImportWalletViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeRustImportWalletViewModel_lift(_ pointer: UnsafeMutableRawPointer) throws -> RustImportWalletViewModel {
    return try FfiConverterTypeRustImportWalletViewModel.lift(pointer)
}

public func FfiConverterTypeRustImportWalletViewModel_lower(_ value: RustImportWalletViewModel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRustImportWalletViewModel.lower(value)
}

public protocol RustPendingWalletViewModelProtocol: AnyObject {
    func bip39Words() -> [String]

    func bip39WordsGrouped() -> [[GroupedWord]]

    func cardIndexes() -> UInt8

    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: PendingWalletViewModelAction)

    func getState() -> PendingWalletViewModelState

    func listenForUpdates(reconciler: PendingWalletViewModelReconciler)

    func numberOfWordsCount() -> UInt8

    func saveWallet() throws -> WalletMetadata
}

open class RustPendingWalletViewModel:
    RustPendingWalletViewModelProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_rustpendingwalletviewmodel(self.pointer, $0) }
    }

    public convenience init(numberOfWords: NumberOfBip39Words) {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_rustpendingwalletviewmodel_new(
                    FfiConverterTypeNumberOfBip39Words.lower(numberOfWords), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustpendingwalletviewmodel(pointer, $0) }
    }

    open func bip39Words() -> [String] {
        return try! FfiConverterSequenceString.lift(try! rustCall {
            uniffi_cove_fn_method_rustpendingwalletviewmodel_bip_39_words(self.uniffiClonePointer(), $0)
        })
    }

    open func bip39WordsGrouped() -> [[GroupedWord]] {
        return try! FfiConverterSequenceSequenceTypeGroupedWord.lift(try! rustCall {
            uniffi_cove_fn_method_rustpendingwalletviewmodel_bip_39_words_grouped(self.uniffiClonePointer(), $0)
        })
    }

    open func cardIndexes() -> UInt8 {
        return try! FfiConverterUInt8.lift(try! rustCall {
            uniffi_cove_fn_method_rustpendingwalletviewmodel_card_indexes(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Action from the frontend to change the state of the view model
     */
    open func dispatch(action: PendingWalletViewModelAction) { try! rustCall {
        uniffi_cove_fn_method_rustpendingwalletviewmodel_dispatch(self.uniffiClonePointer(),
                                                                  FfiConverterTypePendingWalletViewModelAction.lower(action), $0)
    }
    }

    open func getState() -> PendingWalletViewModelState {
        return try! FfiConverterTypePendingWalletViewModelState.lift(try! rustCall {
            uniffi_cove_fn_method_rustpendingwalletviewmodel_get_state(self.uniffiClonePointer(), $0)
        })
    }

    open func listenForUpdates(reconciler: PendingWalletViewModelReconciler) { try! rustCall {
        uniffi_cove_fn_method_rustpendingwalletviewmodel_listen_for_updates(self.uniffiClonePointer(),
                                                                            FfiConverterCallbackInterfacePendingWalletViewModelReconciler.lower(reconciler), $0)
    }
    }

    open func numberOfWordsCount() -> UInt8 {
        return try! FfiConverterUInt8.lift(try! rustCall {
            uniffi_cove_fn_method_rustpendingwalletviewmodel_number_of_words_count(self.uniffiClonePointer(), $0)
        })
    }

    open func saveWallet() throws -> WalletMetadata {
        return try FfiConverterTypeWalletMetadata.lift(rustCallWithError(FfiConverterTypePendingWalletViewModelError.lift) {
            uniffi_cove_fn_method_rustpendingwalletviewmodel_save_wallet(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeRustPendingWalletViewModel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustPendingWalletViewModel

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustPendingWalletViewModel {
        return RustPendingWalletViewModel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustPendingWalletViewModel) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustPendingWalletViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustPendingWalletViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeRustPendingWalletViewModel_lift(_ pointer: UnsafeMutableRawPointer) throws -> RustPendingWalletViewModel {
    return try FfiConverterTypeRustPendingWalletViewModel.lift(pointer)
}

public func FfiConverterTypeRustPendingWalletViewModel_lower(_ value: RustPendingWalletViewModel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRustPendingWalletViewModel.lower(value)
}

public protocol RustWalletViewModelProtocol: AnyObject {
    func balance() async -> Balance

    func currentBlockHeight() async throws -> UInt32

    func deleteWallet() throws

    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: WalletViewModelAction)

    func displayAmount(amount: Amount) -> String

    func fingerprint() -> String

    func listenForUpdates(reconciler: WalletViewModelReconciler)

    func markWalletAsVerified() throws

    /**
     * Get the next address for the wallet
     */
    func nextAddress() async throws -> AddressInfo

    func numberOfConfirmations(blockHeight: UInt32) async throws -> UInt32

    func numberOfConfirmationsFmt(blockHeight: UInt32) async throws -> String

    func startWalletScan() async throws

    func transactionDetails(txId: TxId) async throws -> TransactionDetails

    func walletMetadata() -> WalletMetadata

    func wordValidator() throws -> WordValidator
}

open class RustWalletViewModel:
    RustWalletViewModelProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_rustwalletviewmodel(self.pointer, $0) }
    }

    public convenience init(id: WalletId) throws {
        let pointer =
            try rustCallWithError(FfiConverterTypeWalletViewModelError.lift) {
                uniffi_cove_fn_constructor_rustwalletviewmodel_new(
                    FfiConverterTypeWalletId.lower(id), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustwalletviewmodel(pointer, $0) }
    }

    public static func previewNewWallet() -> RustWalletViewModel {
        return try! FfiConverterTypeRustWalletViewModel.lift(try! rustCall {
            uniffi_cove_fn_constructor_rustwalletviewmodel_preview_new_wallet($0
            )
        })
    }

    open func balance() async -> Balance {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_rustwalletviewmodel_balance(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_rust_buffer,
                completeFunc: ffi_cove_rust_future_complete_rust_buffer,
                freeFunc: ffi_cove_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeBalance.lift,
                errorHandler: nil
            )
    }

    open func currentBlockHeight() async throws -> UInt32 {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_rustwalletviewmodel_current_block_height(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_u32,
                completeFunc: ffi_cove_rust_future_complete_u32,
                freeFunc: ffi_cove_rust_future_free_u32,
                liftFunc: FfiConverterUInt32.lift,
                errorHandler: FfiConverterTypeWalletViewModelError.lift
            )
    }

    open func deleteWallet() throws { try rustCallWithError(FfiConverterTypeWalletViewModelError.lift) {
        uniffi_cove_fn_method_rustwalletviewmodel_delete_wallet(self.uniffiClonePointer(), $0)
    }
    }

    /**
     * Action from the frontend to change the state of the view model
     */
    open func dispatch(action: WalletViewModelAction) { try! rustCall {
        uniffi_cove_fn_method_rustwalletviewmodel_dispatch(self.uniffiClonePointer(),
                                                           FfiConverterTypeWalletViewModelAction.lower(action), $0)
    }
    }

    open func displayAmount(amount: Amount) -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_rustwalletviewmodel_display_amount(self.uniffiClonePointer(),
                                                                     FfiConverterTypeAmount.lower(amount), $0)
        })
    }

    open func fingerprint() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_rustwalletviewmodel_fingerprint(self.uniffiClonePointer(), $0)
        })
    }

    open func listenForUpdates(reconciler: WalletViewModelReconciler) { try! rustCall {
        uniffi_cove_fn_method_rustwalletviewmodel_listen_for_updates(self.uniffiClonePointer(),
                                                                     FfiConverterCallbackInterfaceWalletViewModelReconciler.lower(reconciler), $0)
    }
    }

    open func markWalletAsVerified() throws { try rustCallWithError(FfiConverterTypeWalletViewModelError.lift) {
        uniffi_cove_fn_method_rustwalletviewmodel_mark_wallet_as_verified(self.uniffiClonePointer(), $0)
    }
    }

    /**
     * Get the next address for the wallet
     */
    open func nextAddress() async throws -> AddressInfo {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_rustwalletviewmodel_next_address(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_pointer,
                completeFunc: ffi_cove_rust_future_complete_pointer,
                freeFunc: ffi_cove_rust_future_free_pointer,
                liftFunc: FfiConverterTypeAddressInfo.lift,
                errorHandler: FfiConverterTypeWalletViewModelError.lift
            )
    }

    open func numberOfConfirmations(blockHeight: UInt32) async throws -> UInt32 {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_rustwalletviewmodel_number_of_confirmations(
                        self.uniffiClonePointer(),
                        FfiConverterUInt32.lower(blockHeight)
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_u32,
                completeFunc: ffi_cove_rust_future_complete_u32,
                freeFunc: ffi_cove_rust_future_free_u32,
                liftFunc: FfiConverterUInt32.lift,
                errorHandler: FfiConverterTypeWalletViewModelError.lift
            )
    }

    open func numberOfConfirmationsFmt(blockHeight: UInt32) async throws -> String {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_rustwalletviewmodel_number_of_confirmations_fmt(
                        self.uniffiClonePointer(),
                        FfiConverterUInt32.lower(blockHeight)
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_rust_buffer,
                completeFunc: ffi_cove_rust_future_complete_rust_buffer,
                freeFunc: ffi_cove_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: FfiConverterTypeWalletViewModelError.lift
            )
    }

    open func startWalletScan() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_rustwalletviewmodel_start_wallet_scan(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_void,
                completeFunc: ffi_cove_rust_future_complete_void,
                freeFunc: ffi_cove_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeWalletViewModelError.lift
            )
    }

    open func transactionDetails(txId: TxId) async throws -> TransactionDetails {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_rustwalletviewmodel_transaction_details(
                        self.uniffiClonePointer(),
                        FfiConverterTypeTxId.lower(txId)
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_pointer,
                completeFunc: ffi_cove_rust_future_complete_pointer,
                freeFunc: ffi_cove_rust_future_free_pointer,
                liftFunc: FfiConverterTypeTransactionDetails.lift,
                errorHandler: FfiConverterTypeWalletViewModelError.lift
            )
    }

    open func walletMetadata() -> WalletMetadata {
        return try! FfiConverterTypeWalletMetadata.lift(try! rustCall {
            uniffi_cove_fn_method_rustwalletviewmodel_wallet_metadata(self.uniffiClonePointer(), $0)
        })
    }

    open func wordValidator() throws -> WordValidator {
        return try FfiConverterTypeWordValidator.lift(rustCallWithError(FfiConverterTypeWalletViewModelError.lift) {
            uniffi_cove_fn_method_rustwalletviewmodel_word_validator(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeRustWalletViewModel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustWalletViewModel

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustWalletViewModel {
        return RustWalletViewModel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustWalletViewModel) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustWalletViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustWalletViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeRustWalletViewModel_lift(_ pointer: UnsafeMutableRawPointer) throws -> RustWalletViewModel {
    return try FfiConverterTypeRustWalletViewModel.lift(pointer)
}

public func FfiConverterTypeRustWalletViewModel_lower(_ value: RustWalletViewModel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRustWalletViewModel.lower(value)
}

public protocol SentAndReceivedProtocol: AnyObject {
    func amount() -> Amount

    func amountFmt(unit: Unit) -> String

    func direction() -> TransactionDirection

    func label() -> String

    func received() -> Amount

    func sent() -> Amount
}

open class SentAndReceived:
    SentAndReceivedProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_sentandreceived(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_sentandreceived(pointer, $0) }
    }

    open func amount() -> Amount {
        return try! FfiConverterTypeAmount.lift(try! rustCall {
            uniffi_cove_fn_method_sentandreceived_amount(self.uniffiClonePointer(), $0)
        })
    }

    open func amountFmt(unit: Unit) -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_sentandreceived_amount_fmt(self.uniffiClonePointer(),
                                                             FfiConverterTypeUnit.lower(unit), $0)
        })
    }

    open func direction() -> TransactionDirection {
        return try! FfiConverterTypeTransactionDirection.lift(try! rustCall {
            uniffi_cove_fn_method_sentandreceived_direction(self.uniffiClonePointer(), $0)
        })
    }

    open func label() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_sentandreceived_label(self.uniffiClonePointer(), $0)
        })
    }

    open func received() -> Amount {
        return try! FfiConverterTypeAmount.lift(try! rustCall {
            uniffi_cove_fn_method_sentandreceived_received(self.uniffiClonePointer(), $0)
        })
    }

    open func sent() -> Amount {
        return try! FfiConverterTypeAmount.lift(try! rustCall {
            uniffi_cove_fn_method_sentandreceived_sent(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeSentAndReceived: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SentAndReceived

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SentAndReceived {
        return SentAndReceived(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SentAndReceived) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SentAndReceived {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SentAndReceived, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeSentAndReceived_lift(_ pointer: UnsafeMutableRawPointer) throws -> SentAndReceived {
    return try FfiConverterTypeSentAndReceived.lift(pointer)
}

public func FfiConverterTypeSentAndReceived_lower(_ value: SentAndReceived) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSentAndReceived.lower(value)
}

public protocol TransactionDetailsProtocol: AnyObject {
    func address() -> Address

    func addressSpacedOut() -> String

    func amount() -> Amount

    func amountFiat() async throws -> Double

    func amountFiatFmt() async throws -> String

    func amountFmt(unit: Unit) -> String

    func blockNumber() -> UInt32?

    func blockNumberFmt() -> String?

    func confirmationDateTime() -> String?

    func feeFiatFmt() async throws -> String

    func feeFmt(unit: Unit) -> String?

    func isConfirmed() -> Bool

    func isReceived() -> Bool

    func isSent() -> Bool

    func sentSansFeeFiatFmt() async throws -> String

    func sentSansFeeFmt(unit: Unit) -> String?

    func transactionUrl() -> String
}

open class TransactionDetails:
    TransactionDetailsProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_transactiondetails(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_transactiondetails(pointer, $0) }
    }

    public static func previewConfirmedReceived() -> TransactionDetails {
        return try! FfiConverterTypeTransactionDetails.lift(try! rustCall {
            uniffi_cove_fn_constructor_transactiondetails_preview_confirmed_received($0
            )
        })
    }

    public static func previewConfirmedSent() -> TransactionDetails {
        return try! FfiConverterTypeTransactionDetails.lift(try! rustCall {
            uniffi_cove_fn_constructor_transactiondetails_preview_confirmed_sent($0
            )
        })
    }

    public static func previewNewConfirmed() -> TransactionDetails {
        return try! FfiConverterTypeTransactionDetails.lift(try! rustCall {
            uniffi_cove_fn_constructor_transactiondetails_preview_new_confirmed($0
            )
        })
    }

    public static func previewPendingReceived() -> TransactionDetails {
        return try! FfiConverterTypeTransactionDetails.lift(try! rustCall {
            uniffi_cove_fn_constructor_transactiondetails_preview_pending_received($0
            )
        })
    }

    public static func previewPendingSent() -> TransactionDetails {
        return try! FfiConverterTypeTransactionDetails.lift(try! rustCall {
            uniffi_cove_fn_constructor_transactiondetails_preview_pending_sent($0
            )
        })
    }

    open func address() -> Address {
        return try! FfiConverterTypeAddress.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_address(self.uniffiClonePointer(), $0)
        })
    }

    open func addressSpacedOut() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_address_spaced_out(self.uniffiClonePointer(), $0)
        })
    }

    open func amount() -> Amount {
        return try! FfiConverterTypeAmount.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_amount(self.uniffiClonePointer(), $0)
        })
    }

    open func amountFiat() async throws -> Double {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_transactiondetails_amount_fiat(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_f64,
                completeFunc: ffi_cove_rust_future_complete_f64,
                freeFunc: ffi_cove_rust_future_free_f64,
                liftFunc: FfiConverterDouble.lift,
                errorHandler: FfiConverterTypeTransactionDetailError.lift
            )
    }

    open func amountFiatFmt() async throws -> String {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_transactiondetails_amount_fiat_fmt(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_rust_buffer,
                completeFunc: ffi_cove_rust_future_complete_rust_buffer,
                freeFunc: ffi_cove_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: FfiConverterTypeTransactionDetailError.lift
            )
    }

    open func amountFmt(unit: Unit) -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_amount_fmt(self.uniffiClonePointer(),
                                                                FfiConverterTypeUnit.lower(unit), $0)
        })
    }

    open func blockNumber() -> UInt32? {
        return try! FfiConverterOptionUInt32.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_block_number(self.uniffiClonePointer(), $0)
        })
    }

    open func blockNumberFmt() -> String? {
        return try! FfiConverterOptionString.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_block_number_fmt(self.uniffiClonePointer(), $0)
        })
    }

    open func confirmationDateTime() -> String? {
        return try! FfiConverterOptionString.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_confirmation_date_time(self.uniffiClonePointer(), $0)
        })
    }

    open func feeFiatFmt() async throws -> String {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_transactiondetails_fee_fiat_fmt(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_rust_buffer,
                completeFunc: ffi_cove_rust_future_complete_rust_buffer,
                freeFunc: ffi_cove_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: FfiConverterTypeTransactionDetailError.lift
            )
    }

    open func feeFmt(unit: Unit) -> String? {
        return try! FfiConverterOptionString.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_fee_fmt(self.uniffiClonePointer(),
                                                             FfiConverterTypeUnit.lower(unit), $0)
        })
    }

    open func isConfirmed() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_is_confirmed(self.uniffiClonePointer(), $0)
        })
    }

    open func isReceived() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_is_received(self.uniffiClonePointer(), $0)
        })
    }

    open func isSent() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_is_sent(self.uniffiClonePointer(), $0)
        })
    }

    open func sentSansFeeFiatFmt() async throws -> String {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_cove_fn_method_transactiondetails_sent_sans_fee_fiat_fmt(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_cove_rust_future_poll_rust_buffer,
                completeFunc: ffi_cove_rust_future_complete_rust_buffer,
                freeFunc: ffi_cove_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: FfiConverterTypeTransactionDetailError.lift
            )
    }

    open func sentSansFeeFmt(unit: Unit) -> String? {
        return try! FfiConverterOptionString.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_sent_sans_fee_fmt(self.uniffiClonePointer(),
                                                                       FfiConverterTypeUnit.lower(unit), $0)
        })
    }

    open func transactionUrl() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_transactiondetails_transaction_url(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeTransactionDetails: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionDetails {
        return TransactionDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeTransactionDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionDetails {
    return try FfiConverterTypeTransactionDetails.lift(pointer)
}

public func FfiConverterTypeTransactionDetails_lower(_ value: TransactionDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionDetails.lower(value)
}

public protocol TxIdProtocol: AnyObject {
    func isEqual(other: TxId) -> Bool

    func toHashString() -> String
}

open class TxId:
    TxIdProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_txid(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_txid(pointer, $0) }
    }

    open func isEqual(other: TxId) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_txid_is_equal(self.uniffiClonePointer(),
                                                FfiConverterTypeTxId.lower(other), $0)
        })
    }

    open func toHashString() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_txid_to_hash_string(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeTxId: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxId

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxId {
        return TxId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxId) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeTxId_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxId {
    return try FfiConverterTypeTxId.lift(pointer)
}

public func FfiConverterTypeTxId_lower(_ value: TxId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxId.lower(value)
}

public protocol TxInProtocol: AnyObject {}

open class TxIn:
    TxInProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_txin(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_txin(pointer, $0) }
    }
}

public struct FfiConverterTypeTxIn: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxIn

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxIn {
        return TxIn(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxIn) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxIn {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxIn, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeTxIn_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxIn {
    return try FfiConverterTypeTxIn.lift(pointer)
}

public func FfiConverterTypeTxIn_lower(_ value: TxIn) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxIn.lower(value)
}

public protocol TxOutProtocol: AnyObject {}

open class TxOut:
    TxOutProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_txout(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_txout(pointer, $0) }
    }
}

public struct FfiConverterTypeTxOut: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxOut

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxOut {
        return TxOut(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxOut) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxOut {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxOut, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeTxOut_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxOut {
    return try FfiConverterTypeTxOut.lift(pointer)
}

public func FfiConverterTypeTxOut_lower(_ value: TxOut) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxOut.lower(value)
}

public protocol UnconfirmedTransactionProtocol: AnyObject {
    func id() -> TxId

    func label() -> String

    func lastSeen() -> UInt64

    func sentAndReceived() -> SentAndReceived
}

open class UnconfirmedTransaction:
    UnconfirmedTransactionProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_unconfirmedtransaction(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_unconfirmedtransaction(pointer, $0) }
    }

    open func id() -> TxId {
        return try! FfiConverterTypeTxId.lift(try! rustCall {
            uniffi_cove_fn_method_unconfirmedtransaction_id(self.uniffiClonePointer(), $0)
        })
    }

    open func label() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_unconfirmedtransaction_label(self.uniffiClonePointer(), $0)
        })
    }

    open func lastSeen() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_cove_fn_method_unconfirmedtransaction_last_seen(self.uniffiClonePointer(), $0)
        })
    }

    open func sentAndReceived() -> SentAndReceived {
        return try! FfiConverterTypeSentAndReceived.lift(try! rustCall {
            uniffi_cove_fn_method_unconfirmedtransaction_sent_and_received(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeUnconfirmedTransaction: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnconfirmedTransaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnconfirmedTransaction {
        return UnconfirmedTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnconfirmedTransaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnconfirmedTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnconfirmedTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeUnconfirmedTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnconfirmedTransaction {
    return try FfiConverterTypeUnconfirmedTransaction.lift(pointer)
}

public func FfiConverterTypeUnconfirmedTransaction_lower(_ value: UnconfirmedTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnconfirmedTransaction.lower(value)
}

public protocol WalletProtocol: AnyObject {
    func id() -> WalletId
}

open class Wallet:
    WalletProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_wallet(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_wallet(pointer, $0) }
    }

    public static func previewNewWallet() -> Wallet {
        return try! FfiConverterTypeWallet.lift(try! rustCall {
            uniffi_cove_fn_constructor_wallet_previewnewwallet($0
            )
        })
    }

    open func id() -> WalletId {
        return try! FfiConverterTypeWalletId.lift(try! rustCall {
            uniffi_cove_fn_method_wallet_id(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeWallet: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Wallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
    return try FfiConverterTypeWallet.lift(pointer)
}

public func FfiConverterTypeWallet_lower(_ value: Wallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWallet.lower(value)
}

public protocol WalletKeyProtocol: AnyObject {}

open class WalletKey:
    WalletKeyProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_walletkey(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_walletkey(pointer, $0) }
    }
}

public struct FfiConverterTypeWalletKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WalletKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletKey {
        return WalletKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WalletKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WalletKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeWalletKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletKey {
    return try FfiConverterTypeWalletKey.lift(pointer)
}

public func FfiConverterTypeWalletKey_lower(_ value: WalletKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWalletKey.lower(value)
}

public protocol WalletTableProtocol: AnyObject {
    func all() throws -> [WalletMetadata]

    func isEmpty() throws -> Bool

    func len(network: Network) throws -> UInt16
}

open class WalletTable:
    WalletTableProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_wallettable(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_wallettable(pointer, $0) }
    }

    open func all() throws -> [WalletMetadata] {
        return try FfiConverterSequenceTypeWalletMetadata.lift(rustCallWithError(FfiConverterTypeDatabaseError.lift) {
            uniffi_cove_fn_method_wallettable_all(self.uniffiClonePointer(), $0)
        })
    }

    open func isEmpty() throws -> Bool {
        return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeDatabaseError.lift) {
            uniffi_cove_fn_method_wallettable_is_empty(self.uniffiClonePointer(), $0)
        })
    }

    open func len(network: Network) throws -> UInt16 {
        return try FfiConverterUInt16.lift(rustCallWithError(FfiConverterTypeDatabaseError.lift) {
            uniffi_cove_fn_method_wallettable_len(self.uniffiClonePointer(),
                                                  FfiConverterTypeNetwork.lower(network), $0)
        })
    }
}

public struct FfiConverterTypeWalletTable: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WalletTable

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletTable {
        return WalletTable(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WalletTable) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletTable {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WalletTable, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeWalletTable_lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletTable {
    return try FfiConverterTypeWalletTable.lift(pointer)
}

public func FfiConverterTypeWalletTable_lower(_ value: WalletTable) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWalletTable.lower(value)
}

public protocol WordValidatorProtocol: AnyObject {
    func groupedWords() -> [[GroupedWord]]

    func invalidWordsString(enteredWords: [[String]]) -> String

    func isAllWordsValid(enteredWords: [[String]]) -> Bool

    func isValidWordGroup(groupNumber: UInt8, enteredWords: [String]) -> Bool
}

open class WordValidator:
    WordValidatorProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_wordvalidator(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_wordvalidator(pointer, $0) }
    }

    open func groupedWords() -> [[GroupedWord]] {
        return try! FfiConverterSequenceSequenceTypeGroupedWord.lift(try! rustCall {
            uniffi_cove_fn_method_wordvalidator_grouped_words(self.uniffiClonePointer(), $0)
        })
    }

    open func invalidWordsString(enteredWords: [[String]]) -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_wordvalidator_invalid_words_string(self.uniffiClonePointer(),
                                                                     FfiConverterSequenceSequenceString.lower(enteredWords), $0)
        })
    }

    open func isAllWordsValid(enteredWords: [[String]]) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_wordvalidator_is_all_words_valid(self.uniffiClonePointer(),
                                                                   FfiConverterSequenceSequenceString.lower(enteredWords), $0)
        })
    }

    open func isValidWordGroup(groupNumber: UInt8, enteredWords: [String]) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_wordvalidator_is_valid_word_group(self.uniffiClonePointer(),
                                                                    FfiConverterUInt8.lower(groupNumber),
                                                                    FfiConverterSequenceString.lower(enteredWords), $0)
        })
    }
}

public struct FfiConverterTypeWordValidator: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WordValidator

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WordValidator {
        return WordValidator(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WordValidator) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WordValidator {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WordValidator, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeWordValidator_lift(_ pointer: UnsafeMutableRawPointer) throws -> WordValidator {
    return try FfiConverterTypeWordValidator.lift(pointer)
}

public func FfiConverterTypeWordValidator_lower(_ value: WordValidator) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWordValidator.lower(value)
}

public struct AddressIndex {
    public var lastSeenIndex: UInt8
    public var addressListHash: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastSeenIndex: UInt8, addressListHash: UInt64) {
        self.lastSeenIndex = lastSeenIndex
        self.addressListHash = addressListHash
    }
}

extension AddressIndex: Equatable, Hashable {
    public static func == (lhs: AddressIndex, rhs: AddressIndex) -> Bool {
        if lhs.lastSeenIndex != rhs.lastSeenIndex {
            return false
        }
        if lhs.addressListHash != rhs.addressListHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastSeenIndex)
        hasher.combine(addressListHash)
    }
}

public struct FfiConverterTypeAddressIndex: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressIndex {
        return
            try AddressIndex(
                lastSeenIndex: FfiConverterUInt8.read(from: &buf),
                addressListHash: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: AddressIndex, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.lastSeenIndex, into: &buf)
        FfiConverterUInt64.write(value.addressListHash, into: &buf)
    }
}

public func FfiConverterTypeAddressIndex_lift(_ buf: RustBuffer) throws -> AddressIndex {
    return try FfiConverterTypeAddressIndex.lift(buf)
}

public func FfiConverterTypeAddressIndex_lower(_ value: AddressIndex) -> RustBuffer {
    return FfiConverterTypeAddressIndex.lower(value)
}

public struct AppState {
    public var router: Router

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(router: Router) {
        self.router = router
    }
}

public struct FfiConverterTypeAppState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppState {
        return
            try AppState(
                router: FfiConverterTypeRouter.read(from: &buf)
            )
    }

    public static func write(_ value: AppState, into buf: inout [UInt8]) {
        FfiConverterTypeRouter.write(value.router, into: &buf)
    }
}

public func FfiConverterTypeAppState_lift(_ buf: RustBuffer) throws -> AppState {
    return try FfiConverterTypeAppState.lift(buf)
}

public func FfiConverterTypeAppState_lower(_ value: AppState) -> RustBuffer {
    return FfiConverterTypeAppState.lower(value)
}

public struct Balance {
    public var immature: Amount
    public var trustedPending: Amount
    public var untrustedPending: Amount
    public var confirmed: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(immature: Amount, trustedPending: Amount, untrustedPending: Amount, confirmed: Amount) {
        self.immature = immature
        self.trustedPending = trustedPending
        self.untrustedPending = untrustedPending
        self.confirmed = confirmed
    }
}

public struct FfiConverterTypeBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Balance {
        return
            try Balance(
                immature: FfiConverterTypeAmount.read(from: &buf),
                trustedPending: FfiConverterTypeAmount.read(from: &buf),
                untrustedPending: FfiConverterTypeAmount.read(from: &buf),
                confirmed: FfiConverterTypeAmount.read(from: &buf)
            )
    }

    public static func write(_ value: Balance, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.immature, into: &buf)
        FfiConverterTypeAmount.write(value.trustedPending, into: &buf)
        FfiConverterTypeAmount.write(value.untrustedPending, into: &buf)
        FfiConverterTypeAmount.write(value.confirmed, into: &buf)
    }
}

public func FfiConverterTypeBalance_lift(_ buf: RustBuffer) throws -> Balance {
    return try FfiConverterTypeBalance.lift(buf)
}

public func FfiConverterTypeBalance_lower(_ value: Balance) -> RustBuffer {
    return FfiConverterTypeBalance.lower(value)
}

public struct ConfirmedDetails {
    public var blockNumber: UInt32
    public var confirmationTime: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blockNumber: UInt32, confirmationTime: UInt64) {
        self.blockNumber = blockNumber
        self.confirmationTime = confirmationTime
    }
}

extension ConfirmedDetails: Equatable, Hashable {
    public static func == (lhs: ConfirmedDetails, rhs: ConfirmedDetails) -> Bool {
        if lhs.blockNumber != rhs.blockNumber {
            return false
        }
        if lhs.confirmationTime != rhs.confirmationTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blockNumber)
        hasher.combine(confirmationTime)
    }
}

public struct FfiConverterTypeConfirmedDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmedDetails {
        return
            try ConfirmedDetails(
                blockNumber: FfiConverterUInt32.read(from: &buf),
                confirmationTime: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: ConfirmedDetails, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.blockNumber, into: &buf)
        FfiConverterUInt64.write(value.confirmationTime, into: &buf)
    }
}

public func FfiConverterTypeConfirmedDetails_lift(_ buf: RustBuffer) throws -> ConfirmedDetails {
    return try FfiConverterTypeConfirmedDetails.lift(buf)
}

public func FfiConverterTypeConfirmedDetails_lower(_ value: ConfirmedDetails) -> RustBuffer {
    return FfiConverterTypeConfirmedDetails.lower(value)
}

public struct GroupedWord {
    public var number: UInt8
    public var word: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(number: UInt8, word: String) {
        self.number = number
        self.word = word
    }
}

extension GroupedWord: Equatable, Hashable {
    public static func == (lhs: GroupedWord, rhs: GroupedWord) -> Bool {
        if lhs.number != rhs.number {
            return false
        }
        if lhs.word != rhs.word {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(number)
        hasher.combine(word)
    }
}

public struct FfiConverterTypeGroupedWord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GroupedWord {
        return
            try GroupedWord(
                number: FfiConverterUInt8.read(from: &buf),
                word: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: GroupedWord, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.number, into: &buf)
        FfiConverterString.write(value.word, into: &buf)
    }
}

public func FfiConverterTypeGroupedWord_lift(_ buf: RustBuffer) throws -> GroupedWord {
    return try FfiConverterTypeGroupedWord.lift(buf)
}

public func FfiConverterTypeGroupedWord_lower(_ value: GroupedWord) -> RustBuffer {
    return FfiConverterTypeGroupedWord.lower(value)
}

public struct ImportWalletViewModelState {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension ImportWalletViewModelState: Equatable, Hashable {
    public static func == (_: ImportWalletViewModelState, _: ImportWalletViewModelState) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeImportWalletViewModelState: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> ImportWalletViewModelState {
        return
            ImportWalletViewModelState()
    }

    public static func write(_: ImportWalletViewModelState, into _: inout [UInt8]) {}
}

public func FfiConverterTypeImportWalletViewModelState_lift(_ buf: RustBuffer) throws -> ImportWalletViewModelState {
    return try FfiConverterTypeImportWalletViewModelState.lift(buf)
}

public func FfiConverterTypeImportWalletViewModelState_lower(_ value: ImportWalletViewModelState) -> RustBuffer {
    return FfiConverterTypeImportWalletViewModelState.lower(value)
}

public struct InternalOnlyMetadata {
    public var addressIndex: AddressIndex?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addressIndex: AddressIndex?) {
        self.addressIndex = addressIndex
    }
}

extension InternalOnlyMetadata: Equatable, Hashable {
    public static func == (lhs: InternalOnlyMetadata, rhs: InternalOnlyMetadata) -> Bool {
        if lhs.addressIndex != rhs.addressIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addressIndex)
    }
}

public struct FfiConverterTypeInternalOnlyMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InternalOnlyMetadata {
        return
            try InternalOnlyMetadata(
                addressIndex: FfiConverterOptionTypeAddressIndex.read(from: &buf)
            )
    }

    public static func write(_ value: InternalOnlyMetadata, into buf: inout [UInt8]) {
        FfiConverterOptionTypeAddressIndex.write(value.addressIndex, into: &buf)
    }
}

public func FfiConverterTypeInternalOnlyMetadata_lift(_ buf: RustBuffer) throws -> InternalOnlyMetadata {
    return try FfiConverterTypeInternalOnlyMetadata.lift(buf)
}

public func FfiConverterTypeInternalOnlyMetadata_lower(_ value: InternalOnlyMetadata) -> RustBuffer {
    return FfiConverterTypeInternalOnlyMetadata.lower(value)
}

public struct Node {
    public var name: String
    public var network: Network
    public var apiType: ApiType
    public var url: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, network: Network, apiType: ApiType, url: String) {
        self.name = name
        self.network = network
        self.apiType = apiType
        self.url = url
    }
}

extension Node: Equatable, Hashable {
    public static func == (lhs: Node, rhs: Node) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.apiType != rhs.apiType {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(network)
        hasher.combine(apiType)
        hasher.combine(url)
    }
}

public struct FfiConverterTypeNode: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Node {
        return
            try Node(
                name: FfiConverterString.read(from: &buf),
                network: FfiConverterTypeNetwork.read(from: &buf),
                apiType: FfiConverterTypeApiType.read(from: &buf),
                url: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: Node, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterTypeApiType.write(value.apiType, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
    }
}

public func FfiConverterTypeNode_lift(_ buf: RustBuffer) throws -> Node {
    return try FfiConverterTypeNode.lift(buf)
}

public func FfiConverterTypeNode_lower(_ value: Node) -> RustBuffer {
    return FfiConverterTypeNode.lower(value)
}

public struct PendingDetails {
    public var lastSeen: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastSeen: UInt64) {
        self.lastSeen = lastSeen
    }
}

extension PendingDetails: Equatable, Hashable {
    public static func == (lhs: PendingDetails, rhs: PendingDetails) -> Bool {
        if lhs.lastSeen != rhs.lastSeen {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastSeen)
    }
}

public struct FfiConverterTypePendingDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingDetails {
        return
            try PendingDetails(
                lastSeen: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: PendingDetails, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.lastSeen, into: &buf)
    }
}

public func FfiConverterTypePendingDetails_lift(_ buf: RustBuffer) throws -> PendingDetails {
    return try FfiConverterTypePendingDetails.lift(buf)
}

public func FfiConverterTypePendingDetails_lower(_ value: PendingDetails) -> RustBuffer {
    return FfiConverterTypePendingDetails.lower(value)
}

public struct PendingWalletViewModelState {
    public var numberOfWords: NumberOfBip39Words
    public var wallet: PendingWallet

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numberOfWords: NumberOfBip39Words, wallet: PendingWallet) {
        self.numberOfWords = numberOfWords
        self.wallet = wallet
    }
}

public struct FfiConverterTypePendingWalletViewModelState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletViewModelState {
        return
            try PendingWalletViewModelState(
                numberOfWords: FfiConverterTypeNumberOfBip39Words.read(from: &buf),
                wallet: FfiConverterTypePendingWallet.read(from: &buf)
            )
    }

    public static func write(_ value: PendingWalletViewModelState, into buf: inout [UInt8]) {
        FfiConverterTypeNumberOfBip39Words.write(value.numberOfWords, into: &buf)
        FfiConverterTypePendingWallet.write(value.wallet, into: &buf)
    }
}

public func FfiConverterTypePendingWalletViewModelState_lift(_ buf: RustBuffer) throws -> PendingWalletViewModelState {
    return try FfiConverterTypePendingWalletViewModelState.lift(buf)
}

public func FfiConverterTypePendingWalletViewModelState_lower(_ value: PendingWalletViewModelState) -> RustBuffer {
    return FfiConverterTypePendingWalletViewModelState.lower(value)
}

public struct Router {
    public var app: FfiApp
    public var `default`: Route
    public var routes: [Route]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(app: FfiApp, default: Route, routes: [Route]) {
        self.app = app
        self.default = `default`
        self.routes = routes
    }
}

public struct FfiConverterTypeRouter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Router {
        return
            try Router(
                app: FfiConverterTypeFfiApp.read(from: &buf),
                default: FfiConverterTypeRoute.read(from: &buf),
                routes: FfiConverterSequenceTypeRoute.read(from: &buf)
            )
    }

    public static func write(_ value: Router, into buf: inout [UInt8]) {
        FfiConverterTypeFfiApp.write(value.app, into: &buf)
        FfiConverterTypeRoute.write(value.default, into: &buf)
        FfiConverterSequenceTypeRoute.write(value.routes, into: &buf)
    }
}

public func FfiConverterTypeRouter_lift(_ buf: RustBuffer) throws -> Router {
    return try FfiConverterTypeRouter.lift(buf)
}

public func FfiConverterTypeRouter_lower(_ value: Router) -> RustBuffer {
    return FfiConverterTypeRouter.lower(value)
}

public struct WalletMetadata {
    public var id: WalletId
    public var name: String
    public var color: WalletColor
    public var verified: Bool
    public var network: Network
    public var performedFullScan: Bool
    public var selectedUnit: Unit
    public var selectedFiatCurrency: String
    public var sensitiveVisible: Bool
    public var detailsExpanded: Bool
    public var `internal`: InternalOnlyMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: WalletId, name: String, color: WalletColor, verified: Bool, network: Network, performedFullScan: Bool, selectedUnit: Unit, selectedFiatCurrency: String, sensitiveVisible: Bool, detailsExpanded: Bool, internal: InternalOnlyMetadata) {
        self.id = id
        self.name = name
        self.color = color
        self.verified = verified
        self.network = network
        self.performedFullScan = performedFullScan
        self.selectedUnit = selectedUnit
        self.selectedFiatCurrency = selectedFiatCurrency
        self.sensitiveVisible = sensitiveVisible
        self.detailsExpanded = detailsExpanded
        self.internal = `internal`
    }
}

extension WalletMetadata: Equatable, Hashable {
    public static func == (lhs: WalletMetadata, rhs: WalletMetadata) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.verified != rhs.verified {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.performedFullScan != rhs.performedFullScan {
            return false
        }
        if lhs.selectedUnit != rhs.selectedUnit {
            return false
        }
        if lhs.selectedFiatCurrency != rhs.selectedFiatCurrency {
            return false
        }
        if lhs.sensitiveVisible != rhs.sensitiveVisible {
            return false
        }
        if lhs.detailsExpanded != rhs.detailsExpanded {
            return false
        }
        if lhs.internal != rhs.internal {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(color)
        hasher.combine(verified)
        hasher.combine(network)
        hasher.combine(performedFullScan)
        hasher.combine(selectedUnit)
        hasher.combine(selectedFiatCurrency)
        hasher.combine(sensitiveVisible)
        hasher.combine(detailsExpanded)
        hasher.combine(`internal`)
    }
}

public struct FfiConverterTypeWalletMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletMetadata {
        return
            try WalletMetadata(
                id: FfiConverterTypeWalletId.read(from: &buf),
                name: FfiConverterString.read(from: &buf),
                color: FfiConverterTypeWalletColor.read(from: &buf),
                verified: FfiConverterBool.read(from: &buf),
                network: FfiConverterTypeNetwork.read(from: &buf),
                performedFullScan: FfiConverterBool.read(from: &buf),
                selectedUnit: FfiConverterTypeUnit.read(from: &buf),
                selectedFiatCurrency: FfiConverterString.read(from: &buf),
                sensitiveVisible: FfiConverterBool.read(from: &buf),
                detailsExpanded: FfiConverterBool.read(from: &buf),
                internal: FfiConverterTypeInternalOnlyMetadata.read(from: &buf)
            )
    }

    public static func write(_ value: WalletMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeWalletId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeWalletColor.write(value.color, into: &buf)
        FfiConverterBool.write(value.verified, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterBool.write(value.performedFullScan, into: &buf)
        FfiConverterTypeUnit.write(value.selectedUnit, into: &buf)
        FfiConverterString.write(value.selectedFiatCurrency, into: &buf)
        FfiConverterBool.write(value.sensitiveVisible, into: &buf)
        FfiConverterBool.write(value.detailsExpanded, into: &buf)
        FfiConverterTypeInternalOnlyMetadata.write(value.internal, into: &buf)
    }
}

public func FfiConverterTypeWalletMetadata_lift(_ buf: RustBuffer) throws -> WalletMetadata {
    return try FfiConverterTypeWalletMetadata.lift(buf)
}

public func FfiConverterTypeWalletMetadata_lower(_ value: WalletMetadata) -> RustBuffer {
    return FfiConverterTypeWalletMetadata.lower(value)
}

public enum AddressError {
    case NoOutputs
    case ScriptError(String
    )
}

public struct FfiConverterTypeAddressError: FfiConverterRustBuffer {
    typealias SwiftType = AddressError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .NoOutputs

        case 2: return try .ScriptError(
                FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressError, into buf: inout [UInt8]) {
        switch value {
        case .NoOutputs:
            writeInt(&buf, Int32(1))

        case let .ScriptError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension AddressError: Equatable, Hashable {}

extension AddressError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ApiType {
    case esplora
    case electrum
    case rpc
}

public struct FfiConverterTypeApiType: FfiConverterRustBuffer {
    typealias SwiftType = ApiType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApiType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .esplora

        case 2: return .electrum

        case 3: return .rpc

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ApiType, into buf: inout [UInt8]) {
        switch value {
        case .esplora:
            writeInt(&buf, Int32(1))

        case .electrum:
            writeInt(&buf, Int32(2))

        case .rpc:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeApiType_lift(_ buf: RustBuffer) throws -> ApiType {
    return try FfiConverterTypeApiType.lift(buf)
}

public func FfiConverterTypeApiType_lower(_ value: ApiType) -> RustBuffer {
    return FfiConverterTypeApiType.lower(value)
}

extension ApiType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AppAction {
    case updateRoute(routes: [Route]
    )
    case changeNetwork(network: Network
    )
    case changeColorScheme(ColorSchemeSelection
    )
    case setSelectedNode(Node
    )
}

public struct FfiConverterTypeAppAction: FfiConverterRustBuffer {
    typealias SwiftType = AppAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .updateRoute(routes: FfiConverterSequenceTypeRoute.read(from: &buf)
            )

        case 2: return try .changeNetwork(network: FfiConverterTypeNetwork.read(from: &buf)
            )

        case 3: return try .changeColorScheme(FfiConverterTypeColorSchemeSelection.read(from: &buf)
            )

        case 4: return try .setSelectedNode(FfiConverterTypeNode.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AppAction, into buf: inout [UInt8]) {
        switch value {
        case let .updateRoute(routes):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoute.write(routes, into: &buf)

        case let .changeNetwork(network):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNetwork.write(network, into: &buf)

        case let .changeColorScheme(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeColorSchemeSelection.write(v1, into: &buf)

        case let .setSelectedNode(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeNode.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeAppAction_lift(_ buf: RustBuffer) throws -> AppAction {
    return try FfiConverterTypeAppAction.lift(buf)
}

public func FfiConverterTypeAppAction_lower(_ value: AppAction) -> RustBuffer {
    return FfiConverterTypeAppAction.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AppStateReconcileMessage {
    case defaultRouteChanged(Route
    )
    case routeUpdated([Route]
    )
    case databaseUpdated
    case colorSchemeChanged(ColorSchemeSelection
    )
    case selectedNodeChanged(Node
    )
}

public struct FfiConverterTypeAppStateReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = AppStateReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppStateReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .defaultRouteChanged(FfiConverterTypeRoute.read(from: &buf)
            )

        case 2: return try .routeUpdated(FfiConverterSequenceTypeRoute.read(from: &buf)
            )

        case 3: return .databaseUpdated

        case 4: return try .colorSchemeChanged(FfiConverterTypeColorSchemeSelection.read(from: &buf)
            )

        case 5: return try .selectedNodeChanged(FfiConverterTypeNode.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AppStateReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        case let .defaultRouteChanged(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRoute.write(v1, into: &buf)

        case let .routeUpdated(v1):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeRoute.write(v1, into: &buf)

        case .databaseUpdated:
            writeInt(&buf, Int32(3))

        case let .colorSchemeChanged(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeColorSchemeSelection.write(v1, into: &buf)

        case let .selectedNodeChanged(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeNode.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeAppStateReconcileMessage_lift(_ buf: RustBuffer) throws -> AppStateReconcileMessage {
    return try FfiConverterTypeAppStateReconcileMessage.lift(buf)
}

public func FfiConverterTypeAppStateReconcileMessage_lower(_ value: AppStateReconcileMessage) -> RustBuffer {
    return FfiConverterTypeAppStateReconcileMessage.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ColdWalletRoute {
    case create
    case `import`
}

public struct FfiConverterTypeColdWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = ColdWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ColdWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .create

        case 2: return .import

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ColdWalletRoute, into buf: inout [UInt8]) {
        switch value {
        case .create:
            writeInt(&buf, Int32(1))

        case .import:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeColdWalletRoute_lift(_ buf: RustBuffer) throws -> ColdWalletRoute {
    return try FfiConverterTypeColdWalletRoute.lift(buf)
}

public func FfiConverterTypeColdWalletRoute_lower(_ value: ColdWalletRoute) -> RustBuffer {
    return FfiConverterTypeColdWalletRoute.lower(value)
}

extension ColdWalletRoute: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ColorSchemeSelection {
    case light
    case dark
    case system
}

public struct FfiConverterTypeColorSchemeSelection: FfiConverterRustBuffer {
    typealias SwiftType = ColorSchemeSelection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ColorSchemeSelection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .light

        case 2: return .dark

        case 3: return .system

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ColorSchemeSelection, into buf: inout [UInt8]) {
        switch value {
        case .light:
            writeInt(&buf, Int32(1))

        case .dark:
            writeInt(&buf, Int32(2))

        case .system:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeColorSchemeSelection_lift(_ buf: RustBuffer) throws -> ColorSchemeSelection {
    return try FfiConverterTypeColorSchemeSelection.lift(buf)
}

public func FfiConverterTypeColorSchemeSelection_lower(_ value: ColorSchemeSelection) -> RustBuffer {
    return FfiConverterTypeColorSchemeSelection.lower(value)
}

extension ColorSchemeSelection: Equatable, Hashable {}

public enum DatabaseError {
    case DatabaseAccessError(String
    )
    case TableAccessError(String
    )
    case WalletsError(WalletTableError
    )
    case GlobalFlagError(GlobalFlagTableError
    )
    case GlobalConfigError(GlobalConfigTableError
    )
    case SerializationError(SerdeError
    )
}

public struct FfiConverterTypeDatabaseError: FfiConverterRustBuffer {
    typealias SwiftType = DatabaseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatabaseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .DatabaseAccessError(
                FfiConverterString.read(from: &buf)
            )
        case 2: return try .TableAccessError(
                FfiConverterString.read(from: &buf)
            )
        case 3: return try .WalletsError(
                FfiConverterTypeWalletTableError.read(from: &buf)
            )
        case 4: return try .GlobalFlagError(
                FfiConverterTypeGlobalFlagTableError.read(from: &buf)
            )
        case 5: return try .GlobalConfigError(
                FfiConverterTypeGlobalConfigTableError.read(from: &buf)
            )
        case 6: return try .SerializationError(
                FfiConverterTypeSerdeError.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DatabaseError, into buf: inout [UInt8]) {
        switch value {
        case let .DatabaseAccessError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .TableAccessError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case let .WalletsError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletTableError.write(v1, into: &buf)

        case let .GlobalFlagError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeGlobalFlagTableError.write(v1, into: &buf)

        case let .GlobalConfigError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeGlobalConfigTableError.write(v1, into: &buf)

        case let .SerializationError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeSerdeError.write(v1, into: &buf)
        }
    }
}

extension DatabaseError: Equatable, Hashable {}

extension DatabaseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiColor {
    case red
    case blue
    case green
    case yellow
    case orange
    case purple
    case pink
    case white
    case black
    case gray
    case coolGray
    case custom(UInt8, UInt8, UInt8)
}

public struct FfiConverterTypeFfiColor: FfiConverterRustBuffer {
    typealias SwiftType = FfiColor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiColor {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .red

        case 2: return .blue

        case 3: return .green

        case 4: return .yellow

        case 5: return .orange

        case 6: return .purple

        case 7: return .pink

        case 8: return .white

        case 9: return .black

        case 10: return .gray

        case 11: return .coolGray

        case 12: return try .custom(FfiConverterUInt8.read(from: &buf), FfiConverterUInt8.read(from: &buf), FfiConverterUInt8.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiColor, into buf: inout [UInt8]) {
        switch value {
        case .red:
            writeInt(&buf, Int32(1))

        case .blue:
            writeInt(&buf, Int32(2))

        case .green:
            writeInt(&buf, Int32(3))

        case .yellow:
            writeInt(&buf, Int32(4))

        case .orange:
            writeInt(&buf, Int32(5))

        case .purple:
            writeInt(&buf, Int32(6))

        case .pink:
            writeInt(&buf, Int32(7))

        case .white:
            writeInt(&buf, Int32(8))

        case .black:
            writeInt(&buf, Int32(9))

        case .gray:
            writeInt(&buf, Int32(10))

        case .coolGray:
            writeInt(&buf, Int32(11))

        case let .custom(v1, v2, v3):
            writeInt(&buf, Int32(12))
            FfiConverterUInt8.write(v1, into: &buf)
            FfiConverterUInt8.write(v2, into: &buf)
            FfiConverterUInt8.write(v3, into: &buf)
        }
    }
}

public func FfiConverterTypeFfiColor_lift(_ buf: RustBuffer) throws -> FfiColor {
    return try FfiConverterTypeFfiColor.lift(buf)
}

public func FfiConverterTypeFfiColor_lower(_ value: FfiColor) -> RustBuffer {
    return FfiConverterTypeFfiColor.lower(value)
}

extension FfiColor: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiColorScheme {
    case light
    case dark
}

public struct FfiConverterTypeFfiColorScheme: FfiConverterRustBuffer {
    typealias SwiftType = FfiColorScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiColorScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .light

        case 2: return .dark

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiColorScheme, into buf: inout [UInt8]) {
        switch value {
        case .light:
            writeInt(&buf, Int32(1))

        case .dark:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFfiColorScheme_lift(_ buf: RustBuffer) throws -> FfiColorScheme {
    return try FfiConverterTypeFfiColorScheme.lift(buf)
}

public func FfiConverterTypeFfiColorScheme_lower(_ value: FfiColorScheme) -> RustBuffer {
    return FfiConverterTypeFfiColorScheme.lower(value)
}

extension FfiColorScheme: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FiatCurrency {
    case usd
    case eur
    case gbp
    case cad
    case chf
    case aud
    case jpy
}

public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = FiatCurrency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .usd

        case 2: return .eur

        case 3: return .gbp

        case 4: return .cad

        case 5: return .chf

        case 6: return .aud

        case 7: return .jpy

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        switch value {
        case .usd:
            writeInt(&buf, Int32(1))

        case .eur:
            writeInt(&buf, Int32(2))

        case .gbp:
            writeInt(&buf, Int32(3))

        case .cad:
            writeInt(&buf, Int32(4))

        case .chf:
            writeInt(&buf, Int32(5))

        case .aud:
            writeInt(&buf, Int32(6))

        case .jpy:
            writeInt(&buf, Int32(7))
        }
    }
}

public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}

extension FiatCurrency: Equatable, Hashable {}

public enum FingerprintError {
    case WalletNotFound
}

public struct FfiConverterTypeFingerprintError: FfiConverterRustBuffer {
    typealias SwiftType = FingerprintError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FingerprintError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .WalletNotFound

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FingerprintError, into buf: inout [UInt8]) {
        switch value {
        case .WalletNotFound:
            writeInt(&buf, Int32(1))
        }
    }
}

extension FingerprintError: Equatable, Hashable {}

extension FingerprintError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GlobalConfigKey {
    case selectedWalletId
    case selectedNetwork
    case selectedNode(Network
    )
    case colorScheme
}

public struct FfiConverterTypeGlobalConfigKey: FfiConverterRustBuffer {
    typealias SwiftType = GlobalConfigKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalConfigKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .selectedWalletId

        case 2: return .selectedNetwork

        case 3: return try .selectedNode(FfiConverterTypeNetwork.read(from: &buf)
            )

        case 4: return .colorScheme

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalConfigKey, into buf: inout [UInt8]) {
        switch value {
        case .selectedWalletId:
            writeInt(&buf, Int32(1))

        case .selectedNetwork:
            writeInt(&buf, Int32(2))

        case let .selectedNode(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNetwork.write(v1, into: &buf)

        case .colorScheme:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeGlobalConfigKey_lift(_ buf: RustBuffer) throws -> GlobalConfigKey {
    return try FfiConverterTypeGlobalConfigKey.lift(buf)
}

public func FfiConverterTypeGlobalConfigKey_lower(_ value: GlobalConfigKey) -> RustBuffer {
    return FfiConverterTypeGlobalConfigKey.lower(value)
}

extension GlobalConfigKey: Equatable, Hashable {}

public enum GlobalConfigTableError {
    case SaveError(String
    )
    case ReadError(String
    )
}

public struct FfiConverterTypeGlobalConfigTableError: FfiConverterRustBuffer {
    typealias SwiftType = GlobalConfigTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalConfigTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .SaveError(
                FfiConverterString.read(from: &buf)
            )

        case 2: return try .ReadError(
                FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalConfigTableError, into buf: inout [UInt8]) {
        switch value {
        case let .SaveError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .ReadError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension GlobalConfigTableError: Equatable, Hashable {}

extension GlobalConfigTableError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GlobalFlagKey {
    case completedOnboarding
}

public struct FfiConverterTypeGlobalFlagKey: FfiConverterRustBuffer {
    typealias SwiftType = GlobalFlagKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalFlagKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .completedOnboarding

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalFlagKey, into buf: inout [UInt8]) {
        switch value {
        case .completedOnboarding:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeGlobalFlagKey_lift(_ buf: RustBuffer) throws -> GlobalFlagKey {
    return try FfiConverterTypeGlobalFlagKey.lift(buf)
}

public func FfiConverterTypeGlobalFlagKey_lower(_ value: GlobalFlagKey) -> RustBuffer {
    return FfiConverterTypeGlobalFlagKey.lower(value)
}

extension GlobalFlagKey: Equatable, Hashable {}

public enum GlobalFlagTableError {
    case SaveError(String
    )
    case ReadError(String
    )
}

public struct FfiConverterTypeGlobalFlagTableError: FfiConverterRustBuffer {
    typealias SwiftType = GlobalFlagTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalFlagTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .SaveError(
                FfiConverterString.read(from: &buf)
            )

        case 2: return try .ReadError(
                FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalFlagTableError, into buf: inout [UInt8]) {
        switch value {
        case let .SaveError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .ReadError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension GlobalFlagTableError: Equatable, Hashable {}

extension GlobalFlagTableError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HotWalletRoute {
    case select
    case create(NumberOfBip39Words
    )
    case `import`(NumberOfBip39Words
    )
    case verifyWords(WalletId
    )
}

public struct FfiConverterTypeHotWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = HotWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HotWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .select

        case 2: return try .create(FfiConverterTypeNumberOfBip39Words.read(from: &buf)
            )

        case 3: return try .import(FfiConverterTypeNumberOfBip39Words.read(from: &buf)
            )

        case 4: return try .verifyWords(FfiConverterTypeWalletId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HotWalletRoute, into buf: inout [UInt8]) {
        switch value {
        case .select:
            writeInt(&buf, Int32(1))

        case let .create(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)

        case let .import(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)

        case let .verifyWords(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeWalletId.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeHotWalletRoute_lift(_ buf: RustBuffer) throws -> HotWalletRoute {
    return try FfiConverterTypeHotWalletRoute.lift(buf)
}

public func FfiConverterTypeHotWalletRoute_lower(_ value: HotWalletRoute) -> RustBuffer {
    return FfiConverterTypeHotWalletRoute.lower(value)
}

extension HotWalletRoute: Equatable, Hashable {}

public enum ImportWalletError {
    case WalletImportError(String
    )
    case InvalidWordGroup(String
    )
    case KeychainError(KeychainError
    )
    case WalletAlreadyExists(WalletId
    )
    case DatabaseError(DatabaseError
    )
    case BdkError(String
    )
}

public struct FfiConverterTypeImportWalletError: FfiConverterRustBuffer {
    typealias SwiftType = ImportWalletError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportWalletError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .WalletImportError(
                FfiConverterString.read(from: &buf)
            )
        case 2: return try .InvalidWordGroup(
                FfiConverterString.read(from: &buf)
            )
        case 3: return try .KeychainError(
                FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 4: return try .WalletAlreadyExists(
                FfiConverterTypeWalletId.read(from: &buf)
            )
        case 5: return try .DatabaseError(
                FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 6: return try .BdkError(
                FfiConverterString.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportWalletError, into buf: inout [UInt8]) {
        switch value {
        case let .WalletImportError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .InvalidWordGroup(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case let .KeychainError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeKeychainError.write(v1, into: &buf)

        case let .WalletAlreadyExists(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeWalletId.write(v1, into: &buf)

        case let .DatabaseError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)

        case let .BdkError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension ImportWalletError: Equatable, Hashable {}

extension ImportWalletError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ImportWalletViewModelAction {
    case noOp
}

public struct FfiConverterTypeImportWalletViewModelAction: FfiConverterRustBuffer {
    typealias SwiftType = ImportWalletViewModelAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportWalletViewModelAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .noOp

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportWalletViewModelAction, into buf: inout [UInt8]) {
        switch value {
        case .noOp:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeImportWalletViewModelAction_lift(_ buf: RustBuffer) throws -> ImportWalletViewModelAction {
    return try FfiConverterTypeImportWalletViewModelAction.lift(buf)
}

public func FfiConverterTypeImportWalletViewModelAction_lower(_ value: ImportWalletViewModelAction) -> RustBuffer {
    return FfiConverterTypeImportWalletViewModelAction.lower(value)
}

extension ImportWalletViewModelAction: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ImportWalletViewModelReconcileMessage {
    case noOp
}

public struct FfiConverterTypeImportWalletViewModelReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = ImportWalletViewModelReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportWalletViewModelReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .noOp

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportWalletViewModelReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        case .noOp:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeImportWalletViewModelReconcileMessage_lift(_ buf: RustBuffer) throws -> ImportWalletViewModelReconcileMessage {
    return try FfiConverterTypeImportWalletViewModelReconcileMessage.lift(buf)
}

public func FfiConverterTypeImportWalletViewModelReconcileMessage_lower(_ value: ImportWalletViewModelReconcileMessage) -> RustBuffer {
    return FfiConverterTypeImportWalletViewModelReconcileMessage.lower(value)
}

extension ImportWalletViewModelReconcileMessage: Equatable, Hashable {}

public enum KeychainError {
    case UnableToSave
    case UnableToDelete
    case UnableToParseSavedValue(String
    )
    case UnableToEncrypt(String
    )
    case UnableToDecrypt(String
    )
}

public struct FfiConverterTypeKeychainError: FfiConverterRustBuffer {
    typealias SwiftType = KeychainError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeychainError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .UnableToSave
        case 2: return .UnableToDelete
        case 3: return try .UnableToParseSavedValue(
                FfiConverterString.read(from: &buf)
            )
        case 4: return try .UnableToEncrypt(
                FfiConverterString.read(from: &buf)
            )
        case 5: return try .UnableToDecrypt(
                FfiConverterString.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeychainError, into buf: inout [UInt8]) {
        switch value {
        case .UnableToSave:
            writeInt(&buf, Int32(1))

        case .UnableToDelete:
            writeInt(&buf, Int32(2))

        case let .UnableToParseSavedValue(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)

        case let .UnableToEncrypt(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)

        case let .UnableToDecrypt(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension KeychainError: Equatable, Hashable {}

extension KeychainError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

public enum MnemonicError {
    case GetWalletKeychain(KeychainError
    )
    case NotAvailable(WalletId
    )
}

public struct FfiConverterTypeMnemonicError: FfiConverterRustBuffer {
    typealias SwiftType = MnemonicError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .GetWalletKeychain(
                FfiConverterTypeKeychainError.read(from: &buf)
            )

        case 2: return try .NotAvailable(
                FfiConverterTypeWalletId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MnemonicError, into buf: inout [UInt8]) {
        switch value {
        case let .GetWalletKeychain(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeKeychainError.write(v1, into: &buf)

        case let .NotAvailable(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletId.write(v1, into: &buf)
        }
    }
}

extension MnemonicError: Equatable, Hashable {}

extension MnemonicError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    case bitcoin
    case testnet
}

public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .bitcoin

        case 2: return .testnet

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        case .bitcoin:
            writeInt(&buf, Int32(1))

        case .testnet:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}

extension Network: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NewWalletRoute {
    case select
    case hotWallet(HotWalletRoute
    )
    case coldWallet(ColdWalletRoute
    )
}

public struct FfiConverterTypeNewWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = NewWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .select

        case 2: return try .hotWallet(FfiConverterTypeHotWalletRoute.read(from: &buf)
            )

        case 3: return try .coldWallet(FfiConverterTypeColdWalletRoute.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NewWalletRoute, into buf: inout [UInt8]) {
        switch value {
        case .select:
            writeInt(&buf, Int32(1))

        case let .hotWallet(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeHotWalletRoute.write(v1, into: &buf)

        case let .coldWallet(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeColdWalletRoute.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeNewWalletRoute_lift(_ buf: RustBuffer) throws -> NewWalletRoute {
    return try FfiConverterTypeNewWalletRoute.lift(buf)
}

public func FfiConverterTypeNewWalletRoute_lower(_ value: NewWalletRoute) -> RustBuffer {
    return FfiConverterTypeNewWalletRoute.lower(value)
}

extension NewWalletRoute: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NodeSelection {
    case preset(Node
    )
    case custom(Node
    )
}

public struct FfiConverterTypeNodeSelection: FfiConverterRustBuffer {
    typealias SwiftType = NodeSelection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeSelection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .preset(FfiConverterTypeNode.read(from: &buf)
            )

        case 2: return try .custom(FfiConverterTypeNode.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeSelection, into buf: inout [UInt8]) {
        switch value {
        case let .preset(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNode.write(v1, into: &buf)

        case let .custom(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNode.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeNodeSelection_lift(_ buf: RustBuffer) throws -> NodeSelection {
    return try FfiConverterTypeNodeSelection.lift(buf)
}

public func FfiConverterTypeNodeSelection_lower(_ value: NodeSelection) -> RustBuffer {
    return FfiConverterTypeNodeSelection.lower(value)
}

extension NodeSelection: Equatable, Hashable {}

public enum NodeSelectorError {
    case NodeNotFound(String
    )
    case SetSelectedNodeError(String
    )
    case NodeAccessError(String
    )
    case ParseNodeUrlError(String
    )
}

public struct FfiConverterTypeNodeSelectorError: FfiConverterRustBuffer {
    typealias SwiftType = NodeSelectorError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeSelectorError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .NodeNotFound(
                FfiConverterString.read(from: &buf)
            )
        case 2: return try .SetSelectedNodeError(
                FfiConverterString.read(from: &buf)
            )
        case 3: return try .NodeAccessError(
                FfiConverterString.read(from: &buf)
            )
        case 4: return try .ParseNodeUrlError(
                FfiConverterString.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeSelectorError, into buf: inout [UInt8]) {
        switch value {
        case let .NodeNotFound(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .SetSelectedNodeError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case let .NodeAccessError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)

        case let .ParseNodeUrlError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension NodeSelectorError: Equatable, Hashable {}

extension NodeSelectorError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NumberOfBip39Words {
    case twelve
    case twentyFour
}

public struct FfiConverterTypeNumberOfBip39Words: FfiConverterRustBuffer {
    typealias SwiftType = NumberOfBip39Words

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NumberOfBip39Words {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .twelve

        case 2: return .twentyFour

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NumberOfBip39Words, into buf: inout [UInt8]) {
        switch value {
        case .twelve:
            writeInt(&buf, Int32(1))

        case .twentyFour:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeNumberOfBip39Words_lift(_ buf: RustBuffer) throws -> NumberOfBip39Words {
    return try FfiConverterTypeNumberOfBip39Words.lift(buf)
}

public func FfiConverterTypeNumberOfBip39Words_lower(_ value: NumberOfBip39Words) -> RustBuffer {
    return FfiConverterTypeNumberOfBip39Words.lower(value)
}

extension NumberOfBip39Words: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingOrConfirmed {
    case pending(PendingDetails
    )
    case confirmed(ConfirmedDetails
    )
}

public struct FfiConverterTypePendingOrConfirmed: FfiConverterRustBuffer {
    typealias SwiftType = PendingOrConfirmed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingOrConfirmed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .pending(FfiConverterTypePendingDetails.read(from: &buf)
            )

        case 2: return try .confirmed(FfiConverterTypeConfirmedDetails.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingOrConfirmed, into buf: inout [UInt8]) {
        switch value {
        case let .pending(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypePendingDetails.write(v1, into: &buf)

        case let .confirmed(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeConfirmedDetails.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypePendingOrConfirmed_lift(_ buf: RustBuffer) throws -> PendingOrConfirmed {
    return try FfiConverterTypePendingOrConfirmed.lift(buf)
}

public func FfiConverterTypePendingOrConfirmed_lower(_ value: PendingOrConfirmed) -> RustBuffer {
    return FfiConverterTypePendingOrConfirmed.lower(value)
}

extension PendingOrConfirmed: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingWalletViewModelAction {
    case updateWords(NumberOfBip39Words
    )
}

public struct FfiConverterTypePendingWalletViewModelAction: FfiConverterRustBuffer {
    typealias SwiftType = PendingWalletViewModelAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletViewModelAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .updateWords(FfiConverterTypeNumberOfBip39Words.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingWalletViewModelAction, into buf: inout [UInt8]) {
        switch value {
        case let .updateWords(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypePendingWalletViewModelAction_lift(_ buf: RustBuffer) throws -> PendingWalletViewModelAction {
    return try FfiConverterTypePendingWalletViewModelAction.lift(buf)
}

public func FfiConverterTypePendingWalletViewModelAction_lower(_ value: PendingWalletViewModelAction) -> RustBuffer {
    return FfiConverterTypePendingWalletViewModelAction.lower(value)
}

extension PendingWalletViewModelAction: Equatable, Hashable {}

public enum PendingWalletViewModelError {
    case BdkError(String
    )
    case WalletCreationError(WalletCreationError
    )
}

public struct FfiConverterTypePendingWalletViewModelError: FfiConverterRustBuffer {
    typealias SwiftType = PendingWalletViewModelError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletViewModelError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .BdkError(
                FfiConverterString.read(from: &buf)
            )

        case 2: return try .WalletCreationError(
                FfiConverterTypeWalletCreationError.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingWalletViewModelError, into buf: inout [UInt8]) {
        switch value {
        case let .BdkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .WalletCreationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletCreationError.write(v1, into: &buf)
        }
    }
}

extension PendingWalletViewModelError: Equatable, Hashable {}

extension PendingWalletViewModelError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingWalletViewModelReconcileMessage {
    case words(NumberOfBip39Words
    )
}

public struct FfiConverterTypePendingWalletViewModelReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = PendingWalletViewModelReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletViewModelReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .words(FfiConverterTypeNumberOfBip39Words.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingWalletViewModelReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        case let .words(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypePendingWalletViewModelReconcileMessage_lift(_ buf: RustBuffer) throws -> PendingWalletViewModelReconcileMessage {
    return try FfiConverterTypePendingWalletViewModelReconcileMessage.lift(buf)
}

public func FfiConverterTypePendingWalletViewModelReconcileMessage_lower(_ value: PendingWalletViewModelReconcileMessage) -> RustBuffer {
    return FfiConverterTypePendingWalletViewModelReconcileMessage.lower(value)
}

extension PendingWalletViewModelReconcileMessage: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Route {
    case listWallets
    case selectedWallet(WalletId
    )
    case newWallet(NewWalletRoute
    )
    case settings
    case secretWords(WalletId
    )
    case transactionDetails(id: WalletId, details: TransactionDetails)
}

public struct FfiConverterTypeRoute: FfiConverterRustBuffer {
    typealias SwiftType = Route

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Route {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .listWallets

        case 2: return try .selectedWallet(FfiConverterTypeWalletId.read(from: &buf)
            )

        case 3: return try .newWallet(FfiConverterTypeNewWalletRoute.read(from: &buf)
            )

        case 4: return .settings

        case 5: return try .secretWords(FfiConverterTypeWalletId.read(from: &buf)
            )

        case 6: return try .transactionDetails(id: FfiConverterTypeWalletId.read(from: &buf), details: FfiConverterTypeTransactionDetails.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Route, into buf: inout [UInt8]) {
        switch value {
        case .listWallets:
            writeInt(&buf, Int32(1))

        case let .selectedWallet(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletId.write(v1, into: &buf)

        case let .newWallet(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNewWalletRoute.write(v1, into: &buf)

        case .settings:
            writeInt(&buf, Int32(4))

        case let .secretWords(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeWalletId.write(v1, into: &buf)

        case let .transactionDetails(id, details):
            writeInt(&buf, Int32(6))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterTypeTransactionDetails.write(details, into: &buf)
        }
    }
}

public func FfiConverterTypeRoute_lift(_ buf: RustBuffer) throws -> Route {
    return try FfiConverterTypeRoute.lift(buf)
}

public func FfiConverterTypeRoute_lower(_ value: Route) -> RustBuffer {
    return FfiConverterTypeRoute.lower(value)
}

public enum SerdeError {
    case SerializationError(String
    )
    case DeserializationError(String
    )
}

public struct FfiConverterTypeSerdeError: FfiConverterRustBuffer {
    typealias SwiftType = SerdeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SerdeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .SerializationError(
                FfiConverterString.read(from: &buf)
            )

        case 2: return try .DeserializationError(
                FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SerdeError, into buf: inout [UInt8]) {
        switch value {
        case let .SerializationError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .DeserializationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension SerdeError: Equatable, Hashable {}

extension SerdeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Transaction {
    case confirmed(ConfirmedTransaction
    )
    case unconfirmed(UnconfirmedTransaction
    )
}

public struct FfiConverterTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = Transaction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transaction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .confirmed(FfiConverterTypeConfirmedTransaction.read(from: &buf)
            )

        case 2: return try .unconfirmed(FfiConverterTypeUnconfirmedTransaction.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Transaction, into buf: inout [UInt8]) {
        switch value {
        case let .confirmed(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeConfirmedTransaction.write(v1, into: &buf)

        case let .unconfirmed(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUnconfirmedTransaction.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeTransaction_lift(_ buf: RustBuffer) throws -> Transaction {
    return try FfiConverterTypeTransaction.lift(buf)
}

public func FfiConverterTypeTransaction_lower(_ value: Transaction) -> RustBuffer {
    return FfiConverterTypeTransaction.lower(value)
}

public enum TransactionDetailError {
    case FeeError(String
    )
    case FeeRateError(String
    )
    case AddressError(AddressError
    )
    case FiatAmountError(String
    )
}

public struct FfiConverterTypeTransactionDetailError: FfiConverterRustBuffer {
    typealias SwiftType = TransactionDetailError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDetailError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .FeeError(
                FfiConverterString.read(from: &buf)
            )
        case 2: return try .FeeRateError(
                FfiConverterString.read(from: &buf)
            )
        case 3: return try .AddressError(
                FfiConverterTypeAddressError.read(from: &buf)
            )
        case 4: return try .FiatAmountError(
                FfiConverterString.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionDetailError, into buf: inout [UInt8]) {
        switch value {
        case let .FeeError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .FeeRateError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case let .AddressError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAddressError.write(v1, into: &buf)

        case let .FiatAmountError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension TransactionDetailError: Equatable, Hashable {}

extension TransactionDetailError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionDirection {
    case incoming
    case outgoing
}

public struct FfiConverterTypeTransactionDirection: FfiConverterRustBuffer {
    typealias SwiftType = TransactionDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .incoming

        case 2: return .outgoing

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionDirection, into buf: inout [UInt8]) {
        switch value {
        case .incoming:
            writeInt(&buf, Int32(1))

        case .outgoing:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeTransactionDirection_lift(_ buf: RustBuffer) throws -> TransactionDirection {
    return try FfiConverterTypeTransactionDirection.lift(buf)
}

public func FfiConverterTypeTransactionDirection_lower(_ value: TransactionDirection) -> RustBuffer {
    return FfiConverterTypeTransactionDirection.lower(value)
}

extension TransactionDirection: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionState {
    case pending
    case confirmed
}

public struct FfiConverterTypeTransactionState: FfiConverterRustBuffer {
    typealias SwiftType = TransactionState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .pending

        case 2: return .confirmed

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionState, into buf: inout [UInt8]) {
        switch value {
        case .pending:
            writeInt(&buf, Int32(1))

        case .confirmed:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeTransactionState_lift(_ buf: RustBuffer) throws -> TransactionState {
    return try FfiConverterTypeTransactionState.lift(buf)
}

public func FfiConverterTypeTransactionState_lower(_ value: TransactionState) -> RustBuffer {
    return FfiConverterTypeTransactionState.lower(value)
}

extension TransactionState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Unit {
    case btc
    case sat
}

public struct FfiConverterTypeUnit: FfiConverterRustBuffer {
    typealias SwiftType = Unit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .btc

        case 2: return .sat

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Unit, into buf: inout [UInt8]) {
        switch value {
        case .btc:
            writeInt(&buf, Int32(1))

        case .sat:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeUnit_lift(_ buf: RustBuffer) throws -> Unit {
    return try FfiConverterTypeUnit.lift(buf)
}

public func FfiConverterTypeUnit_lower(_ value: Unit) -> RustBuffer {
    return FfiConverterTypeUnit.lower(value)
}

extension Unit: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletColor {
    case red
    case blue
    case green
    case yellow
    case orange
    case purple
    case pink
    case custom(r: UInt8, g: UInt8, b: UInt8)
}

public struct FfiConverterTypeWalletColor: FfiConverterRustBuffer {
    typealias SwiftType = WalletColor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletColor {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .red

        case 2: return .blue

        case 3: return .green

        case 4: return .yellow

        case 5: return .orange

        case 6: return .purple

        case 7: return .pink

        case 8: return try .custom(r: FfiConverterUInt8.read(from: &buf), g: FfiConverterUInt8.read(from: &buf), b: FfiConverterUInt8.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletColor, into buf: inout [UInt8]) {
        switch value {
        case .red:
            writeInt(&buf, Int32(1))

        case .blue:
            writeInt(&buf, Int32(2))

        case .green:
            writeInt(&buf, Int32(3))

        case .yellow:
            writeInt(&buf, Int32(4))

        case .orange:
            writeInt(&buf, Int32(5))

        case .purple:
            writeInt(&buf, Int32(6))

        case .pink:
            writeInt(&buf, Int32(7))

        case let .custom(r, g, b):
            writeInt(&buf, Int32(8))
            FfiConverterUInt8.write(r, into: &buf)
            FfiConverterUInt8.write(g, into: &buf)
            FfiConverterUInt8.write(b, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletColor_lift(_ buf: RustBuffer) throws -> WalletColor {
    return try FfiConverterTypeWalletColor.lift(buf)
}

public func FfiConverterTypeWalletColor_lower(_ value: WalletColor) -> RustBuffer {
    return FfiConverterTypeWalletColor.lower(value)
}

extension WalletColor: Equatable, Hashable {}

public enum WalletCreationError {
    case BdkError(String
    )
    case KeychainError(KeychainError
    )
    case DatabaseError(DatabaseError
    )
    case PersisError(String
    )
}

public struct FfiConverterTypeWalletCreationError: FfiConverterRustBuffer {
    typealias SwiftType = WalletCreationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletCreationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .BdkError(
                FfiConverterString.read(from: &buf)
            )
        case 2: return try .KeychainError(
                FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 3: return try .DatabaseError(
                FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 4: return try .PersisError(
                FfiConverterString.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletCreationError, into buf: inout [UInt8]) {
        switch value {
        case let .BdkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .KeychainError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeKeychainError.write(v1, into: &buf)

        case let .DatabaseError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)

        case let .PersisError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension WalletCreationError: Equatable, Hashable {}

extension WalletCreationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

public enum WalletError {
    case BdkError(String
    )
    case UnsupportedWallet(String
    )
    case PersistError(String
    )
    case LoadError(String
    )
    case KeychainError(KeychainError
    )
    case DatabaseError(DatabaseError
    )
    case WalletNotFound
    case MetadataNotFound
}

public struct FfiConverterTypeWalletError: FfiConverterRustBuffer {
    typealias SwiftType = WalletError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .BdkError(
                FfiConverterString.read(from: &buf)
            )
        case 2: return try .UnsupportedWallet(
                FfiConverterString.read(from: &buf)
            )
        case 3: return try .PersistError(
                FfiConverterString.read(from: &buf)
            )
        case 4: return try .LoadError(
                FfiConverterString.read(from: &buf)
            )
        case 5: return try .KeychainError(
                FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 6: return try .DatabaseError(
                FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 7: return .WalletNotFound
        case 8: return .MetadataNotFound
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletError, into buf: inout [UInt8]) {
        switch value {
        case let .BdkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .UnsupportedWallet(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case let .PersistError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)

        case let .LoadError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)

        case let .KeychainError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeKeychainError.write(v1, into: &buf)

        case let .DatabaseError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)

        case .WalletNotFound:
            writeInt(&buf, Int32(7))

        case .MetadataNotFound:
            writeInt(&buf, Int32(8))
        }
    }
}

extension WalletError: Equatable, Hashable {}

extension WalletError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletErrorAlert {
    case nodeConnectionFailed(String
    )
}

public struct FfiConverterTypeWalletErrorAlert: FfiConverterRustBuffer {
    typealias SwiftType = WalletErrorAlert

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletErrorAlert {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .nodeConnectionFailed(FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletErrorAlert, into buf: inout [UInt8]) {
        switch value {
        case let .nodeConnectionFailed(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletErrorAlert_lift(_ buf: RustBuffer) throws -> WalletErrorAlert {
    return try FfiConverterTypeWalletErrorAlert.lift(buf)
}

public func FfiConverterTypeWalletErrorAlert_lower(_ value: WalletErrorAlert) -> RustBuffer {
    return FfiConverterTypeWalletErrorAlert.lower(value)
}

extension WalletErrorAlert: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletLoadState {
    case loading
    case scanning([Transaction]
    )
    case loaded([Transaction]
    )
}

public struct FfiConverterTypeWalletLoadState: FfiConverterRustBuffer {
    typealias SwiftType = WalletLoadState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletLoadState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .loading

        case 2: return try .scanning(FfiConverterSequenceTypeTransaction.read(from: &buf)
            )

        case 3: return try .loaded(FfiConverterSequenceTypeTransaction.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletLoadState, into buf: inout [UInt8]) {
        switch value {
        case .loading:
            writeInt(&buf, Int32(1))

        case let .scanning(v1):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)

        case let .loaded(v1):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletLoadState_lift(_ buf: RustBuffer) throws -> WalletLoadState {
    return try FfiConverterTypeWalletLoadState.lift(buf)
}

public func FfiConverterTypeWalletLoadState_lower(_ value: WalletLoadState) -> RustBuffer {
    return FfiConverterTypeWalletLoadState.lower(value)
}

public enum WalletTableError {
    case SaveError(String
    )
    case ReadError(String
    )
}

public struct FfiConverterTypeWalletTableError: FfiConverterRustBuffer {
    typealias SwiftType = WalletTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .SaveError(
                FfiConverterString.read(from: &buf)
            )

        case 2: return try .ReadError(
                FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletTableError, into buf: inout [UInt8]) {
        switch value {
        case let .SaveError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .ReadError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension WalletTableError: Equatable, Hashable {}

extension WalletTableError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletViewModelAction {
    case updateName(String
    )
    case updateColor(WalletColor
    )
    case updateUnit(Unit
    )
    case updateFiatCurrency(String
    )
    case toggleSensitiveVisibility
    case toggleDetailsExpanded
}

public struct FfiConverterTypeWalletViewModelAction: FfiConverterRustBuffer {
    typealias SwiftType = WalletViewModelAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletViewModelAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .updateName(FfiConverterString.read(from: &buf)
            )

        case 2: return try .updateColor(FfiConverterTypeWalletColor.read(from: &buf)
            )

        case 3: return try .updateUnit(FfiConverterTypeUnit.read(from: &buf)
            )

        case 4: return try .updateFiatCurrency(FfiConverterString.read(from: &buf)
            )

        case 5: return .toggleSensitiveVisibility

        case 6: return .toggleDetailsExpanded

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletViewModelAction, into buf: inout [UInt8]) {
        switch value {
        case let .updateName(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .updateColor(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletColor.write(v1, into: &buf)

        case let .updateUnit(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUnit.write(v1, into: &buf)

        case let .updateFiatCurrency(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)

        case .toggleSensitiveVisibility:
            writeInt(&buf, Int32(5))

        case .toggleDetailsExpanded:
            writeInt(&buf, Int32(6))
        }
    }
}

public func FfiConverterTypeWalletViewModelAction_lift(_ buf: RustBuffer) throws -> WalletViewModelAction {
    return try FfiConverterTypeWalletViewModelAction.lift(buf)
}

public func FfiConverterTypeWalletViewModelAction_lower(_ value: WalletViewModelAction) -> RustBuffer {
    return FfiConverterTypeWalletViewModelAction.lower(value)
}

extension WalletViewModelAction: Equatable, Hashable {}

public enum WalletViewModelError {
    case GetSelectedWalletError(String
    )
    case WalletDoesNotExist
    case SecretRetrievalError(KeychainError
    )
    case MarkWalletAsVerifiedError(DatabaseError
    )
    case LoadWalletError(WalletError
    )
    case NodeConnectionFailed(String
    )
    case WalletScanError(String
    )
    case TransactionsRetrievalError(String
    )
    case WalletBalanceError(String
    )
    case NextAddressError(String
    )
    case GetHeightError
    case TransactionDetailsError(String
    )
}

public struct FfiConverterTypeWalletViewModelError: FfiConverterRustBuffer {
    typealias SwiftType = WalletViewModelError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletViewModelError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .GetSelectedWalletError(
                FfiConverterString.read(from: &buf)
            )
        case 2: return .WalletDoesNotExist
        case 3: return try .SecretRetrievalError(
                FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 4: return try .MarkWalletAsVerifiedError(
                FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 5: return try .LoadWalletError(
                FfiConverterTypeWalletError.read(from: &buf)
            )
        case 6: return try .NodeConnectionFailed(
                FfiConverterString.read(from: &buf)
            )
        case 7: return try .WalletScanError(
                FfiConverterString.read(from: &buf)
            )
        case 8: return try .TransactionsRetrievalError(
                FfiConverterString.read(from: &buf)
            )
        case 9: return try .WalletBalanceError(
                FfiConverterString.read(from: &buf)
            )
        case 10: return try .NextAddressError(
                FfiConverterString.read(from: &buf)
            )
        case 11: return .GetHeightError
        case 12: return try .TransactionDetailsError(
                FfiConverterString.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletViewModelError, into buf: inout [UInt8]) {
        switch value {
        case let .GetSelectedWalletError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case .WalletDoesNotExist:
            writeInt(&buf, Int32(2))

        case let .SecretRetrievalError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeKeychainError.write(v1, into: &buf)

        case let .MarkWalletAsVerifiedError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)

        case let .LoadWalletError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeWalletError.write(v1, into: &buf)

        case let .NodeConnectionFailed(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)

        case let .WalletScanError(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)

        case let .TransactionsRetrievalError(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)

        case let .WalletBalanceError(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)

        case let .NextAddressError(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)

        case .GetHeightError:
            writeInt(&buf, Int32(11))

        case let .TransactionDetailsError(v1):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension WalletViewModelError: Equatable, Hashable {}

extension WalletViewModelError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletViewModelReconcileMessage {
    case startedWalletScan
    case availableTransactions([Transaction]
    )
    case scanComplete([Transaction]
    )
    case nodeConnectionFailed(String
    )
    case walletMetadataChanged(WalletMetadata
    )
    case walletBalanceChanged(Balance
    )
    case walletError(WalletViewModelError
    )
    case unknownError(String
    )
}

public struct FfiConverterTypeWalletViewModelReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = WalletViewModelReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletViewModelReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .startedWalletScan

        case 2: return try .availableTransactions(FfiConverterSequenceTypeTransaction.read(from: &buf)
            )

        case 3: return try .scanComplete(FfiConverterSequenceTypeTransaction.read(from: &buf)
            )

        case 4: return try .nodeConnectionFailed(FfiConverterString.read(from: &buf)
            )

        case 5: return try .walletMetadataChanged(FfiConverterTypeWalletMetadata.read(from: &buf)
            )

        case 6: return try .walletBalanceChanged(FfiConverterTypeBalance.read(from: &buf)
            )

        case 7: return try .walletError(FfiConverterTypeWalletViewModelError.read(from: &buf)
            )

        case 8: return try .unknownError(FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletViewModelReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        case .startedWalletScan:
            writeInt(&buf, Int32(1))

        case let .availableTransactions(v1):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)

        case let .scanComplete(v1):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)

        case let .nodeConnectionFailed(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)

        case let .walletMetadataChanged(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeWalletMetadata.write(v1, into: &buf)

        case let .walletBalanceChanged(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeBalance.write(v1, into: &buf)

        case let .walletError(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeWalletViewModelError.write(v1, into: &buf)

        case let .unknownError(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletViewModelReconcileMessage_lift(_ buf: RustBuffer) throws -> WalletViewModelReconcileMessage {
    return try FfiConverterTypeWalletViewModelReconcileMessage.lift(buf)
}

public func FfiConverterTypeWalletViewModelReconcileMessage_lower(_ value: WalletViewModelReconcileMessage) -> RustBuffer {
    return FfiConverterTypeWalletViewModelReconcileMessage.lower(value)
}

public protocol FfiReconcile: AnyObject {
    /**
     * Essentially a callback to the frontend
     */
    func reconcile(message: AppStateReconcileMessage)
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceFfiReconcile {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFfiReconcile = .init(
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceFfiReconcile.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.reconcile(
                    message: FfiConverterTypeAppStateReconcileMessage.lift(message)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceFfiReconcile.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiReconcile: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFfiReconcile() {
    uniffi_cove_fn_init_callback_vtable_ffireconcile(&UniffiCallbackInterfaceFfiReconcile.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiReconcile {
    fileprivate static var handleMap = UniffiHandleMap<FfiReconcile>()
}

extension FfiConverterCallbackInterfaceFfiReconcile: FfiConverter {
    typealias SwiftType = FfiReconcile
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol ImportWalletViewModelReconciler: AnyObject {
    /**
     * Tells the frontend to reconcile the view model changes
     */
    func reconcile(message: ImportWalletViewModelReconcileMessage)
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceImportWalletViewModelReconciler {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceImportWalletViewModelReconciler = .init(
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceImportWalletViewModelReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.reconcile(
                    message: FfiConverterTypeImportWalletViewModelReconcileMessage.lift(message)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceImportWalletViewModelReconciler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ImportWalletViewModelReconciler: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitImportWalletViewModelReconciler() {
    uniffi_cove_fn_init_callback_vtable_importwalletviewmodelreconciler(&UniffiCallbackInterfaceImportWalletViewModelReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceImportWalletViewModelReconciler {
    fileprivate static var handleMap = UniffiHandleMap<ImportWalletViewModelReconciler>()
}

extension FfiConverterCallbackInterfaceImportWalletViewModelReconciler: FfiConverter {
    typealias SwiftType = ImportWalletViewModelReconciler
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol KeychainAccess: AnyObject {
    func save(key: String, value: String) throws

    func get(key: String) -> String?

    func delete(key: String) -> Bool
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceKeychainAccess {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceKeychainAccess = .init(
        save: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            value: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceKeychainAccess.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.save(
                    key: FfiConverterString.lift(key),
                    value: FfiConverterString.lift(value)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeKeychainError.lower
            )
        },
        get: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String? in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceKeychainAccess.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.get(
                    key: FfiConverterString.lift(key)
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        delete: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceKeychainAccess.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.delete(
                    key: FfiConverterString.lift(key)
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceKeychainAccess.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface KeychainAccess: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitKeychainAccess() {
    uniffi_cove_fn_init_callback_vtable_keychainaccess(&UniffiCallbackInterfaceKeychainAccess.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceKeychainAccess {
    fileprivate static var handleMap = UniffiHandleMap<KeychainAccess>()
}

extension FfiConverterCallbackInterfaceKeychainAccess: FfiConverter {
    typealias SwiftType = KeychainAccess
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol PendingWalletViewModelReconciler: AnyObject {
    /**
     * Tells the frontend to reconcile the view model changes
     */
    func reconcile(message: PendingWalletViewModelReconcileMessage)
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfacePendingWalletViewModelReconciler {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfacePendingWalletViewModelReconciler = .init(
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePendingWalletViewModelReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.reconcile(
                    message: FfiConverterTypePendingWalletViewModelReconcileMessage.lift(message)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfacePendingWalletViewModelReconciler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PendingWalletViewModelReconciler: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitPendingWalletViewModelReconciler() {
    uniffi_cove_fn_init_callback_vtable_pendingwalletviewmodelreconciler(&UniffiCallbackInterfacePendingWalletViewModelReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfacePendingWalletViewModelReconciler {
    fileprivate static var handleMap = UniffiHandleMap<PendingWalletViewModelReconciler>()
}

extension FfiConverterCallbackInterfacePendingWalletViewModelReconciler: FfiConverter {
    typealias SwiftType = PendingWalletViewModelReconciler
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol WalletViewModelReconciler: AnyObject {
    /**
     * Tells the frontend to reconcile the view model changes
     */
    func reconcile(message: WalletViewModelReconcileMessage)
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceWalletViewModelReconciler {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceWalletViewModelReconciler = .init(
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceWalletViewModelReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.reconcile(
                    message: FfiConverterTypeWalletViewModelReconcileMessage.lift(message)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceWalletViewModelReconciler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface WalletViewModelReconciler: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitWalletViewModelReconciler() {
    uniffi_cove_fn_init_callback_vtable_walletviewmodelreconciler(&UniffiCallbackInterfaceWalletViewModelReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceWalletViewModelReconciler {
    fileprivate static var handleMap = UniffiHandleMap<WalletViewModelReconciler>()
}

extension FfiConverterCallbackInterfaceWalletViewModelReconciler: FfiConverter {
    typealias SwiftType = WalletViewModelReconciler
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

private struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeAddressIndex: FfiConverterRustBuffer {
    typealias SwiftType = AddressIndex?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAddressIndex.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAddressIndex.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeWalletId: FfiConverterRustBuffer {
    typealias SwiftType = WalletId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeGroupedWord: FfiConverterRustBuffer {
    typealias SwiftType = [GroupedWord]

    public static func write(_ value: [GroupedWord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGroupedWord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GroupedWord] {
        let len: Int32 = try readInt(&buf)
        var seq = [GroupedWord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeGroupedWord.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeWalletMetadata: FfiConverterRustBuffer {
    typealias SwiftType = [WalletMetadata]

    public static func write(_ value: [WalletMetadata], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletMetadata.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletMetadata] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletMetadata]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeWalletMetadata.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeColorSchemeSelection: FfiConverterRustBuffer {
    typealias SwiftType = [ColorSchemeSelection]

    public static func write(_ value: [ColorSchemeSelection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeColorSchemeSelection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ColorSchemeSelection] {
        let len: Int32 = try readInt(&buf)
        var seq = [ColorSchemeSelection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeColorSchemeSelection.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [Network]

    public static func write(_ value: [Network], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Network] {
        let len: Int32 = try readInt(&buf)
        var seq = [Network]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNetwork.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNodeSelection: FfiConverterRustBuffer {
    typealias SwiftType = [NodeSelection]

    public static func write(_ value: [NodeSelection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeSelection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeSelection] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeSelection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNodeSelection.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeRoute: FfiConverterRustBuffer {
    typealias SwiftType = [Route]

    public static func write(_ value: [Route], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoute.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Route] {
        let len: Int32 = try readInt(&buf)
        var seq = [Route]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeRoute.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [Transaction]

    public static func write(_ value: [Transaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Transaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Transaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTransaction.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeUnit: FfiConverterRustBuffer {
    typealias SwiftType = [Unit]

    public static func write(_ value: [Unit], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnit.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Unit] {
        let len: Int32 = try readInt(&buf)
        var seq = [Unit]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeUnit.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]

    public static func write(_ value: [[String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterSequenceString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceSequenceTypeGroupedWord: FfiConverterRustBuffer {
    typealias SwiftType = [[GroupedWord]]

    public static func write(_ value: [[GroupedWord]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypeGroupedWord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[GroupedWord]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[GroupedWord]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterSequenceTypeGroupedWord.read(from: &buf))
        }
        return seq
    }
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletId = String
public struct FfiConverterTypeWalletId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: WalletId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> WalletId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: WalletId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeWalletId_lift(_ value: RustBuffer) throws -> WalletId {
    return try FfiConverterTypeWalletId.lift(value)
}

public func FfiConverterTypeWalletId_lower(_ value: WalletId) -> RustBuffer {
    return FfiConverterTypeWalletId.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

private func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> Void,
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> Void,
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

public func allColorSchemes() -> [ColorSchemeSelection] {
    return try! FfiConverterSequenceTypeColorSchemeSelection.lift(try! rustCall {
        uniffi_cove_fn_func_all_color_schemes($0
        )
    })
}

public func allNetworks() -> [Network] {
    return try! FfiConverterSequenceTypeNetwork.lift(try! rustCall {
        uniffi_cove_fn_func_all_networks($0
        )
    })
}

public func allUnits() -> [Unit] {
    return try! FfiConverterSequenceTypeUnit.lift(try! rustCall {
        uniffi_cove_fn_func_all_units($0
        )
    })
}

public func balanceZero() -> Balance {
    return try! FfiConverterTypeBalance.lift(try! rustCall {
        uniffi_cove_fn_func_balance_zero($0
        )
    })
}

public func colorSchemeSelectionCapitalizedString(colorScheme: ColorSchemeSelection) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_cove_fn_func_color_scheme_selection_capitalized_string(
            FfiConverterTypeColorSchemeSelection.lower(colorScheme), $0
        )
    })
}

public func defaultNodeSelection() -> NodeSelection {
    return try! FfiConverterTypeNodeSelection.lift(try! rustCall {
        uniffi_cove_fn_func_default_node_selection($0
        )
    })
}

public func hashRoute(route: Route) -> UInt64 {
    return try! FfiConverterUInt64.lift(try! rustCall {
        uniffi_cove_fn_func_hash_route(
            FfiConverterTypeRoute.lower(route), $0
        )
    })
}

public func isRouteEqual(route: Route, routeToCheck: Route) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_cove_fn_func_is_route_equal(
            FfiConverterTypeRoute.lower(route),
            FfiConverterTypeRoute.lower(routeToCheck), $0
        )
    })
}

public func networkToString(network: Network) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_cove_fn_func_network_to_string(
            FfiConverterTypeNetwork.lower(network), $0
        )
    })
}

public func nodeSelectionToNode(node: NodeSelection) -> Node {
    return try! FfiConverterTypeNode.lift(try! rustCall {
        uniffi_cove_fn_func_node_selection_to_node(
            FfiConverterTypeNodeSelection.lower(node), $0
        )
    })
}

public func numberOfWordsInGroups(me: NumberOfBip39Words, of: UInt8) -> [[String]] {
    return try! FfiConverterSequenceSequenceString.lift(try! rustCall {
        uniffi_cove_fn_func_number_of_words_in_groups(
            FfiConverterTypeNumberOfBip39Words.lower(me),
            FfiConverterUInt8.lower(of), $0
        )
    })
}

public func numberOfWordsToWordCount(me: NumberOfBip39Words) -> UInt8 {
    return try! FfiConverterUInt8.lift(try! rustCall {
        uniffi_cove_fn_func_number_of_words_to_word_count(
            FfiConverterTypeNumberOfBip39Words.lower(me), $0
        )
    })
}

public func transactionPreviewConfirmedNew() -> Transaction {
    return try! FfiConverterTypeTransaction.lift(try! rustCall {
        uniffi_cove_fn_func_transaction_preview_confirmed_new($0
        )
    })
}

public func transactionPreviewUnconfirmedNew() -> Transaction {
    return try! FfiConverterTypeTransaction.lift(try! rustCall {
        uniffi_cove_fn_func_transaction_preview_unconfirmed_new($0
        )
    })
}

public func transactionsPreviewNew(confirmed: UInt8, unconfirmed: UInt8) -> [Transaction] {
    return try! FfiConverterSequenceTypeTransaction.lift(try! rustCall {
        uniffi_cove_fn_func_transactions_preview_new(
            FfiConverterUInt8.lower(confirmed),
            FfiConverterUInt8.lower(unconfirmed), $0
        )
    })
}

public func unitToString(unit: Unit) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_cove_fn_func_unit_to_string(
            FfiConverterTypeUnit.lower(unit), $0
        )
    })
}

public func walletMetadataPreview() -> WalletMetadata {
    return try! FfiConverterTypeWalletMetadata.lift(try! rustCall {
        uniffi_cove_fn_func_wallet_metadata_preview($0
        )
    })
}

public func walletStateIsEqual(lhs: WalletLoadState, rhs: WalletLoadState) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_cove_fn_func_wallet_state_is_equal(
            FfiConverterTypeWalletLoadState.lower(lhs),
            FfiConverterTypeWalletLoadState.lower(rhs), $0
        )
    })
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_cove_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_cove_checksum_func_all_color_schemes() != 24835 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_all_networks() != 30650 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_all_units() != 36925 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_balance_zero() != 63807 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_color_scheme_selection_capitalized_string() != 42247 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_default_node_selection() != 14665 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_hash_route() != 32817 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_is_route_equal() != 25732 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_network_to_string() != 60660 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_node_selection_to_node() != 57209 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_number_of_words_in_groups() != 14214 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_number_of_words_to_word_count() != 24846 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_transaction_preview_confirmed_new() != 43706 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_transaction_preview_unconfirmed_new() != 49725 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_transactions_preview_new() != 60166 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_unit_to_string() != 63080 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_wallet_metadata_preview() != 1229 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_func_wallet_state_is_equal() != 27037 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_address_string() != 10597 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_addressinfo_address() != 59376 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_addressinfo_adress_string() != 41627 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_addressinfo_index() != 45529 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_amount_as_btc() != 7531 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_amount_as_sats() != 62969 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_amount_btc_string() != 21387 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_amount_fmt_string() != 15357 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_amount_sats_string() != 36019 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_autocomplete_autocomplete() != 4748 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_autocomplete_is_valid_word() != 18021 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_bip39autocomplete_autocomplete() != 21847 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_bip39autocomplete_is_valid_word() != 19081 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_bip39wordspecificautocomplete_autocomplete() != 34680 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_bip39wordspecificautocomplete_is_valid_word() != 4400 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_confirmedtransaction_block_height() != 62845 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_confirmedtransaction_block_height_fmt() != 22839 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_confirmedtransaction_confirmed_at() != 21481 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_confirmedtransaction_confirmed_at_fmt() != 28835 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_confirmedtransaction_confirmed_at_fmt_with_time() != 36703 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_confirmedtransaction_id() != 63537 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_confirmedtransaction_label() != 17010 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_confirmedtransaction_sent_and_received() != 3525 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_database_global_config() != 4476 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_database_wallets() != 17223 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_dispatch() != 48712 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_go_to_selected_wallet() != 36820 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_has_wallets() != 3792 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_init_async_runtime() != 45507 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_listen_for_updates() != 48795 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_network() != 26747 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_num_wallets() != 28903 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_reset_default_route_to() != 40613 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_select_wallet() != 4478 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_state() != 19551 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_fingerprint_to_lowercase() != 27643 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_fingerprint_to_uppercase() != 23675 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_clear_selected_wallet() != 22146 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_color_scheme() != 18859 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_delete() != 13364 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_get() != 52128 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_select_wallet() != 52001 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_selected_network() != 7657 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_selected_node() != 31353 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_selected_wallet() != 51568 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_set() != 31033 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_set_color_scheme() != 24086 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_set_selected_network() != 34312 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalconfigtable_set_selected_node() != 35090 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalflagtable_get() != 42810 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalflagtable_set() != 23016 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_globalflagtable_toggle_bool_config() != 12062 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_headericonpresenter_ring_color() != 23010 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_mnemonic_all_words() != 45039 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_nodeselector_check_and_save_node() != 48519 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_nodeselector_check_selected_node() != 19872 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_nodeselector_node_list() != 23402 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_nodeselector_parse_custom_node() != 54190 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_nodeselector_select_preset_node() != 36330 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_nodeselector_selected_node() != 29849 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_routefactory_hot_wallet() != 7846 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_routefactory_is_same_parent_route() != 43168 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_routefactory_new_cold_wallet() != 14639 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_routefactory_new_hot_wallet() != 51032 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_routefactory_new_wallet_select() != 21343 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_routefactory_secret_words() != 64915 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustimportwalletviewmodel_dispatch() != 54003 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustimportwalletviewmodel_import_wallet() != 22388 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustimportwalletviewmodel_listen_for_updates() != 3156 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustpendingwalletviewmodel_bip_39_words() != 43976 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustpendingwalletviewmodel_bip_39_words_grouped() != 45204 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustpendingwalletviewmodel_card_indexes() != 33165 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustpendingwalletviewmodel_dispatch() != 8422 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustpendingwalletviewmodel_get_state() != 22652 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustpendingwalletviewmodel_listen_for_updates() != 25486 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustpendingwalletviewmodel_number_of_words_count() != 47399 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustpendingwalletviewmodel_save_wallet() != 45300 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_balance() != 10059 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_current_block_height() != 59265 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_delete_wallet() != 30016 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_dispatch() != 35864 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_display_amount() != 59974 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_fingerprint() != 38447 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_listen_for_updates() != 31064 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_mark_wallet_as_verified() != 64306 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_next_address() != 23410 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_number_of_confirmations() != 21053 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_number_of_confirmations_fmt() != 20695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_start_wallet_scan() != 46525 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_transaction_details() != 62006 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_wallet_metadata() != 44518 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_word_validator() != 32309 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_sentandreceived_amount() != 29581 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_sentandreceived_amount_fmt() != 55767 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_sentandreceived_direction() != 63307 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_sentandreceived_label() != 28947 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_sentandreceived_received() != 12400 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_sentandreceived_sent() != 29124 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_address() != 31151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_address_spaced_out() != 61966 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_amount() != 16978 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_amount_fiat() != 34436 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_amount_fiat_fmt() != 60211 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_amount_fmt() != 3569 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_block_number() != 61262 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_block_number_fmt() != 52006 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_confirmation_date_time() != 54859 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_fee_fiat_fmt() != 62198 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_fee_fmt() != 46565 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_is_confirmed() != 54031 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_is_received() != 54839 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_is_sent() != 7556 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_sent_sans_fee_fiat_fmt() != 62275 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_sent_sans_fee_fmt() != 54855 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_transactiondetails_transaction_url() != 12235 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_txid_is_equal() != 5460 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_txid_to_hash_string() != 24069 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_unconfirmedtransaction_id() != 59175 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_unconfirmedtransaction_label() != 12913 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_unconfirmedtransaction_last_seen() != 29089 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_unconfirmedtransaction_sent_and_received() != 24593 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_wallet_id() != 39072 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_wallettable_all() != 50582 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_wallettable_is_empty() != 59412 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_wallettable_len() != 21855 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_wordvalidator_grouped_words() != 32035 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_wordvalidator_invalid_words_string() != 7159 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_wordvalidator_is_all_words_valid() != 17704 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_wordvalidator_is_valid_word_group() != 6393 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_address_preview_new() != 14015 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_amount_from_sat() != 58319 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_amount_one_btc() != 59586 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_amount_one_sat() != 58118 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_bip39autocomplete_new() != 41839 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_bip39wordspecificautocomplete_new() != 49814 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_database_new() != 41458 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_ffiapp_new() != 11955 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_fingerprint_new() != 20831 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_headericonpresenter_new() != 10425 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_keychain_new() != 34449 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_mnemonic_new() != 56597 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_mnemonic_preview() != 3882 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_nodeselector_new() != 61659 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_routefactory_new() != 4959 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_rustimportwalletviewmodel_new() != 30630 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_rustpendingwalletviewmodel_new() != 47075 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_rustwalletviewmodel_new() != 37675 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_rustwalletviewmodel_preview_new_wallet() != 37026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_transactiondetails_preview_confirmed_received() != 6979 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_transactiondetails_preview_confirmed_sent() != 20500 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_transactiondetails_preview_new_confirmed() != 2385 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_transactiondetails_preview_pending_received() != 1731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_transactiondetails_preview_pending_sent() != 378 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_wallet_previewnewwallet() != 56877 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffireconcile_reconcile() != 54238 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_importwalletviewmodelreconciler_reconcile() != 63459 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_keychainaccess_save() != 63039 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_keychainaccess_get() != 3155 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_keychainaccess_delete() != 11466 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_pendingwalletviewmodelreconciler_reconcile() != 37929 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_walletviewmodelreconciler_reconcile() != 28159 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAutoComplete()
    uniffiCallbackInitFfiReconcile()
    uniffiCallbackInitImportWalletViewModelReconciler()
    uniffiCallbackInitKeychainAccess()
    uniffiCallbackInitPendingWalletViewModelReconciler()
    uniffiCallbackInitWalletViewModelReconciler()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
