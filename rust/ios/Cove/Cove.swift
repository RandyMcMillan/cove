// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(coveFFI)
    import coveFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_cove_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_cove_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

public protocol AuthenticatorProtocol: AnyObject {}

open class Authenticator:
    AuthenticatorProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_authenticator(self.pointer, $0) }
    }

    public convenience init(keychain: Keychain) {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_authenticator_new(
                    FfiConverterCallbackInterfaceKeychain.lower(keychain), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_authenticator(pointer, $0) }
    }
}

public struct FfiConverterTypeAuthenticator: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Authenticator

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Authenticator {
        return Authenticator(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Authenticator) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Authenticator {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Authenticator, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeAuthenticator_lift(_ pointer: UnsafeMutableRawPointer) throws -> Authenticator {
    return try FfiConverterTypeAuthenticator.lift(pointer)
}

public func FfiConverterTypeAuthenticator_lower(_ value: Authenticator) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAuthenticator.lower(value)
}

public protocol AutoComplete: AnyObject {
    func autocomplete(word: String) -> [String]
}

open class AutoCompleteImpl:
    AutoComplete
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_autocomplete(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_autocomplete(pointer, $0) }
    }

    open func autocomplete(word: String) -> [String] {
        return try! FfiConverterSequenceString.lift(try! rustCall {
            uniffi_cove_fn_method_autocomplete_autocomplete(self.uniffiClonePointer(),
                                                            FfiConverterString.lower(word), $0)
        })
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceAutoComplete {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceAutoComplete = .init(
        autocomplete: { (
            uniffiHandle: UInt64,
            word: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> [String] in
                guard let uniffiObj = try? FfiConverterTypeAutoComplete.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.autocomplete(
                    word: FfiConverterString.lift(word)
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterSequenceString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeAutoComplete.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface AutoComplete: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitAutoComplete() {
    uniffi_cove_fn_init_callback_vtable_autocomplete(&UniffiCallbackInterfaceAutoComplete.vtable)
}

public struct FfiConverterTypeAutoComplete: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<AutoComplete>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AutoComplete

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AutoComplete {
        return AutoCompleteImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AutoComplete) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AutoComplete {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AutoComplete, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeAutoComplete_lift(_ pointer: UnsafeMutableRawPointer) throws -> AutoComplete {
    return try FfiConverterTypeAutoComplete.lift(pointer)
}

public func FfiConverterTypeAutoComplete_lower(_ value: AutoComplete) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAutoComplete.lower(value)
}

public protocol Bip39AutoCompleteProtocol: AnyObject {
    func autocomplete(word: String) -> [String]
}

open class Bip39AutoComplete:
    Bip39AutoCompleteProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_bip39autocomplete(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_bip39autocomplete_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_bip39autocomplete(pointer, $0) }
    }

    open func autocomplete(word: String) -> [String] {
        return try! FfiConverterSequenceString.lift(try! rustCall {
            uniffi_cove_fn_method_bip39autocomplete_autocomplete(self.uniffiClonePointer(),
                                                                 FfiConverterString.lower(word), $0)
        })
    }
}

public struct FfiConverterTypeBip39AutoComplete: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bip39AutoComplete

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bip39AutoComplete {
        return Bip39AutoComplete(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bip39AutoComplete) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39AutoComplete {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bip39AutoComplete, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeBip39AutoComplete_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bip39AutoComplete {
    return try FfiConverterTypeBip39AutoComplete.lift(pointer)
}

public func FfiConverterTypeBip39AutoComplete_lower(_ value: Bip39AutoComplete) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBip39AutoComplete.lower(value)
}

public protocol DatabaseProtocol: AnyObject {
    func getBoolConfig(key: GlobalBoolConfigKey) throws -> Bool

    func setBoolConfig(key: GlobalBoolConfigKey, value: Bool) throws

    func toggleBoolConfig(key: GlobalBoolConfigKey) throws
}

open class Database:
    DatabaseProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_database(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_database_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_database(pointer, $0) }
    }

    open func getBoolConfig(key: GlobalBoolConfigKey) throws -> Bool {
        return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeError.lift) {
            uniffi_cove_fn_method_database_get_bool_config(self.uniffiClonePointer(),
                                                           FfiConverterTypeGlobalBoolConfigKey.lower(key), $0)
        })
    }

    open func setBoolConfig(key: GlobalBoolConfigKey, value: Bool) throws { try rustCallWithError(FfiConverterTypeError.lift) {
        uniffi_cove_fn_method_database_set_bool_config(self.uniffiClonePointer(),
                                                       FfiConverterTypeGlobalBoolConfigKey.lower(key),
                                                       FfiConverterBool.lower(value), $0)
    }
    }

    open func toggleBoolConfig(key: GlobalBoolConfigKey) throws { try rustCallWithError(FfiConverterTypeError.lift) {
        uniffi_cove_fn_method_database_toggle_bool_config(self.uniffiClonePointer(),
                                                          FfiConverterTypeGlobalBoolConfigKey.lower(key), $0)
    }
    }
}

public struct FfiConverterTypeDatabase: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Database

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Database {
        return Database(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Database) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Database {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Database, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeDatabase_lift(_ pointer: UnsafeMutableRawPointer) throws -> Database {
    return try FfiConverterTypeDatabase.lift(pointer)
}

public func FfiConverterTypeDatabase_lower(_ value: Database) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDatabase.lower(value)
}

/**
 * Representation of our app over FFI. Essentially a wrapper of [`App`].
 */
public protocol FfiAppProtocol: AnyObject {
    /**
     * Frontend calls this method to send events to the rust application logic
     */
    func dispatch(event: Event)

    func getState() -> AppState

    func listenForUpdates(updater: FfiUpdater)
}

/**
 * Representation of our app over FFI. Essentially a wrapper of [`App`].
 */
open class FfiApp:
    FfiAppProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_ffiapp(self.pointer, $0) }
    }

    /**
     * FFI constructor which wraps in an Arc
     */
    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_ffiapp_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_ffiapp(pointer, $0) }
    }

    /**
     * Frontend calls this method to send events to the rust application logic
     */
    open func dispatch(event: Event) { try! rustCall {
        uniffi_cove_fn_method_ffiapp_dispatch(self.uniffiClonePointer(),
                                              FfiConverterTypeEvent.lower(event), $0)
    }
    }

    open func getState() -> AppState {
        return try! FfiConverterTypeAppState.lift(try! rustCall {
            uniffi_cove_fn_method_ffiapp_get_state(self.uniffiClonePointer(), $0)
        })
    }

    open func listenForUpdates(updater: FfiUpdater) { try! rustCall {
        uniffi_cove_fn_method_ffiapp_listen_for_updates(self.uniffiClonePointer(),
                                                        FfiConverterCallbackInterfaceFfiUpdater.lower(updater), $0)
    }
    }
}

public struct FfiConverterTypeFfiApp: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiApp

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiApp {
        return FfiApp(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiApp) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiApp {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiApp, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiApp_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiApp {
    return try FfiConverterTypeFfiApp.lift(pointer)
}

public func FfiConverterTypeFfiApp_lower(_ value: FfiApp) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiApp.lower(value)
}

public protocol PendingWalletProtocol: AnyObject {}

open class PendingWallet:
    PendingWalletProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_pendingwallet(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_pendingwallet(pointer, $0) }
    }
}

public struct FfiConverterTypePendingWallet: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PendingWallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PendingWallet {
        return PendingWallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PendingWallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PendingWallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypePendingWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> PendingWallet {
    return try FfiConverterTypePendingWallet.lift(pointer)
}

public func FfiConverterTypePendingWallet_lower(_ value: PendingWallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypePendingWallet.lower(value)
}

public protocol RouteFactoryProtocol: AnyObject {
    func `default`() -> Route

    func hotWallet(route: HotWalletRoute) -> Route

    func newColdWallet() -> Route

    func newHotWallet() -> Route

    func newWalletSelect() -> Route
}

open class RouteFactory:
    RouteFactoryProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_routefactory(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_routefactory_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_routefactory(pointer, $0) }
    }

    open func `default`() -> Route {
        return try! FfiConverterTypeRoute.lift(try! rustCall {
            uniffi_cove_fn_method_routefactory_default(self.uniffiClonePointer(), $0)
        })
    }

    open func hotWallet(route: HotWalletRoute) -> Route {
        return try! FfiConverterTypeRoute.lift(try! rustCall {
            uniffi_cove_fn_method_routefactory_hot_wallet(self.uniffiClonePointer(),
                                                          FfiConverterTypeHotWalletRoute.lower(route), $0)
        })
    }

    open func newColdWallet() -> Route {
        return try! FfiConverterTypeRoute.lift(try! rustCall {
            uniffi_cove_fn_method_routefactory_new_cold_wallet(self.uniffiClonePointer(), $0)
        })
    }

    open func newHotWallet() -> Route {
        return try! FfiConverterTypeRoute.lift(try! rustCall {
            uniffi_cove_fn_method_routefactory_new_hot_wallet(self.uniffiClonePointer(), $0)
        })
    }

    open func newWalletSelect() -> Route {
        return try! FfiConverterTypeRoute.lift(try! rustCall {
            uniffi_cove_fn_method_routefactory_new_wallet_select(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeRouteFactory: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RouteFactory

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RouteFactory {
        return RouteFactory(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RouteFactory) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteFactory {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RouteFactory, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeRouteFactory_lift(_ pointer: UnsafeMutableRawPointer) throws -> RouteFactory {
    return try FfiConverterTypeRouteFactory.lift(pointer)
}

public func FfiConverterTypeRouteFactory_lower(_ value: RouteFactory) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRouteFactory.lower(value)
}

public protocol RustWalletViewModelProtocol: AnyObject {
    func bip39Words() -> [String]

    func bip39WordsGrouped() -> [[GroupedWord]]

    func cardIndexes() -> UInt8

    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: WalletViewModelAction)

    func getState() -> WalletViewModelState

    func invalidWordsString(enteredWords: [[String]]) -> String

    func isAllWordsValid(enteredWords: [[String]]) -> Bool

    func isValidWordGroup(groupNumber: UInt8, enteredWords: [String]) -> Bool

    func listenForUpdates(reconciler: PendingWalletViewModelReconciler)

    func numberOfWordsCount() -> UInt8
}

open class RustWalletViewModel:
    RustWalletViewModelProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_rustwalletviewmodel(self.pointer, $0) }
    }

    public convenience init(numberOfWords: NumberOfBip39Words) {
        let pointer =
            try! rustCall {
                uniffi_cove_fn_constructor_rustwalletviewmodel_new(
                    FfiConverterTypeNumberOfBip39Words.lower(numberOfWords), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustwalletviewmodel(pointer, $0) }
    }

    open func bip39Words() -> [String] {
        return try! FfiConverterSequenceString.lift(try! rustCall {
            uniffi_cove_fn_method_rustwalletviewmodel_bip_39_words(self.uniffiClonePointer(), $0)
        })
    }

    open func bip39WordsGrouped() -> [[GroupedWord]] {
        return try! FfiConverterSequenceSequenceTypeGroupedWord.lift(try! rustCall {
            uniffi_cove_fn_method_rustwalletviewmodel_bip_39_words_grouped(self.uniffiClonePointer(), $0)
        })
    }

    open func cardIndexes() -> UInt8 {
        return try! FfiConverterUInt8.lift(try! rustCall {
            uniffi_cove_fn_method_rustwalletviewmodel_card_indexes(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Action from the frontend to change the state of the view model
     */
    open func dispatch(action: WalletViewModelAction) { try! rustCall {
        uniffi_cove_fn_method_rustwalletviewmodel_dispatch(self.uniffiClonePointer(),
                                                           FfiConverterTypeWalletViewModelAction.lower(action), $0)
    }
    }

    open func getState() -> WalletViewModelState {
        return try! FfiConverterTypeWalletViewModelState.lift(try! rustCall {
            uniffi_cove_fn_method_rustwalletviewmodel_get_state(self.uniffiClonePointer(), $0)
        })
    }

    open func invalidWordsString(enteredWords: [[String]]) -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_cove_fn_method_rustwalletviewmodel_invalid_words_string(self.uniffiClonePointer(),
                                                                           FfiConverterSequenceSequenceString.lower(enteredWords), $0)
        })
    }

    open func isAllWordsValid(enteredWords: [[String]]) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_rustwalletviewmodel_is_all_words_valid(self.uniffiClonePointer(),
                                                                         FfiConverterSequenceSequenceString.lower(enteredWords), $0)
        })
    }

    open func isValidWordGroup(groupNumber: UInt8, enteredWords: [String]) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_cove_fn_method_rustwalletviewmodel_is_valid_word_group(self.uniffiClonePointer(),
                                                                          FfiConverterUInt8.lower(groupNumber),
                                                                          FfiConverterSequenceString.lower(enteredWords), $0)
        })
    }

    open func listenForUpdates(reconciler: PendingWalletViewModelReconciler) { try! rustCall {
        uniffi_cove_fn_method_rustwalletviewmodel_listen_for_updates(self.uniffiClonePointer(),
                                                                     FfiConverterCallbackInterfacePendingWalletViewModelReconciler.lower(reconciler), $0)
    }
    }

    open func numberOfWordsCount() -> UInt8 {
        return try! FfiConverterUInt8.lift(try! rustCall {
            uniffi_cove_fn_method_rustwalletviewmodel_number_of_words_count(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeRustWalletViewModel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustWalletViewModel

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustWalletViewModel {
        return RustWalletViewModel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustWalletViewModel) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustWalletViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustWalletViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeRustWalletViewModel_lift(_ pointer: UnsafeMutableRawPointer) throws -> RustWalletViewModel {
    return try FfiConverterTypeRustWalletViewModel.lift(pointer)
}

public func FfiConverterTypeRustWalletViewModel_lower(_ value: RustWalletViewModel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRustWalletViewModel.lower(value)
}

public protocol WalletProtocol: AnyObject {}

open class Wallet:
    WalletProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_wallet(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_wallet(pointer, $0) }
    }
}

public struct FfiConverterTypeWallet: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Wallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
    return try FfiConverterTypeWallet.lift(pointer)
}

public func FfiConverterTypeWallet_lower(_ value: Wallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWallet.lower(value)
}

public struct AppState {
    public var router: Router

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(router: Router) {
        self.router = router
    }
}

public struct FfiConverterTypeAppState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppState {
        return
            try AppState(
                router: FfiConverterTypeRouter.read(from: &buf)
            )
    }

    public static func write(_ value: AppState, into buf: inout [UInt8]) {
        FfiConverterTypeRouter.write(value.router, into: &buf)
    }
}

public func FfiConverterTypeAppState_lift(_ buf: RustBuffer) throws -> AppState {
    return try FfiConverterTypeAppState.lift(buf)
}

public func FfiConverterTypeAppState_lower(_ value: AppState) -> RustBuffer {
    return FfiConverterTypeAppState.lower(value)
}

public struct GroupedWord {
    public var number: UInt8
    public var word: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(number: UInt8, word: String) {
        self.number = number
        self.word = word
    }
}

extension GroupedWord: Equatable, Hashable {
    public static func == (lhs: GroupedWord, rhs: GroupedWord) -> Bool {
        if lhs.number != rhs.number {
            return false
        }
        if lhs.word != rhs.word {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(number)
        hasher.combine(word)
    }
}

public struct FfiConverterTypeGroupedWord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GroupedWord {
        return
            try GroupedWord(
                number: FfiConverterUInt8.read(from: &buf),
                word: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: GroupedWord, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.number, into: &buf)
        FfiConverterString.write(value.word, into: &buf)
    }
}

public func FfiConverterTypeGroupedWord_lift(_ buf: RustBuffer) throws -> GroupedWord {
    return try FfiConverterTypeGroupedWord.lift(buf)
}

public func FfiConverterTypeGroupedWord_lower(_ value: GroupedWord) -> RustBuffer {
    return FfiConverterTypeGroupedWord.lower(value)
}

public struct Router {
    public var app: FfiApp
    public var routes: [Route]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(app: FfiApp, routes: [Route]) {
        self.app = app
        self.routes = routes
    }
}

public struct FfiConverterTypeRouter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Router {
        return
            try Router(
                app: FfiConverterTypeFfiApp.read(from: &buf),
                routes: FfiConverterSequenceTypeRoute.read(from: &buf)
            )
    }

    public static func write(_ value: Router, into buf: inout [UInt8]) {
        FfiConverterTypeFfiApp.write(value.app, into: &buf)
        FfiConverterSequenceTypeRoute.write(value.routes, into: &buf)
    }
}

public func FfiConverterTypeRouter_lift(_ buf: RustBuffer) throws -> Router {
    return try FfiConverterTypeRouter.lift(buf)
}

public func FfiConverterTypeRouter_lower(_ value: Router) -> RustBuffer {
    return FfiConverterTypeRouter.lower(value)
}

public struct WalletViewModelState {
    public var numberOfWords: NumberOfBip39Words
    public var wallet: PendingWallet

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numberOfWords: NumberOfBip39Words, wallet: PendingWallet) {
        self.numberOfWords = numberOfWords
        self.wallet = wallet
    }
}

public struct FfiConverterTypeWalletViewModelState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletViewModelState {
        return
            try WalletViewModelState(
                numberOfWords: FfiConverterTypeNumberOfBip39Words.read(from: &buf),
                wallet: FfiConverterTypePendingWallet.read(from: &buf)
            )
    }

    public static func write(_ value: WalletViewModelState, into buf: inout [UInt8]) {
        FfiConverterTypeNumberOfBip39Words.write(value.numberOfWords, into: &buf)
        FfiConverterTypePendingWallet.write(value.wallet, into: &buf)
    }
}

public func FfiConverterTypeWalletViewModelState_lift(_ buf: RustBuffer) throws -> WalletViewModelState {
    return try FfiConverterTypeWalletViewModelState.lift(buf)
}

public func FfiConverterTypeWalletViewModelState_lower(_ value: WalletViewModelState) -> RustBuffer {
    return FfiConverterTypeWalletViewModelState.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ColdWalletRoute {
    case create
    case `import`
}

public struct FfiConverterTypeColdWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = ColdWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ColdWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .create

        case 2: return .import

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ColdWalletRoute, into buf: inout [UInt8]) {
        switch value {
        case .create:
            writeInt(&buf, Int32(1))

        case .import:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeColdWalletRoute_lift(_ buf: RustBuffer) throws -> ColdWalletRoute {
    return try FfiConverterTypeColdWalletRoute.lift(buf)
}

public func FfiConverterTypeColdWalletRoute_lower(_ value: ColdWalletRoute) -> RustBuffer {
    return FfiConverterTypeColdWalletRoute.lower(value)
}

extension ColdWalletRoute: Equatable, Hashable {}

public enum Error {
    case DatabaseAccessError(String
    )
    case TableAccessError(String
    )
    case ConfigReadError(String
    )
}

public struct FfiConverterTypeError: FfiConverterRustBuffer {
    typealias SwiftType = Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .DatabaseAccessError(
                FfiConverterString.read(from: &buf)
            )
        case 2: return try .TableAccessError(
                FfiConverterString.read(from: &buf)
            )
        case 3: return try .ConfigReadError(
                FfiConverterString.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Error, into buf: inout [UInt8]) {
        switch value {
        case let .DatabaseAccessError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .TableAccessError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case let .ConfigReadError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension Error: Equatable, Hashable {}

extension Error: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Event {
    case routeChanged(routes: [Route]
    )
}

public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .routeChanged(routes: FfiConverterSequenceTypeRoute.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        switch value {
        case let .routeChanged(routes):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoute.write(routes, into: &buf)
        }
    }
}

public func FfiConverterTypeEvent_lift(_ buf: RustBuffer) throws -> Event {
    return try FfiConverterTypeEvent.lift(buf)
}

public func FfiConverterTypeEvent_lower(_ value: Event) -> RustBuffer {
    return FfiConverterTypeEvent.lower(value)
}

extension Event: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GlobalBoolConfigKey {
    case completedOnboarding
}

public struct FfiConverterTypeGlobalBoolConfigKey: FfiConverterRustBuffer {
    typealias SwiftType = GlobalBoolConfigKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalBoolConfigKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .completedOnboarding

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalBoolConfigKey, into buf: inout [UInt8]) {
        switch value {
        case .completedOnboarding:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeGlobalBoolConfigKey_lift(_ buf: RustBuffer) throws -> GlobalBoolConfigKey {
    return try FfiConverterTypeGlobalBoolConfigKey.lift(buf)
}

public func FfiConverterTypeGlobalBoolConfigKey_lower(_ value: GlobalBoolConfigKey) -> RustBuffer {
    return FfiConverterTypeGlobalBoolConfigKey.lower(value)
}

extension GlobalBoolConfigKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HotWalletRoute {
    case select
    case create(words: NumberOfBip39Words
    )
    case `import`
    case verifyWords
}

public struct FfiConverterTypeHotWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = HotWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HotWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .select

        case 2: return try .create(words: FfiConverterTypeNumberOfBip39Words.read(from: &buf)
            )

        case 3: return .import

        case 4: return .verifyWords

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HotWalletRoute, into buf: inout [UInt8]) {
        switch value {
        case .select:
            writeInt(&buf, Int32(1))

        case let .create(words):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNumberOfBip39Words.write(words, into: &buf)

        case .import:
            writeInt(&buf, Int32(3))

        case .verifyWords:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeHotWalletRoute_lift(_ buf: RustBuffer) throws -> HotWalletRoute {
    return try FfiConverterTypeHotWalletRoute.lift(buf)
}

public func FfiConverterTypeHotWalletRoute_lower(_ value: HotWalletRoute) -> RustBuffer {
    return FfiConverterTypeHotWalletRoute.lower(value)
}

extension HotWalletRoute: Equatable, Hashable {}

public enum KeychainError {
    case Generic(String
    )
}

public struct FfiConverterTypeKeychainError: FfiConverterRustBuffer {
    typealias SwiftType = KeychainError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeychainError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .Generic(
                FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeychainError, into buf: inout [UInt8]) {
        switch value {
        case let .Generic(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension KeychainError: Equatable, Hashable {}

extension KeychainError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NewWalletRoute {
    case select
    case hotWallet(HotWalletRoute
    )
    case coldWallet(ColdWalletRoute
    )
}

public struct FfiConverterTypeNewWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = NewWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .select

        case 2: return try .hotWallet(FfiConverterTypeHotWalletRoute.read(from: &buf)
            )

        case 3: return try .coldWallet(FfiConverterTypeColdWalletRoute.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NewWalletRoute, into buf: inout [UInt8]) {
        switch value {
        case .select:
            writeInt(&buf, Int32(1))

        case let .hotWallet(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeHotWalletRoute.write(v1, into: &buf)

        case let .coldWallet(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeColdWalletRoute.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeNewWalletRoute_lift(_ buf: RustBuffer) throws -> NewWalletRoute {
    return try FfiConverterTypeNewWalletRoute.lift(buf)
}

public func FfiConverterTypeNewWalletRoute_lower(_ value: NewWalletRoute) -> RustBuffer {
    return FfiConverterTypeNewWalletRoute.lower(value)
}

extension NewWalletRoute: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NumberOfBip39Words {
    case twelve
    case twentyFour
}

public struct FfiConverterTypeNumberOfBip39Words: FfiConverterRustBuffer {
    typealias SwiftType = NumberOfBip39Words

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NumberOfBip39Words {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .twelve

        case 2: return .twentyFour

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NumberOfBip39Words, into buf: inout [UInt8]) {
        switch value {
        case .twelve:
            writeInt(&buf, Int32(1))

        case .twentyFour:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeNumberOfBip39Words_lift(_ buf: RustBuffer) throws -> NumberOfBip39Words {
    return try FfiConverterTypeNumberOfBip39Words.lift(buf)
}

public func FfiConverterTypeNumberOfBip39Words_lower(_ value: NumberOfBip39Words) -> RustBuffer {
    return FfiConverterTypeNumberOfBip39Words.lower(value)
}

extension NumberOfBip39Words: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingWalletViewModelReconcileMessage {
    case words(NumberOfBip39Words
    )
}

public struct FfiConverterTypePendingWalletViewModelReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = PendingWalletViewModelReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletViewModelReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .words(FfiConverterTypeNumberOfBip39Words.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingWalletViewModelReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        case let .words(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypePendingWalletViewModelReconcileMessage_lift(_ buf: RustBuffer) throws -> PendingWalletViewModelReconcileMessage {
    return try FfiConverterTypePendingWalletViewModelReconcileMessage.lift(buf)
}

public func FfiConverterTypePendingWalletViewModelReconcileMessage_lower(_ value: PendingWalletViewModelReconcileMessage) -> RustBuffer {
    return FfiConverterTypePendingWalletViewModelReconcileMessage.lower(value)
}

extension PendingWalletViewModelReconcileMessage: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Route {
    case cove
    case newWallet(NewWalletRoute
    )
}

public struct FfiConverterTypeRoute: FfiConverterRustBuffer {
    typealias SwiftType = Route

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Route {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .cove

        case 2: return try .newWallet(FfiConverterTypeNewWalletRoute.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Route, into buf: inout [UInt8]) {
        switch value {
        case .cove:
            writeInt(&buf, Int32(1))

        case let .newWallet(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNewWalletRoute.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeRoute_lift(_ buf: RustBuffer) throws -> Route {
    return try FfiConverterTypeRoute.lift(buf)
}

public func FfiConverterTypeRoute_lower(_ value: Route) -> RustBuffer {
    return FfiConverterTypeRoute.lower(value)
}

extension Route: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Update {
    case routerUpdate(router: Router
    )
    case databaseUpdate
}

public struct FfiConverterTypeUpdate: FfiConverterRustBuffer {
    typealias SwiftType = Update

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Update {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .routerUpdate(router: FfiConverterTypeRouter.read(from: &buf)
            )

        case 2: return .databaseUpdate

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Update, into buf: inout [UInt8]) {
        switch value {
        case let .routerUpdate(router):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRouter.write(router, into: &buf)

        case .databaseUpdate:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeUpdate_lift(_ buf: RustBuffer) throws -> Update {
    return try FfiConverterTypeUpdate.lift(buf)
}

public func FfiConverterTypeUpdate_lower(_ value: Update) -> RustBuffer {
    return FfiConverterTypeUpdate.lower(value)
}

public enum WalletCreationError {
    case BdkError(String
    )
}

public struct FfiConverterTypeWalletCreationError: FfiConverterRustBuffer {
    typealias SwiftType = WalletCreationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletCreationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .BdkError(
                FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletCreationError, into buf: inout [UInt8]) {
        switch value {
        case let .BdkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

extension WalletCreationError: Equatable, Hashable {}

extension WalletCreationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletViewModelAction {
    case updateWords(NumberOfBip39Words
    )
}

public struct FfiConverterTypeWalletViewModelAction: FfiConverterRustBuffer {
    typealias SwiftType = WalletViewModelAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletViewModelAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .updateWords(FfiConverterTypeNumberOfBip39Words.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletViewModelAction, into buf: inout [UInt8]) {
        switch value {
        case let .updateWords(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletViewModelAction_lift(_ buf: RustBuffer) throws -> WalletViewModelAction {
    return try FfiConverterTypeWalletViewModelAction.lift(buf)
}

public func FfiConverterTypeWalletViewModelAction_lower(_ value: WalletViewModelAction) -> RustBuffer {
    return FfiConverterTypeWalletViewModelAction.lower(value)
}

extension WalletViewModelAction: Equatable, Hashable {}

public protocol FfiUpdater: AnyObject {
    /**
     * Essentially a callback to the frontend
     */
    func update(update: Update)
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceFfiUpdater {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFfiUpdater = .init(
        update: { (
            uniffiHandle: UInt64,
            update: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceFfiUpdater.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.update(
                    update: FfiConverterTypeUpdate.lift(update)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceFfiUpdater.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiUpdater: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFfiUpdater() {
    uniffi_cove_fn_init_callback_vtable_ffiupdater(&UniffiCallbackInterfaceFfiUpdater.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiUpdater {
    fileprivate static var handleMap = UniffiHandleMap<FfiUpdater>()
}

extension FfiConverterCallbackInterfaceFfiUpdater: FfiConverter {
    typealias SwiftType = FfiUpdater
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol Keychain: AnyObject {
    func encrypt(data: Data) throws -> Data
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceKeychain {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceKeychain = .init(
        encrypt: { (
            uniffiHandle: UInt64,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceKeychain.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.encrypt(
                    data: FfiConverterData.lift(data)
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterData.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeKeychainError.lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceKeychain.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Keychain: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitKeychain() {
    uniffi_cove_fn_init_callback_vtable_keychain(&UniffiCallbackInterfaceKeychain.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceKeychain {
    fileprivate static var handleMap = UniffiHandleMap<Keychain>()
}

extension FfiConverterCallbackInterfaceKeychain: FfiConverter {
    typealias SwiftType = Keychain
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol PendingWalletViewModelReconciler: AnyObject {
    /**
     * Tells the frontend to reconcile the view model changes
     */
    func reconcile(message: PendingWalletViewModelReconcileMessage)
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfacePendingWalletViewModelReconciler {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfacePendingWalletViewModelReconciler = .init(
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePendingWalletViewModelReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.reconcile(
                    message: FfiConverterTypePendingWalletViewModelReconcileMessage.lift(message)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfacePendingWalletViewModelReconciler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PendingWalletViewModelReconciler: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitPendingWalletViewModelReconciler() {
    uniffi_cove_fn_init_callback_vtable_pendingwalletviewmodelreconciler(&UniffiCallbackInterfacePendingWalletViewModelReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfacePendingWalletViewModelReconciler {
    fileprivate static var handleMap = UniffiHandleMap<PendingWalletViewModelReconciler>()
}

extension FfiConverterCallbackInterfacePendingWalletViewModelReconciler: FfiConverter {
    typealias SwiftType = PendingWalletViewModelReconciler
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeGroupedWord: FfiConverterRustBuffer {
    typealias SwiftType = [GroupedWord]

    public static func write(_ value: [GroupedWord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGroupedWord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GroupedWord] {
        let len: Int32 = try readInt(&buf)
        var seq = [GroupedWord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeGroupedWord.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeRoute: FfiConverterRustBuffer {
    typealias SwiftType = [Route]

    public static func write(_ value: [Route], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoute.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Route] {
        let len: Int32 = try readInt(&buf)
        var seq = [Route]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeRoute.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]

    public static func write(_ value: [[String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterSequenceString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceSequenceTypeGroupedWord: FfiConverterRustBuffer {
    typealias SwiftType = [[GroupedWord]]

    public static func write(_ value: [[GroupedWord]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypeGroupedWord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[GroupedWord]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[GroupedWord]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterSequenceTypeGroupedWord.read(from: &buf))
        }
        return seq
    }
}

public func global() { try! rustCall {
    uniffi_cove_fn_func_global($0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_cove_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_cove_checksum_func_global() != 52066 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_autocomplete_autocomplete() != 4748 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_bip39autocomplete_autocomplete() != 21847 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_database_get_bool_config() != 51514 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_database_set_bool_config() != 60463 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_database_toggle_bool_config() != 31033 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_dispatch() != 2014 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_get_state() != 15088 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiapp_listen_for_updates() != 45338 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_routefactory_default() != 64785 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_routefactory_hot_wallet() != 7846 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_routefactory_new_cold_wallet() != 14639 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_routefactory_new_hot_wallet() != 51032 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_routefactory_new_wallet_select() != 21343 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_bip_39_words() != 30749 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_bip_39_words_grouped() != 18300 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_card_indexes() != 50108 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_dispatch() != 35864 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_get_state() != 55828 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_invalid_words_string() != 62162 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_is_all_words_valid() != 31255 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_is_valid_word_group() != 25656 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_listen_for_updates() != 17396 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_rustwalletviewmodel_number_of_words_count() != 60024 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_authenticator_new() != 4424 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_bip39autocomplete_new() != 41839 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_database_new() != 41458 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_ffiapp_new() != 11955 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_routefactory_new() != 4959 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_constructor_rustwalletviewmodel_new() != 22927 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_ffiupdater_update() != 21755 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_keychain_encrypt() != 65101 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_cove_checksum_method_pendingwalletviewmodelreconciler_reconcile() != 37929 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAutoComplete()
    uniffiCallbackInitFfiUpdater()
    uniffiCallbackInitKeychain()
    uniffiCallbackInitPendingWalletViewModelReconciler()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
