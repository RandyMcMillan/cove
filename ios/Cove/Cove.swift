// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(coveFFI)
import coveFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_cove_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_cove_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol AddressProtocol : AnyObject {
    
    func spacedOut()  -> String
    
    func string()  -> String
    
}

open class Address:
    AddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_address(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_address(pointer, $0) }
    }

    
public static func fromString(address: String)throws  -> Address  {
    return try  FfiConverterTypeAddress.lift(try rustCallWithError(FfiConverterTypeAddressError.lift) {
    uniffi_cove_fn_constructor_address_from_string(
        FfiConverterString.lower(address),$0
    )
})
}
    
public static func previewNew() -> Address  {
    return try!  FfiConverterTypeAddress.lift(try! rustCall() {
    uniffi_cove_fn_constructor_address_preview_new($0
    )
})
}
    

    
open func spacedOut() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_address_spaced_out(self.uniffiClonePointer(),$0
    )
})
}
    
open func string() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_address_string(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddress: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Address

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
        return Address(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Address) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
    return try FfiConverterTypeAddress.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lower(_ value: Address) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddress.lower(value)
}




public protocol AddressInfoProtocol : AnyObject {
    
    func address()  -> Address
    
    func adressString()  -> String
    
    func index()  -> UInt32
    
}

open class AddressInfo:
    AddressInfoProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_addressinfo(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_addressinfo(pointer, $0) }
    }

    

    
open func address() -> Address  {
    return try!  FfiConverterTypeAddress.lift(try! rustCall() {
    uniffi_cove_fn_method_addressinfo_address(self.uniffiClonePointer(),$0
    )
})
}
    
open func adressString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_addressinfo_adress_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func index() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_cove_fn_method_addressinfo_index(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressInfo: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AddressInfo

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AddressInfo {
        return AddressInfo(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AddressInfo) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressInfo {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AddressInfo, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfo_lift(_ pointer: UnsafeMutableRawPointer) throws -> AddressInfo {
    return try FfiConverterTypeAddressInfo.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfo_lower(_ value: AddressInfo) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddressInfo.lower(value)
}




public protocol AddressWithNetworkProtocol : AnyObject {
    
    func address()  -> Address
    
    func amount()  -> Amount?
    
    func network()  -> Network
    
}

open class AddressWithNetwork:
    AddressWithNetworkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_addresswithnetwork(self.pointer, $0) }
    }
public convenience init(address: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeAddressError.lift) {
    uniffi_cove_fn_constructor_addresswithnetwork_new(
        FfiConverterString.lower(address),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_addresswithnetwork(pointer, $0) }
    }

    

    
open func address() -> Address  {
    return try!  FfiConverterTypeAddress.lift(try! rustCall() {
    uniffi_cove_fn_method_addresswithnetwork_address(self.uniffiClonePointer(),$0
    )
})
}
    
open func amount() -> Amount?  {
    return try!  FfiConverterOptionTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_addresswithnetwork_amount(self.uniffiClonePointer(),$0
    )
})
}
    
open func network() -> Network  {
    return try!  FfiConverterTypeNetwork.lift(try! rustCall() {
    uniffi_cove_fn_method_addresswithnetwork_network(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressWithNetwork: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AddressWithNetwork

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AddressWithNetwork {
        return AddressWithNetwork(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AddressWithNetwork) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressWithNetwork {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AddressWithNetwork, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressWithNetwork_lift(_ pointer: UnsafeMutableRawPointer) throws -> AddressWithNetwork {
    return try FfiConverterTypeAddressWithNetwork.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressWithNetwork_lower(_ value: AddressWithNetwork) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddressWithNetwork.lower(value)
}




public protocol AmountProtocol : AnyObject {
    
    func asBtc()  -> Double
    
    func asSats()  -> UInt64
    
    func btcString()  -> String
    
    func btcStringWithUnit()  -> String
    
    func fmtStringWithUnit(unit: Unit)  -> String
    
    func satsString()  -> String
    
    func satsStringWithUnit()  -> String
    
}

open class Amount:
    AmountProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_amount(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_amount(pointer, $0) }
    }

    
public static func fromSat(sats: UInt64) -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_constructor_amount_from_sat(
        FfiConverterUInt64.lower(sats),$0
    )
})
}
    
public static func oneBtc() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_constructor_amount_one_btc($0
    )
})
}
    
public static func oneSat() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_constructor_amount_one_sat($0
    )
})
}
    

    
open func asBtc() -> Double  {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_cove_fn_method_amount_as_btc(self.uniffiClonePointer(),$0
    )
})
}
    
open func asSats() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_amount_as_sats(self.uniffiClonePointer(),$0
    )
})
}
    
open func btcString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_amount_btc_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func btcStringWithUnit() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_amount_btc_string_with_unit(self.uniffiClonePointer(),$0
    )
})
}
    
open func fmtStringWithUnit(unit: Unit) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_amount_fmt_string_with_unit(self.uniffiClonePointer(),
        FfiConverterTypeUnit.lower(unit),$0
    )
})
}
    
open func satsString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_amount_sats_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func satsStringWithUnit() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_amount_sats_string_with_unit(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAmount: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Amount

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
        return Amount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Amount) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lower(_ value: Amount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAmount.lower(value)
}




public protocol AutoComplete : AnyObject {
    
    func autocomplete(word: String)  -> [String]
    
    func isValidWord(word: String)  -> Bool
    
}

open class AutoCompleteImpl:
    AutoComplete {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_autocomplete(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_autocomplete(pointer, $0) }
    }

    

    
open func autocomplete(word: String) -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_autocomplete_autocomplete(self.uniffiClonePointer(),
        FfiConverterString.lower(word),$0
    )
})
}
    
open func isValidWord(word: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_autocomplete_is_valid_word(self.uniffiClonePointer(),
        FfiConverterString.lower(word),$0
    )
})
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceAutoComplete {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceAutoComplete] = [UniffiVTableCallbackInterfaceAutoComplete(
        autocomplete: { (
            uniffiHandle: UInt64,
            word: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> [String] in
                guard let uniffiObj = try? FfiConverterTypeAutoComplete.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.autocomplete(
                     word: try FfiConverterString.lift(word)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterSequenceString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        isValidWord: { (
            uniffiHandle: UInt64,
            word: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeAutoComplete.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.isValidWord(
                     word: try FfiConverterString.lift(word)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeAutoComplete.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface AutoComplete: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitAutoComplete() {
    uniffi_cove_fn_init_callback_vtable_autocomplete(UniffiCallbackInterfaceAutoComplete.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAutoComplete: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<AutoComplete>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AutoComplete

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AutoComplete {
        return AutoCompleteImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AutoComplete) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AutoComplete {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AutoComplete, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAutoComplete_lift(_ pointer: UnsafeMutableRawPointer) throws -> AutoComplete {
    return try FfiConverterTypeAutoComplete.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAutoComplete_lower(_ value: AutoComplete) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAutoComplete.lower(value)
}




public protocol BbqrJoinResultProtocol : AnyObject {
    
    func finalResult() throws  -> String
    
    func isComplete()  -> Bool
    
    func partsLeft()  -> UInt32
    
}

open class BbqrJoinResult:
    BbqrJoinResultProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_bbqrjoinresult(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_bbqrjoinresult(pointer, $0) }
    }

    

    
open func finalResult()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeMultiQrError.lift) {
    uniffi_cove_fn_method_bbqrjoinresult_final_result(self.uniffiClonePointer(),$0
    )
})
}
    
open func isComplete() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_bbqrjoinresult_is_complete(self.uniffiClonePointer(),$0
    )
})
}
    
open func partsLeft() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_cove_fn_method_bbqrjoinresult_parts_left(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBbqrJoinResult: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BbqrJoinResult

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BbqrJoinResult {
        return BbqrJoinResult(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BbqrJoinResult) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BbqrJoinResult {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BbqrJoinResult, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBbqrJoinResult_lift(_ pointer: UnsafeMutableRawPointer) throws -> BbqrJoinResult {
    return try FfiConverterTypeBbqrJoinResult.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBbqrJoinResult_lower(_ value: BbqrJoinResult) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBbqrJoinResult.lower(value)
}




public protocol BbqrJoinedProtocol : AnyObject {
    
    func getGroupedWords(chunks: UInt8) throws  -> [[String]]
    
    func getSeedWords() throws  -> [String]
    
}

open class BbqrJoined:
    BbqrJoinedProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_bbqrjoined(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_bbqrjoined(pointer, $0) }
    }

    

    
open func getGroupedWords(chunks: UInt8)throws  -> [[String]]  {
    return try  FfiConverterSequenceSequenceString.lift(try rustCallWithError(FfiConverterTypeMultiQrError.lift) {
    uniffi_cove_fn_method_bbqrjoined_get_grouped_words(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(chunks),$0
    )
})
}
    
open func getSeedWords()throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeMultiQrError.lift) {
    uniffi_cove_fn_method_bbqrjoined_get_seed_words(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBbqrJoined: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BbqrJoined

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BbqrJoined {
        return BbqrJoined(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BbqrJoined) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BbqrJoined {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BbqrJoined, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBbqrJoined_lift(_ pointer: UnsafeMutableRawPointer) throws -> BbqrJoined {
    return try FfiConverterTypeBbqrJoined.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBbqrJoined_lower(_ value: BbqrJoined) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBbqrJoined.lower(value)
}




public protocol Bip39AutoCompleteProtocol : AnyObject {
    
    func autocomplete(word: String)  -> [String]
    
    func isValidWord(word: String)  -> Bool
    
}

open class Bip39AutoComplete:
    Bip39AutoCompleteProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_bip39autocomplete(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_bip39autocomplete_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_bip39autocomplete(pointer, $0) }
    }

    

    
open func autocomplete(word: String) -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39autocomplete_autocomplete(self.uniffiClonePointer(),
        FfiConverterString.lower(word),$0
    )
})
}
    
open func isValidWord(word: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39autocomplete_is_valid_word(self.uniffiClonePointer(),
        FfiConverterString.lower(word),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip39AutoComplete: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bip39AutoComplete

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bip39AutoComplete {
        return Bip39AutoComplete(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bip39AutoComplete) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39AutoComplete {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bip39AutoComplete, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39AutoComplete_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bip39AutoComplete {
    return try FfiConverterTypeBip39AutoComplete.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39AutoComplete_lower(_ value: Bip39AutoComplete) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBip39AutoComplete.lower(value)
}




public protocol Bip39WordSpecificAutocompleteProtocol : AnyObject {
    
    func autocomplete(word: String, allWords: [[String]])  -> [String]
    
    func isBip39Word(word: String)  -> Bool
    
    func isValidWord(word: String, allWords: [[String]])  -> Bool
    
}

open class Bip39WordSpecificAutocomplete:
    Bip39WordSpecificAutocompleteProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_bip39wordspecificautocomplete(self.pointer, $0) }
    }
public convenience init(wordNumber: UInt16, numberOfWords: NumberOfBip39Words) {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_bip39wordspecificautocomplete_new(
        FfiConverterUInt16.lower(wordNumber),
        FfiConverterTypeNumberOfBip39Words.lower(numberOfWords),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_bip39wordspecificautocomplete(pointer, $0) }
    }

    

    
open func autocomplete(word: String, allWords: [[String]]) -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39wordspecificautocomplete_autocomplete(self.uniffiClonePointer(),
        FfiConverterString.lower(word),
        FfiConverterSequenceSequenceString.lower(allWords),$0
    )
})
}
    
open func isBip39Word(word: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39wordspecificautocomplete_is_bip39_word(self.uniffiClonePointer(),
        FfiConverterString.lower(word),$0
    )
})
}
    
open func isValidWord(word: String, allWords: [[String]]) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39wordspecificautocomplete_is_valid_word(self.uniffiClonePointer(),
        FfiConverterString.lower(word),
        FfiConverterSequenceSequenceString.lower(allWords),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip39WordSpecificAutocomplete: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bip39WordSpecificAutocomplete

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bip39WordSpecificAutocomplete {
        return Bip39WordSpecificAutocomplete(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bip39WordSpecificAutocomplete) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39WordSpecificAutocomplete {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bip39WordSpecificAutocomplete, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39WordSpecificAutocomplete_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bip39WordSpecificAutocomplete {
    return try FfiConverterTypeBip39WordSpecificAutocomplete.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39WordSpecificAutocomplete_lower(_ value: Bip39WordSpecificAutocomplete) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBip39WordSpecificAutocomplete.lower(value)
}




public protocol BitcoinTransactionProtocol : AnyObject {
    
    func normalizeTxId()  -> String
    
    func txId()  -> TxId
    
    func txIdHash()  -> String
    
}

open class BitcoinTransaction:
    BitcoinTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_bitcointransaction(self.pointer, $0) }
    }
public convenience init(txHex: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeBitcoinTransactionError.lift) {
    uniffi_cove_fn_constructor_bitcointransaction_new(
        FfiConverterString.lower(txHex),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_bitcointransaction(pointer, $0) }
    }

    
public static func tryFromData(data: Data)throws  -> BitcoinTransaction  {
    return try  FfiConverterTypeBitcoinTransaction.lift(try rustCallWithError(FfiConverterTypeBitcoinTransactionError.lift) {
    uniffi_cove_fn_constructor_bitcointransaction_tryfromdata(
        FfiConverterData.lower(data),$0
    )
})
}
    

    
open func normalizeTxId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_bitcointransaction_normalize_tx_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func txId() -> TxId  {
    return try!  FfiConverterTypeTxId.lift(try! rustCall() {
    uniffi_cove_fn_method_bitcointransaction_tx_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func txIdHash() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_bitcointransaction_tx_id_hash(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BitcoinTransaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BitcoinTransaction {
        return BitcoinTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BitcoinTransaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BitcoinTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> BitcoinTransaction {
    return try FfiConverterTypeBitcoinTransaction.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinTransaction_lower(_ value: BitcoinTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBitcoinTransaction.lower(value)
}




public protocol BoxedRouteProtocol : AnyObject {
    
    func route()  -> Route
    
}

open class BoxedRoute:
    BoxedRouteProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_boxedroute(self.pointer, $0) }
    }
public convenience init(route: Route) {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_boxedroute_new(
        FfiConverterTypeRoute.lower(route),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_boxedroute(pointer, $0) }
    }

    

    
open func route() -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_boxedroute_route(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBoxedRoute: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BoxedRoute

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BoxedRoute {
        return BoxedRoute(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BoxedRoute) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BoxedRoute {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BoxedRoute, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBoxedRoute_lift(_ pointer: UnsafeMutableRawPointer) throws -> BoxedRoute {
    return try FfiConverterTypeBoxedRoute.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBoxedRoute_lower(_ value: BoxedRoute) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBoxedRoute.lower(value)
}




public protocol ChainPositionProtocol : AnyObject {
    
}

open class ChainPosition:
    ChainPositionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_chainposition(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_chainposition(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainPosition: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ChainPosition

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ChainPosition {
        return ChainPosition(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ChainPosition) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainPosition {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ChainPosition, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainPosition_lift(_ pointer: UnsafeMutableRawPointer) throws -> ChainPosition {
    return try FfiConverterTypeChainPosition.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainPosition_lower(_ value: ChainPosition) -> UnsafeMutableRawPointer {
    return FfiConverterTypeChainPosition.lower(value)
}




public protocol ConfirmDetailsProtocol : AnyObject {
    
    func feeRate()  -> FeeRate
    
    func feeTotal()  -> Amount
    
    func id()  -> TxId
    
    func idHash()  -> String
    
    func isEqual(rhs: ConfirmDetails)  -> Bool
    
    func normalizedId()  -> String
    
    func psbtBytes()  -> Data
    
    func psbtToBbqr() throws  -> [String]
    
    func psbtToHex()  -> String
    
    func sendingAmount()  -> Amount
    
    func sendingTo()  -> Address
    
    func spendingAmount()  -> Amount
    
}

open class ConfirmDetails:
    ConfirmDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_confirmdetails(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_confirmdetails(pointer, $0) }
    }

    
public static func previewNew() -> ConfirmDetails  {
    return try!  FfiConverterTypeConfirmDetails.lift(try! rustCall() {
    uniffi_cove_fn_constructor_confirmdetails_preview_new($0
    )
})
}
    

    
open func feeRate() -> FeeRate  {
    return try!  FfiConverterTypeFeeRate.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmdetails_fee_rate(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeTotal() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmdetails_fee_total(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> TxId  {
    return try!  FfiConverterTypeTxId.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmdetails_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func idHash() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmdetails_id_hash(self.uniffiClonePointer(),$0
    )
})
}
    
open func isEqual(rhs: ConfirmDetails) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmdetails_is_equal(self.uniffiClonePointer(),
        FfiConverterTypeConfirmDetails.lower(rhs),$0
    )
})
}
    
open func normalizedId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmdetails_normalized_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func psbtBytes() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmdetails_psbt_bytes(self.uniffiClonePointer(),$0
    )
})
}
    
open func psbtToBbqr()throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeConfirmDetailsError.lift) {
    uniffi_cove_fn_method_confirmdetails_psbt_to_bbqr(self.uniffiClonePointer(),$0
    )
})
}
    
open func psbtToHex() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmdetails_psbt_to_hex(self.uniffiClonePointer(),$0
    )
})
}
    
open func sendingAmount() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmdetails_sending_amount(self.uniffiClonePointer(),$0
    )
})
}
    
open func sendingTo() -> Address  {
    return try!  FfiConverterTypeAddress.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmdetails_sending_to(self.uniffiClonePointer(),$0
    )
})
}
    
open func spendingAmount() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmdetails_spending_amount(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ConfirmDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ConfirmDetails {
        return ConfirmDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ConfirmDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ConfirmDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> ConfirmDetails {
    return try FfiConverterTypeConfirmDetails.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmDetails_lower(_ value: ConfirmDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeConfirmDetails.lower(value)
}




public protocol ConfirmedTransactionProtocol : AnyObject {
    
    func blockHeight()  -> UInt32
    
    func blockHeightFmt()  -> String
    
    func confirmedAt()  -> UInt64
    
    func confirmedAtFmt()  -> String
    
    func confirmedAtFmtWithTime()  -> String
    
    func fiatAmount()  -> FiatAmount?
    
    func id()  -> TxId
    
    func label()  -> String
    
    func sentAndReceived()  -> SentAndReceived
    
}

open class ConfirmedTransaction:
    ConfirmedTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_confirmedtransaction(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_confirmedtransaction(pointer, $0) }
    }

    

    
open func blockHeight() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_block_height(self.uniffiClonePointer(),$0
    )
})
}
    
open func blockHeightFmt() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_block_height_fmt(self.uniffiClonePointer(),$0
    )
})
}
    
open func confirmedAt() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_confirmed_at(self.uniffiClonePointer(),$0
    )
})
}
    
open func confirmedAtFmt() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_confirmed_at_fmt(self.uniffiClonePointer(),$0
    )
})
}
    
open func confirmedAtFmtWithTime() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_confirmed_at_fmt_with_time(self.uniffiClonePointer(),$0
    )
})
}
    
open func fiatAmount() -> FiatAmount?  {
    return try!  FfiConverterOptionTypeFiatAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_fiat_amount(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> TxId  {
    return try!  FfiConverterTypeTxId.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func label() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_label(self.uniffiClonePointer(),$0
    )
})
}
    
open func sentAndReceived() -> SentAndReceived  {
    return try!  FfiConverterTypeSentAndReceived.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_sent_and_received(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmedTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ConfirmedTransaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ConfirmedTransaction {
        return ConfirmedTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ConfirmedTransaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmedTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ConfirmedTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmedTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> ConfirmedTransaction {
    return try FfiConverterTypeConfirmedTransaction.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmedTransaction_lower(_ value: ConfirmedTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeConfirmedTransaction.lower(value)
}




public protocol DatabaseProtocol : AnyObject {
    
    func globalConfig()  -> GlobalConfigTable
    
    func unsignedTransactions()  -> UnsignedTransactionsTable
    
    func wallets()  -> WalletsTable
    
}

open class Database:
    DatabaseProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_database(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_database_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_database(pointer, $0) }
    }

    

    
open func globalConfig() -> GlobalConfigTable  {
    return try!  FfiConverterTypeGlobalConfigTable.lift(try! rustCall() {
    uniffi_cove_fn_method_database_global_config(self.uniffiClonePointer(),$0
    )
})
}
    
open func unsignedTransactions() -> UnsignedTransactionsTable  {
    return try!  FfiConverterTypeUnsignedTransactionsTable.lift(try! rustCall() {
    uniffi_cove_fn_method_database_unsigned_transactions(self.uniffiClonePointer(),$0
    )
})
}
    
open func wallets() -> WalletsTable  {
    return try!  FfiConverterTypeWalletsTable.lift(try! rustCall() {
    uniffi_cove_fn_method_database_wallets(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDatabase: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Database

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Database {
        return Database(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Database) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Database {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Database, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatabase_lift(_ pointer: UnsafeMutableRawPointer) throws -> Database {
    return try FfiConverterTypeDatabase.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatabase_lower(_ value: Database) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDatabase.lower(value)
}




public protocol DeviceProtocol : AnyObject {
    
}

open class Device:
    DeviceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_device(self.pointer, $0) }
    }
public convenience init(device: DeviceAccess) {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_device_new(
        FfiConverterCallbackInterfaceDeviceAccess.lower(device),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_device(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDevice: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Device

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Device {
        return Device(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Device) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Device {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Device, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDevice_lift(_ pointer: UnsafeMutableRawPointer) throws -> Device {
    return try FfiConverterTypeDevice.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDevice_lower(_ value: Device) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDevice.lower(value)
}




public protocol FeeRateProtocol : AnyObject {
    
    func satPerVb()  -> Double
    
}

open class FeeRate:
    FeeRateProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_feerate(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_feerate(pointer, $0) }
    }

    
public static func fromSatPerVb(satPerVb: UInt64) -> FeeRate  {
    return try!  FfiConverterTypeFeeRate.lift(try! rustCall() {
    uniffi_cove_fn_constructor_feerate_from_sat_per_vb(
        FfiConverterUInt64.lower(satPerVb),$0
    )
})
}
    

    
open func satPerVb() -> Double  {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_cove_fn_method_feerate_sat_per_vb(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
        return FeeRate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
    return try FfiConverterTypeFeeRate.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRate.lower(value)
}




public protocol FeeRateOptionProtocol : AnyObject {
    
    func duration()  -> String
    
    func feeRate()  -> FeeRate
    
    func feeSpeed()  -> FeeSpeed
    
    func isEqual(rhs: FeeRateOption)  -> Bool
    
    func satPerVb()  -> Double
    
}

open class FeeRateOption:
    FeeRateOptionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_feerateoption(self.pointer, $0) }
    }
public convenience init(feeSpeed: FeeSpeed, feeRate: UInt64) {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_feerateoption_new(
        FfiConverterTypeFeeSpeed.lower(feeSpeed),
        FfiConverterUInt64.lower(feeRate),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_feerateoption(pointer, $0) }
    }

    

    
open func duration() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoption_duration(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeRate() -> FeeRate  {
    return try!  FfiConverterTypeFeeRate.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoption_fee_rate(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeSpeed() -> FeeSpeed  {
    return try!  FfiConverterTypeFeeSpeed.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoption_fee_speed(self.uniffiClonePointer(),$0
    )
})
}
    
open func isEqual(rhs: FeeRateOption) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoption_is_equal(self.uniffiClonePointer(),
        FfiConverterTypeFeeRateOption.lower(rhs),$0
    )
})
}
    
open func satPerVb() -> Double  {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoption_sat_per_vb(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOption: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRateOption

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOption {
        return FeeRateOption(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRateOption) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOption {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRateOption, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOption_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOption {
    return try FfiConverterTypeFeeRateOption.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOption_lower(_ value: FeeRateOption) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRateOption.lower(value)
}




public protocol FeeRateOptionWithTotalFeeProtocol : AnyObject {
    
    func duration()  -> String
    
    func feeRate()  -> FeeRate
    
    func feeRateOptions()  -> FeeRateOption
    
    func feeSpeed()  -> FeeSpeed
    
    func isEqual(rhs: FeeRateOptionWithTotalFee)  -> Bool
    
    func satPerVb()  -> Double
    
    func totalFee()  -> Amount
    
}

open class FeeRateOptionWithTotalFee:
    FeeRateOptionWithTotalFeeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_feerateoptionwithtotalfee(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_feerateoptionwithtotalfee(pointer, $0) }
    }

    

    
open func duration() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptionwithtotalfee_duration(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeRate() -> FeeRate  {
    return try!  FfiConverterTypeFeeRate.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptionwithtotalfee_fee_rate(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeRateOptions() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptionwithtotalfee_fee_rate_options(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeSpeed() -> FeeSpeed  {
    return try!  FfiConverterTypeFeeSpeed.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptionwithtotalfee_fee_speed(self.uniffiClonePointer(),$0
    )
})
}
    
open func isEqual(rhs: FeeRateOptionWithTotalFee) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptionwithtotalfee_is_equal(self.uniffiClonePointer(),
        FfiConverterTypeFeeRateOptionWithTotalFee.lower(rhs),$0
    )
})
}
    
open func satPerVb() -> Double  {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptionwithtotalfee_sat_per_vb(self.uniffiClonePointer(),$0
    )
})
}
    
open func totalFee() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptionwithtotalfee_total_fee(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOptionWithTotalFee: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRateOptionWithTotalFee

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptionWithTotalFee {
        return FeeRateOptionWithTotalFee(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRateOptionWithTotalFee) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOptionWithTotalFee {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRateOptionWithTotalFee, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionWithTotalFee_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptionWithTotalFee {
    return try FfiConverterTypeFeeRateOptionWithTotalFee.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionWithTotalFee_lower(_ value: FeeRateOptionWithTotalFee) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRateOptionWithTotalFee.lower(value)
}




public protocol FeeRateOptionsProtocol : AnyObject {
    
    func fast()  -> FeeRateOption
    
    func medium()  -> FeeRateOption
    
    func slow()  -> FeeRateOption
    
}

open class FeeRateOptions:
    FeeRateOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_feerateoptions(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_feerateoptions(pointer, $0) }
    }

    
public static func previewNew() -> FeeRateOptions  {
    return try!  FfiConverterTypeFeeRateOptions.lift(try! rustCall() {
    uniffi_cove_fn_constructor_feerateoptions_preview_new($0
    )
})
}
    

    
open func fast() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptions_fast(self.uniffiClonePointer(),$0
    )
})
}
    
open func medium() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptions_medium(self.uniffiClonePointer(),$0
    )
})
}
    
open func slow() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptions_slow(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRateOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptions {
        return FeeRateOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRateOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRateOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptions {
    return try FfiConverterTypeFeeRateOptions.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptions_lower(_ value: FeeRateOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRateOptions.lower(value)
}




public protocol FeeRateOptionsWithTotalFeeProtocol : AnyObject {
    
    func fast()  -> FeeRateOptionWithTotalFee
    
    func feeRateOptions()  -> FeeRateOptions
    
    func medium()  -> FeeRateOptionWithTotalFee
    
    func slow()  -> FeeRateOptionWithTotalFee
    
}

open class FeeRateOptionsWithTotalFee:
    FeeRateOptionsWithTotalFeeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_feerateoptionswithtotalfee(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_feerateoptionswithtotalfee(pointer, $0) }
    }

    
public static func previewNew() -> FeeRateOptionsWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionsWithTotalFee.lift(try! rustCall() {
    uniffi_cove_fn_constructor_feerateoptionswithtotalfee_preview_new($0
    )
})
}
    

    
open func fast() -> FeeRateOptionWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionWithTotalFee.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptionswithtotalfee_fast(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeRateOptions() -> FeeRateOptions  {
    return try!  FfiConverterTypeFeeRateOptions.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptionswithtotalfee_fee_rate_options(self.uniffiClonePointer(),$0
    )
})
}
    
open func medium() -> FeeRateOptionWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionWithTotalFee.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptionswithtotalfee_medium(self.uniffiClonePointer(),$0
    )
})
}
    
open func slow() -> FeeRateOptionWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionWithTotalFee.lift(try! rustCall() {
    uniffi_cove_fn_method_feerateoptionswithtotalfee_slow(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOptionsWithTotalFee: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRateOptionsWithTotalFee

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptionsWithTotalFee {
        return FeeRateOptionsWithTotalFee(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRateOptionsWithTotalFee) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOptionsWithTotalFee {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRateOptionsWithTotalFee, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionsWithTotalFee_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptionsWithTotalFee {
    return try FfiConverterTypeFeeRateOptionsWithTotalFee.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionsWithTotalFee_lower(_ value: FeeRateOptionsWithTotalFee) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRateOptionsWithTotalFee.lower(value)
}




/**
 * Representation of our app over FFI. Essentially a wrapper of [`App`].
 */
public protocol FfiAppProtocol : AnyObject {
    
    /**
     * Frontend calls this method to send events to the rust application logic
     */
    func dispatch(action: AppAction) 
    
    func fees() async throws  -> FeeResponse
    
    /**
     * Get the selected wallet
     */
    func goToSelectedWallet()  -> WalletId?
    
    /**
     * Check if there's any wallets
     */
    func hasWallets()  -> Bool
    
    /**
     * run all initialization tasks here, only called once
     */
    func initOnStart() async 
    
    func listenForUpdates(updater: FfiReconcile) 
    
    /**
     * Load and reset the default route after 800ms delay
     */
    func loadAndResetDefaultRoute(route: Route) 
    
    /**
     * Load and reset the default route
     * Shows a laoding screen, and then resets the default route
     */
    func loadAndResetDefaultRouteAfter(route: Route, afterMillis: UInt32) 
    
    func network()  -> Network
    
    /**
     * Number of wallets
     */
    func numWallets()  -> UInt16
    
    func prices() async throws  -> PriceResponse
    
    /**
     * Change the default route, and reset the routes
     */
    func resetDefaultRouteTo(route: Route) 
    
    /**
     * Reset the default route, with a nested route
     */
    func resetNestedRoutesTo(defaultRoute: Route, nestedRoutes: [Route]) 
    
    /**
     * Select a wallet
     */
    func selectWallet(id: WalletId, nextRoute: Route?) throws 
    
    func state()  -> AppState
    
}

/**
 * Representation of our app over FFI. Essentially a wrapper of [`App`].
 */
open class FfiApp:
    FfiAppProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_ffiapp(self.pointer, $0) }
    }
    /**
     * FFI constructor which wraps in an Arc
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_ffiapp_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_ffiapp(pointer, $0) }
    }

    

    
    /**
     * Frontend calls this method to send events to the rust application logic
     */
open func dispatch(action: AppAction)  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_dispatch(self.uniffiClonePointer(),
        FfiConverterTypeAppAction.lower(action),$0
    )
}
}
    
open func fees()async throws  -> FeeResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_ffiapp_fees(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFeeResponse.lift,
            errorHandler: FfiConverterTypeAppError.lift
        )
}
    
    /**
     * Get the selected wallet
     */
open func goToSelectedWallet() -> WalletId?  {
    return try!  FfiConverterOptionTypeWalletId.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_go_to_selected_wallet(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if there's any wallets
     */
open func hasWallets() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_has_wallets(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * run all initialization tasks here, only called once
     */
open func initOnStart()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_ffiapp_init_on_start(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func listenForUpdates(updater: FfiReconcile)  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_listen_for_updates(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceFfiReconcile.lower(updater),$0
    )
}
}
    
    /**
     * Load and reset the default route after 800ms delay
     */
open func loadAndResetDefaultRoute(route: Route)  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_load_and_reset_default_route(self.uniffiClonePointer(),
        FfiConverterTypeRoute.lower(route),$0
    )
}
}
    
    /**
     * Load and reset the default route
     * Shows a laoding screen, and then resets the default route
     */
open func loadAndResetDefaultRouteAfter(route: Route, afterMillis: UInt32)  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_load_and_reset_default_route_after(self.uniffiClonePointer(),
        FfiConverterTypeRoute.lower(route),
        FfiConverterUInt32.lower(afterMillis),$0
    )
}
}
    
open func network() -> Network  {
    return try!  FfiConverterTypeNetwork.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_network(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Number of wallets
     */
open func numWallets() -> UInt16  {
    return try!  FfiConverterUInt16.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_num_wallets(self.uniffiClonePointer(),$0
    )
})
}
    
open func prices()async throws  -> PriceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_ffiapp_prices(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePriceResponse.lift,
            errorHandler: FfiConverterTypeAppError.lift
        )
}
    
    /**
     * Change the default route, and reset the routes
     */
open func resetDefaultRouteTo(route: Route)  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_reset_default_route_to(self.uniffiClonePointer(),
        FfiConverterTypeRoute.lower(route),$0
    )
}
}
    
    /**
     * Reset the default route, with a nested route
     */
open func resetNestedRoutesTo(defaultRoute: Route, nestedRoutes: [Route])  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_reset_nested_routes_to(self.uniffiClonePointer(),
        FfiConverterTypeRoute.lower(defaultRoute),
        FfiConverterSequenceTypeRoute.lower(nestedRoutes),$0
    )
}
}
    
    /**
     * Select a wallet
     */
open func selectWallet(id: WalletId, nextRoute: Route? = nil)throws   {try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_ffiapp_select_wallet(self.uniffiClonePointer(),
        FfiConverterTypeWalletId.lower(id),
        FfiConverterOptionTypeRoute.lower(nextRoute),$0
    )
}
}
    
open func state() -> AppState  {
    return try!  FfiConverterTypeAppState.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_state(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiApp: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiApp

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiApp {
        return FfiApp(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiApp) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiApp {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiApp, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiApp_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiApp {
    return try FfiConverterTypeFfiApp.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiApp_lower(_ value: FfiApp) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiApp.lower(value)
}




public protocol FfiNfcReaderProtocol : AnyObject {
    
    func dataFromRecords(records: [NdefRecord])  -> Data
    
    func isResumeable(data: Data) throws 
    
    func isStarted()  -> Bool
    
    func messageInfo()  -> MessageInfo?
    
    func parse(data: Data) throws  -> ParseResult
    
    func stringFromRecord(record: NdefRecord)  -> String?
    
}

open class FfiNfcReader:
    FfiNfcReaderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_ffinfcreader(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_ffinfcreader_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_ffinfcreader(pointer, $0) }
    }

    

    
open func dataFromRecords(records: [NdefRecord]) -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_cove_fn_method_ffinfcreader_data_from_records(self.uniffiClonePointer(),
        FfiConverterSequenceTypeNdefRecord.lower(records),$0
    )
})
}
    
open func isResumeable(data: Data)throws   {try rustCallWithError(FfiConverterTypeResumeError.lift) {
    uniffi_cove_fn_method_ffinfcreader_is_resumeable(self.uniffiClonePointer(),
        FfiConverterData.lower(data),$0
    )
}
}
    
open func isStarted() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_ffinfcreader_is_started(self.uniffiClonePointer(),$0
    )
})
}
    
open func messageInfo() -> MessageInfo?  {
    return try!  FfiConverterOptionTypeMessageInfo.lift(try! rustCall() {
    uniffi_cove_fn_method_ffinfcreader_message_info(self.uniffiClonePointer(),$0
    )
})
}
    
open func parse(data: Data)throws  -> ParseResult  {
    return try  FfiConverterTypeParseResult.lift(try rustCallWithError(FfiConverterTypeNfcReaderError.lift) {
    uniffi_cove_fn_method_ffinfcreader_parse(self.uniffiClonePointer(),
        FfiConverterData.lower(data),$0
    )
})
}
    
open func stringFromRecord(record: NdefRecord) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_ffinfcreader_string_from_record(self.uniffiClonePointer(),
        FfiConverterTypeNdefRecord.lower(record),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiNfcReader: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiNfcReader

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiNfcReader {
        return FfiNfcReader(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiNfcReader) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiNfcReader {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiNfcReader, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiNfcReader_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiNfcReader {
    return try FfiConverterTypeFfiNfcReader.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiNfcReader_lower(_ value: FfiNfcReader) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiNfcReader.lower(value)
}




public protocol FiatClientProtocol : AnyObject {
    
}

open class FiatClient:
    FiatClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_fiatclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_fiatclient(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FiatClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FiatClient {
        return FiatClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FiatClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FiatClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> FiatClient {
    return try FfiConverterTypeFiatClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatClient_lower(_ value: FiatClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFiatClient.lower(value)
}




public protocol FileHandlerProtocol : AnyObject {
    
    func read() throws  -> MultiFormat
    
}

open class FileHandler:
    FileHandlerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_filehandler(self.pointer, $0) }
    }
public convenience init(filePath: String) {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_filehandler_new(
        FfiConverterString.lower(filePath),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_filehandler(pointer, $0) }
    }

    

    
open func read()throws  -> MultiFormat  {
    return try  FfiConverterTypeMultiFormat.lift(try rustCallWithError(FfiConverterTypeFileHandlerError.lift) {
    uniffi_cove_fn_method_filehandler_read(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileHandler: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FileHandler

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FileHandler {
        return FileHandler(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FileHandler) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileHandler {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FileHandler, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileHandler_lift(_ pointer: UnsafeMutableRawPointer) throws -> FileHandler {
    return try FfiConverterTypeFileHandler.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileHandler_lower(_ value: FileHandler) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFileHandler.lower(value)
}




public protocol FingerprintProtocol : AnyObject {
    
    func asLowercase()  -> String
    
    func asUppercase()  -> String
    
}

open class Fingerprint:
    FingerprintProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_fingerprint(self.pointer, $0) }
    }
public convenience init(id: WalletId)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeFingerprintError.lift) {
    uniffi_cove_fn_constructor_fingerprint_new(
        FfiConverterTypeWalletId.lower(id),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_fingerprint(pointer, $0) }
    }

    

    
open func asLowercase() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_fingerprint_as_lowercase(self.uniffiClonePointer(),$0
    )
})
}
    
open func asUppercase() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_fingerprint_as_uppercase(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFingerprint: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Fingerprint

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Fingerprint {
        return Fingerprint(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Fingerprint) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fingerprint {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Fingerprint, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFingerprint_lift(_ pointer: UnsafeMutableRawPointer) throws -> Fingerprint {
    return try FfiConverterTypeFingerprint.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFingerprint_lower(_ value: Fingerprint) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFingerprint.lower(value)
}




public protocol FoundJsonProtocol : AnyObject {
    
}

open class FoundJson:
    FoundJsonProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_foundjson(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_foundjson(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFoundJson: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FoundJson

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FoundJson {
        return FoundJson(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FoundJson) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FoundJson {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FoundJson, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFoundJson_lift(_ pointer: UnsafeMutableRawPointer) throws -> FoundJson {
    return try FfiConverterTypeFoundJson.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFoundJson_lower(_ value: FoundJson) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFoundJson.lower(value)
}




public protocol GlobalConfigTableProtocol : AnyObject {
    
    func clearSelectedWallet() throws 
    
    func colorScheme()  -> ColorSchemeSelection
    
    func delete(key: GlobalConfigKey) throws 
    
    func get(key: GlobalConfigKey) throws  -> String?
    
    func selectWallet(id: WalletId) throws 
    
    func selectedNetwork()  -> Network
    
    func selectedNode()  -> Node
    
    func selectedWallet()  -> WalletId?
    
    func set(key: GlobalConfigKey, value: String) throws 
    
    func setColorScheme(colorScheme: ColorSchemeSelection) throws 
    
    func setSelectedNetwork(network: Network) throws 
    
    func setSelectedNode(node: Node) throws 
    
}

open class GlobalConfigTable:
    GlobalConfigTableProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_globalconfigtable(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_globalconfigtable(pointer, $0) }
    }

    

    
open func clearSelectedWallet()throws   {try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_globalconfigtable_clear_selected_wallet(self.uniffiClonePointer(),$0
    )
}
}
    
open func colorScheme() -> ColorSchemeSelection  {
    return try!  FfiConverterTypeColorSchemeSelection.lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_color_scheme(self.uniffiClonePointer(),$0
    )
})
}
    
open func delete(key: GlobalConfigKey)throws   {try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_globalconfigtable_delete(self.uniffiClonePointer(),
        FfiConverterTypeGlobalConfigKey.lower(key),$0
    )
}
}
    
open func get(key: GlobalConfigKey)throws  -> String?  {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_globalconfigtable_get(self.uniffiClonePointer(),
        FfiConverterTypeGlobalConfigKey.lower(key),$0
    )
})
}
    
open func selectWallet(id: WalletId)throws   {try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_globalconfigtable_select_wallet(self.uniffiClonePointer(),
        FfiConverterTypeWalletId.lower(id),$0
    )
}
}
    
open func selectedNetwork() -> Network  {
    return try!  FfiConverterTypeNetwork.lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_selected_network(self.uniffiClonePointer(),$0
    )
})
}
    
open func selectedNode() -> Node  {
    return try!  FfiConverterTypeNode.lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_selected_node(self.uniffiClonePointer(),$0
    )
})
}
    
open func selectedWallet() -> WalletId?  {
    return try!  FfiConverterOptionTypeWalletId.lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_selected_wallet(self.uniffiClonePointer(),$0
    )
})
}
    
open func set(key: GlobalConfigKey, value: String)throws   {try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_globalconfigtable_set(self.uniffiClonePointer(),
        FfiConverterTypeGlobalConfigKey.lower(key),
        FfiConverterString.lower(value),$0
    )
}
}
    
open func setColorScheme(colorScheme: ColorSchemeSelection)throws   {try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_globalconfigtable_set_color_scheme(self.uniffiClonePointer(),
        FfiConverterTypeColorSchemeSelection.lower(colorScheme),$0
    )
}
}
    
open func setSelectedNetwork(network: Network)throws   {try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_globalconfigtable_set_selected_network(self.uniffiClonePointer(),
        FfiConverterTypeNetwork.lower(network),$0
    )
}
}
    
open func setSelectedNode(node: Node)throws   {try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_globalconfigtable_set_selected_node(self.uniffiClonePointer(),
        FfiConverterTypeNode.lower(node),$0
    )
}
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalConfigTable: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GlobalConfigTable

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GlobalConfigTable {
        return GlobalConfigTable(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GlobalConfigTable) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalConfigTable {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GlobalConfigTable, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfigTable_lift(_ pointer: UnsafeMutableRawPointer) throws -> GlobalConfigTable {
    return try FfiConverterTypeGlobalConfigTable.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfigTable_lower(_ value: GlobalConfigTable) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGlobalConfigTable.lower(value)
}




public protocol GlobalFlagTableProtocol : AnyObject {
    
    func get(key: GlobalFlagKey) throws  -> Bool
    
    func set(key: GlobalFlagKey, value: Bool) throws 
    
    func toggleBoolConfig(key: GlobalFlagKey) throws 
    
}

open class GlobalFlagTable:
    GlobalFlagTableProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_globalflagtable(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_globalflagtable(pointer, $0) }
    }

    

    
open func get(key: GlobalFlagKey)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_globalflagtable_get(self.uniffiClonePointer(),
        FfiConverterTypeGlobalFlagKey.lower(key),$0
    )
})
}
    
open func set(key: GlobalFlagKey, value: Bool)throws   {try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_globalflagtable_set(self.uniffiClonePointer(),
        FfiConverterTypeGlobalFlagKey.lower(key),
        FfiConverterBool.lower(value),$0
    )
}
}
    
open func toggleBoolConfig(key: GlobalFlagKey)throws   {try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_globalflagtable_toggle_bool_config(self.uniffiClonePointer(),
        FfiConverterTypeGlobalFlagKey.lower(key),$0
    )
}
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalFlagTable: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GlobalFlagTable

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GlobalFlagTable {
        return GlobalFlagTable(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GlobalFlagTable) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalFlagTable {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GlobalFlagTable, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalFlagTable_lift(_ pointer: UnsafeMutableRawPointer) throws -> GlobalFlagTable {
    return try FfiConverterTypeGlobalFlagTable.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalFlagTable_lower(_ value: GlobalFlagTable) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGlobalFlagTable.lower(value)
}




public protocol HardwareExportProtocol : AnyObject {
    
}

open class HardwareExport:
    HardwareExportProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_hardwareexport(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_hardwareexport(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHardwareExport: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HardwareExport

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HardwareExport {
        return HardwareExport(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HardwareExport) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HardwareExport {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HardwareExport, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHardwareExport_lift(_ pointer: UnsafeMutableRawPointer) throws -> HardwareExport {
    return try FfiConverterTypeHardwareExport.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHardwareExport_lower(_ value: HardwareExport) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHardwareExport.lower(value)
}




public protocol HeaderIconPresenterProtocol : AnyObject {
    
    func backgroundColor(state: TransactionState, direction: TransactionDirection, colorScheme: FfiColorScheme, confirmationCount: Int32)  -> FfiColor
    
    func iconColor(state: TransactionState, direction: TransactionDirection, colorScheme: FfiColorScheme, confirmationCount: Int32)  -> FfiColor
    
    func ringColor(state: TransactionState, colorScheme: FfiColorScheme, direction: TransactionDirection, confirmations: Int32, ringNumber: Int32)  -> FfiColor
    
}

open class HeaderIconPresenter:
    HeaderIconPresenterProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_headericonpresenter(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_headericonpresenter_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_headericonpresenter(pointer, $0) }
    }

    

    
open func backgroundColor(state: TransactionState, direction: TransactionDirection, colorScheme: FfiColorScheme, confirmationCount: Int32) -> FfiColor  {
    return try!  FfiConverterTypeFfiColor.lift(try! rustCall() {
    uniffi_cove_fn_method_headericonpresenter_background_color(self.uniffiClonePointer(),
        FfiConverterTypeTransactionState.lower(state),
        FfiConverterTypeTransactionDirection.lower(direction),
        FfiConverterTypeFfiColorScheme.lower(colorScheme),
        FfiConverterInt32.lower(confirmationCount),$0
    )
})
}
    
open func iconColor(state: TransactionState, direction: TransactionDirection, colorScheme: FfiColorScheme, confirmationCount: Int32) -> FfiColor  {
    return try!  FfiConverterTypeFfiColor.lift(try! rustCall() {
    uniffi_cove_fn_method_headericonpresenter_icon_color(self.uniffiClonePointer(),
        FfiConverterTypeTransactionState.lower(state),
        FfiConverterTypeTransactionDirection.lower(direction),
        FfiConverterTypeFfiColorScheme.lower(colorScheme),
        FfiConverterInt32.lower(confirmationCount),$0
    )
})
}
    
open func ringColor(state: TransactionState, colorScheme: FfiColorScheme, direction: TransactionDirection, confirmations: Int32, ringNumber: Int32) -> FfiColor  {
    return try!  FfiConverterTypeFfiColor.lift(try! rustCall() {
    uniffi_cove_fn_method_headericonpresenter_ring_color(self.uniffiClonePointer(),
        FfiConverterTypeTransactionState.lower(state),
        FfiConverterTypeFfiColorScheme.lower(colorScheme),
        FfiConverterTypeTransactionDirection.lower(direction),
        FfiConverterInt32.lower(confirmations),
        FfiConverterInt32.lower(ringNumber),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHeaderIconPresenter: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HeaderIconPresenter

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HeaderIconPresenter {
        return HeaderIconPresenter(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HeaderIconPresenter) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HeaderIconPresenter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HeaderIconPresenter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeaderIconPresenter_lift(_ pointer: UnsafeMutableRawPointer) throws -> HeaderIconPresenter {
    return try FfiConverterTypeHeaderIconPresenter.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeaderIconPresenter_lower(_ value: HeaderIconPresenter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHeaderIconPresenter.lower(value)
}




public protocol KeychainProtocol : AnyObject {
    
}

open class Keychain:
    KeychainProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_keychain(self.pointer, $0) }
    }
public convenience init(keychain: KeychainAccess) {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_keychain_new(
        FfiConverterCallbackInterfaceKeychainAccess.lower(keychain),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_keychain(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeychain: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Keychain

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Keychain {
        return Keychain(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Keychain) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Keychain {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Keychain, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeychain_lift(_ pointer: UnsafeMutableRawPointer) throws -> Keychain {
    return try FfiConverterTypeKeychain.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeychain_lower(_ value: Keychain) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKeychain.lower(value)
}




public protocol MnemonicProtocol : AnyObject {
    
    func allWords()  -> [GroupedWord]
    
    func words()  -> [String]
    
}

open class Mnemonic:
    MnemonicProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_mnemonic(self.pointer, $0) }
    }
public convenience init(id: WalletId)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeMnemonicError.lift) {
    uniffi_cove_fn_constructor_mnemonic_new(
        FfiConverterTypeWalletId.lower(id),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_mnemonic(pointer, $0) }
    }

    
public static func preview(numberOfBip39Words: NumberOfBip39Words) -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_cove_fn_constructor_mnemonic_preview(
        FfiConverterTypeNumberOfBip39Words.lower(numberOfBip39Words),$0
    )
})
}
    

    
open func allWords() -> [GroupedWord]  {
    return try!  FfiConverterSequenceTypeGroupedWord.lift(try! rustCall() {
    uniffi_cove_fn_method_mnemonic_all_words(self.uniffiClonePointer(),$0
    )
})
}
    
open func words() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_mnemonic_words(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonic: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Mnemonic

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Mnemonic {
        return Mnemonic(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Mnemonic) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lift(_ pointer: UnsafeMutableRawPointer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMnemonic.lower(value)
}




public protocol MultiQrProtocol : AnyObject {
    
    func addPart(qr: String) throws  -> BbqrJoinResult
    
    func getGroupedWords(qr: StringOrData, groupsOf: UInt8) throws  -> [[String]]?
    
    func handleScanResult(qr: StringOrData) throws  -> MultiQrScanResult
    
    func isBbqr()  -> Bool
    
    func isSeedQr()  -> Bool
    
    func totalParts()  -> UInt32
    
}

open class MultiQr:
    MultiQrProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_multiqr(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_multiqr(pointer, $0) }
    }

    
public static func newFromString(qr: String) -> MultiQr  {
    return try!  FfiConverterTypeMultiQr.lift(try! rustCall() {
    uniffi_cove_fn_constructor_multiqr_new_from_string(
        FfiConverterString.lower(qr),$0
    )
})
}
    
public static func tryNew(qr: StringOrData)throws  -> MultiQr  {
    return try  FfiConverterTypeMultiQr.lift(try rustCallWithError(FfiConverterTypeMultiQrError.lift) {
    uniffi_cove_fn_constructor_multiqr_try_new(
        FfiConverterTypeStringOrData.lower(qr),$0
    )
})
}
    
public static func tryNewFromData(data: Data)throws  -> MultiQr  {
    return try  FfiConverterTypeMultiQr.lift(try rustCallWithError(FfiConverterTypeMultiQrError.lift) {
    uniffi_cove_fn_constructor_multiqr_try_new_from_data(
        FfiConverterData.lower(data),$0
    )
})
}
    

    
open func addPart(qr: String)throws  -> BbqrJoinResult  {
    return try  FfiConverterTypeBbqrJoinResult.lift(try rustCallWithError(FfiConverterTypeMultiQrError.lift) {
    uniffi_cove_fn_method_multiqr_add_part(self.uniffiClonePointer(),
        FfiConverterString.lower(qr),$0
    )
})
}
    
open func getGroupedWords(qr: StringOrData, groupsOf: UInt8)throws  -> [[String]]?  {
    return try  FfiConverterOptionSequenceSequenceString.lift(try rustCallWithError(FfiConverterTypeMultiQrError.lift) {
    uniffi_cove_fn_method_multiqr_get_grouped_words(self.uniffiClonePointer(),
        FfiConverterTypeStringOrData.lower(qr),
        FfiConverterUInt8.lower(groupsOf),$0
    )
})
}
    
open func handleScanResult(qr: StringOrData)throws  -> MultiQrScanResult  {
    return try  FfiConverterTypeMultiQrScanResult.lift(try rustCallWithError(FfiConverterTypeMultiQrError.lift) {
    uniffi_cove_fn_method_multiqr_handle_scan_result(self.uniffiClonePointer(),
        FfiConverterTypeStringOrData.lower(qr),$0
    )
})
}
    
open func isBbqr() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_multiqr_is_bbqr(self.uniffiClonePointer(),$0
    )
})
}
    
open func isSeedQr() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_multiqr_is_seed_qr(self.uniffiClonePointer(),$0
    )
})
}
    
open func totalParts() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_cove_fn_method_multiqr_total_parts(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMultiQr: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MultiQr

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MultiQr {
        return MultiQr(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MultiQr) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiQr {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MultiQr, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiQr_lift(_ pointer: UnsafeMutableRawPointer) throws -> MultiQr {
    return try FfiConverterTypeMultiQr.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiQr_lower(_ value: MultiQr) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMultiQr.lower(value)
}




public protocol NdefRecordReaderProtocol : AnyObject {
    
    func id()  -> String?
    
    func type()  -> String?
    
}

open class NdefRecordReader:
    NdefRecordReaderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_ndefrecordreader(self.pointer, $0) }
    }
public convenience init(record: NdefRecord) {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_ndefrecordreader_new(
        FfiConverterTypeNdefRecord.lower(record),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_ndefrecordreader(pointer, $0) }
    }

    

    
open func id() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_ndefrecordreader_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func type() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_ndefrecordreader_type_(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNdefRecordReader: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NdefRecordReader

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NdefRecordReader {
        return NdefRecordReader(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NdefRecordReader) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NdefRecordReader {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NdefRecordReader, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNdefRecordReader_lift(_ pointer: UnsafeMutableRawPointer) throws -> NdefRecordReader {
    return try FfiConverterTypeNdefRecordReader.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNdefRecordReader_lower(_ value: NdefRecordReader) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNdefRecordReader.lower(value)
}




public protocol NfcConstProtocol : AnyObject {
    
    func bytesPerBlock()  -> UInt16
    
    func numberOfBlocksPerChunk()  -> UInt16
    
    func totalBytesPerChunk()  -> UInt16
    
}

open class NfcConst:
    NfcConstProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_nfcconst(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_nfcconst_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_nfcconst(pointer, $0) }
    }

    

    
open func bytesPerBlock() -> UInt16  {
    return try!  FfiConverterUInt16.lift(try! rustCall() {
    uniffi_cove_fn_method_nfcconst_bytes_per_block(self.uniffiClonePointer(),$0
    )
})
}
    
open func numberOfBlocksPerChunk() -> UInt16  {
    return try!  FfiConverterUInt16.lift(try! rustCall() {
    uniffi_cove_fn_method_nfcconst_number_of_blocks_per_chunk(self.uniffiClonePointer(),$0
    )
})
}
    
open func totalBytesPerChunk() -> UInt16  {
    return try!  FfiConverterUInt16.lift(try! rustCall() {
    uniffi_cove_fn_method_nfcconst_total_bytes_per_chunk(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNfcConst: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NfcConst

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NfcConst {
        return NfcConst(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NfcConst) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NfcConst {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NfcConst, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNfcConst_lift(_ pointer: UnsafeMutableRawPointer) throws -> NfcConst {
    return try FfiConverterTypeNfcConst.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNfcConst_lower(_ value: NfcConst) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNfcConst.lower(value)
}




public protocol NodeSelectorProtocol : AnyObject {
    
    /**
     * Check the node url and set it as selected node if it is valid
     */
    func checkAndSaveNode(node: Node) async throws 
    
    func checkSelectedNode(node: Node) async throws 
    
    func nodeList()  -> [NodeSelection]
    
    /**
     * Use the url and name of the custom node to set it as the selected node
     */
    func parseCustomNode(url: String, name: String, enteredName: String) throws  -> Node
    
    func selectPresetNode(name: String) throws  -> Node
    
    func selectedNode()  -> NodeSelection
    
}

open class NodeSelector:
    NodeSelectorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_nodeselector(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_nodeselector_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_nodeselector(pointer, $0) }
    }

    

    
    /**
     * Check the node url and set it as selected node if it is valid
     */
open func checkAndSaveNode(node: Node)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_nodeselector_check_and_save_node(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNode.lower(node)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNodeSelectorError.lift
        )
}
    
open func checkSelectedNode(node: Node)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_nodeselector_check_selected_node(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNode.lower(node)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNodeSelectorError.lift
        )
}
    
open func nodeList() -> [NodeSelection]  {
    return try!  FfiConverterSequenceTypeNodeSelection.lift(try! rustCall() {
    uniffi_cove_fn_method_nodeselector_node_list(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Use the url and name of the custom node to set it as the selected node
     */
open func parseCustomNode(url: String, name: String, enteredName: String)throws  -> Node  {
    return try  FfiConverterTypeNode.lift(try rustCallWithError(FfiConverterTypeNodeSelectorError.lift) {
    uniffi_cove_fn_method_nodeselector_parse_custom_node(self.uniffiClonePointer(),
        FfiConverterString.lower(url),
        FfiConverterString.lower(name),
        FfiConverterString.lower(enteredName),$0
    )
})
}
    
open func selectPresetNode(name: String)throws  -> Node  {
    return try  FfiConverterTypeNode.lift(try rustCallWithError(FfiConverterTypeNodeSelectorError.lift) {
    uniffi_cove_fn_method_nodeselector_select_preset_node(self.uniffiClonePointer(),
        FfiConverterString.lower(name),$0
    )
})
}
    
open func selectedNode() -> NodeSelection  {
    return try!  FfiConverterTypeNodeSelection.lift(try! rustCall() {
    uniffi_cove_fn_method_nodeselector_selected_node(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeSelector: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NodeSelector

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NodeSelector {
        return NodeSelector(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NodeSelector) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeSelector {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NodeSelector, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeSelector_lift(_ pointer: UnsafeMutableRawPointer) throws -> NodeSelector {
    return try FfiConverterTypeNodeSelector.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeSelector_lower(_ value: NodeSelector) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNodeSelector.lower(value)
}




public protocol OutPointProtocol : AnyObject {
    
}

open class OutPoint:
    OutPointProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_outpoint(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_outpoint(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutPoint: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OutPoint

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OutPoint {
        return OutPoint(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OutPoint) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lift(_ pointer: UnsafeMutableRawPointer) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOutPoint.lower(value)
}




public protocol PendingWalletProtocol : AnyObject {
    
}

open class PendingWallet:
    PendingWalletProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_pendingwallet(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_pendingwallet(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingWallet: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PendingWallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PendingWallet {
        return PendingWallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PendingWallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PendingWallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> PendingWallet {
    return try FfiConverterTypePendingWallet.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWallet_lower(_ value: PendingWallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypePendingWallet.lower(value)
}




public protocol PsbtProtocol : AnyObject {
    
    /**
     * Total fee in sats.
     */
    func fee() throws  -> Amount
    
    /**
     * Get the transaction id of the unsigned transaction
     */
    func txId()  -> TxId
    
    /**
     * The virtual size of the transaction.
     */
    func weight()  -> UInt64
    
}

open class Psbt:
    PsbtProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_psbt(self.pointer, $0) }
    }
public convenience init(data: Data)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypePsbtError.lift) {
    uniffi_cove_fn_constructor_psbt_new(
        FfiConverterData.lower(data),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_psbt(pointer, $0) }
    }

    

    
    /**
     * Total fee in sats.
     */
open func fee()throws  -> Amount  {
    return try  FfiConverterTypeAmount.lift(try rustCallWithError(FfiConverterTypePsbtError.lift) {
    uniffi_cove_fn_method_psbt_fee(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the transaction id of the unsigned transaction
     */
open func txId() -> TxId  {
    return try!  FfiConverterTypeTxId.lift(try! rustCall() {
    uniffi_cove_fn_method_psbt_tx_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The virtual size of the transaction.
     */
open func weight() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_psbt_weight(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbt: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Psbt

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Psbt {
        return Psbt(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Psbt) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Psbt {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Psbt, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbt_lift(_ pointer: UnsafeMutableRawPointer) throws -> Psbt {
    return try FfiConverterTypePsbt.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbt_lower(_ value: Psbt) -> UnsafeMutableRawPointer {
    return FfiConverterTypePsbt.lower(value)
}




public protocol RouteFactoryProtocol : AnyObject {
    
    func coldWalletImport(route: ColdWalletRoute)  -> Route
    
    func hotWallet(route: HotWalletRoute)  -> Route
    
    func hotWalletImportFromScan()  -> Route
    
    func isSameParentRoute(route: Route, routeToCheck: Route)  -> Bool
    
    func loadAndResetNestedTo(defaultRoute: Route, nestedRoutes: [Route])  -> Route
    
    func loadAndResetTo(resetTo: Route)  -> Route
    
    func loadAndResetToAfter(resetTo: Route, time: UInt32)  -> Route
    
    func newHotWallet()  -> Route
    
    func newWalletSelect()  -> Route
    
    func qrImport()  -> Route
    
    func secretWords(walletId: WalletId)  -> Route
    
    func send(send: SendRoute)  -> Route
    
    func sendConfirm(id: WalletId, details: ConfirmDetails)  -> Route
    
    func sendHardwareExport(id: WalletId, details: ConfirmDetails)  -> Route
    
    func sendSetAmount(id: WalletId, address: Address?, amount: Amount?)  -> Route
    
}

open class RouteFactory:
    RouteFactoryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_routefactory(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_routefactory_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_routefactory(pointer, $0) }
    }

    

    
open func coldWalletImport(route: ColdWalletRoute) -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_cold_wallet_import(self.uniffiClonePointer(),
        FfiConverterTypeColdWalletRoute.lower(route),$0
    )
})
}
    
open func hotWallet(route: HotWalletRoute) -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_hot_wallet(self.uniffiClonePointer(),
        FfiConverterTypeHotWalletRoute.lower(route),$0
    )
})
}
    
open func hotWalletImportFromScan() -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_hot_wallet_import_from_scan(self.uniffiClonePointer(),$0
    )
})
}
    
open func isSameParentRoute(route: Route, routeToCheck: Route) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_is_same_parent_route(self.uniffiClonePointer(),
        FfiConverterTypeRoute.lower(route),
        FfiConverterTypeRoute.lower(routeToCheck),$0
    )
})
}
    
open func loadAndResetNestedTo(defaultRoute: Route, nestedRoutes: [Route]) -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_load_and_reset_nested_to(self.uniffiClonePointer(),
        FfiConverterTypeRoute.lower(defaultRoute),
        FfiConverterSequenceTypeRoute.lower(nestedRoutes),$0
    )
})
}
    
open func loadAndResetTo(resetTo: Route) -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_load_and_reset_to(self.uniffiClonePointer(),
        FfiConverterTypeRoute.lower(resetTo),$0
    )
})
}
    
open func loadAndResetToAfter(resetTo: Route, time: UInt32) -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_load_and_reset_to_after(self.uniffiClonePointer(),
        FfiConverterTypeRoute.lower(resetTo),
        FfiConverterUInt32.lower(time),$0
    )
})
}
    
open func newHotWallet() -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_new_hot_wallet(self.uniffiClonePointer(),$0
    )
})
}
    
open func newWalletSelect() -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_new_wallet_select(self.uniffiClonePointer(),$0
    )
})
}
    
open func qrImport() -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_qr_import(self.uniffiClonePointer(),$0
    )
})
}
    
open func secretWords(walletId: WalletId) -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_secret_words(self.uniffiClonePointer(),
        FfiConverterTypeWalletId.lower(walletId),$0
    )
})
}
    
open func send(send: SendRoute) -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_send(self.uniffiClonePointer(),
        FfiConverterTypeSendRoute.lower(send),$0
    )
})
}
    
open func sendConfirm(id: WalletId, details: ConfirmDetails) -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_send_confirm(self.uniffiClonePointer(),
        FfiConverterTypeWalletId.lower(id),
        FfiConverterTypeConfirmDetails.lower(details),$0
    )
})
}
    
open func sendHardwareExport(id: WalletId, details: ConfirmDetails) -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_send_hardware_export(self.uniffiClonePointer(),
        FfiConverterTypeWalletId.lower(id),
        FfiConverterTypeConfirmDetails.lower(details),$0
    )
})
}
    
open func sendSetAmount(id: WalletId, address: Address? = nil, amount: Amount? = nil) -> Route  {
    return try!  FfiConverterTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_send_set_amount(self.uniffiClonePointer(),
        FfiConverterTypeWalletId.lower(id),
        FfiConverterOptionTypeAddress.lower(address),
        FfiConverterOptionTypeAmount.lower(amount),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRouteFactory: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RouteFactory

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RouteFactory {
        return RouteFactory(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RouteFactory) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteFactory {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RouteFactory, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRouteFactory_lift(_ pointer: UnsafeMutableRawPointer) throws -> RouteFactory {
    return try FfiConverterTypeRouteFactory.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRouteFactory_lower(_ value: RouteFactory) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRouteFactory.lower(value)
}




public protocol RustImportWalletManagerProtocol : AnyObject {
    
    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: ImportWalletManagerAction) 
    
    /**
     * Import wallet view from entered words
     */
    func importWallet(enteredWords: [[String]]) throws  -> WalletMetadata
    
    func listenForUpdates(reconciler: ImportWalletManagerReconciler) 
    
}

open class RustImportWalletManager:
    RustImportWalletManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_rustimportwalletmanager(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_rustimportwalletmanager_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustimportwalletmanager(pointer, $0) }
    }

    

    
    /**
     * Action from the frontend to change the state of the view model
     */
open func dispatch(action: ImportWalletManagerAction)  {try! rustCall() {
    uniffi_cove_fn_method_rustimportwalletmanager_dispatch(self.uniffiClonePointer(),
        FfiConverterTypeImportWalletManagerAction.lower(action),$0
    )
}
}
    
    /**
     * Import wallet view from entered words
     */
open func importWallet(enteredWords: [[String]])throws  -> WalletMetadata  {
    return try  FfiConverterTypeWalletMetadata.lift(try rustCallWithError(FfiConverterTypeImportWalletError.lift) {
    uniffi_cove_fn_method_rustimportwalletmanager_import_wallet(self.uniffiClonePointer(),
        FfiConverterSequenceSequenceString.lower(enteredWords),$0
    )
})
}
    
open func listenForUpdates(reconciler: ImportWalletManagerReconciler)  {try! rustCall() {
    uniffi_cove_fn_method_rustimportwalletmanager_listen_for_updates(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceImportWalletManagerReconciler.lower(reconciler),$0
    )
}
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRustImportWalletManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustImportWalletManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustImportWalletManager {
        return RustImportWalletManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustImportWalletManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustImportWalletManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustImportWalletManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustImportWalletManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> RustImportWalletManager {
    return try FfiConverterTypeRustImportWalletManager.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustImportWalletManager_lower(_ value: RustImportWalletManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRustImportWalletManager.lower(value)
}




public protocol RustPendingWalletManagerProtocol : AnyObject {
    
    func bip39Words()  -> [String]
    
    func bip39WordsGrouped()  -> [[GroupedWord]]
    
    func cardIndexes()  -> UInt8
    
    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: PendingWalletManagerAction) 
    
    func getState()  -> PendingWalletManagerState
    
    func listenForUpdates(reconciler: PendingWalletManagerReconciler) 
    
    func numberOfWordsCount()  -> UInt8
    
    func saveWallet() throws  -> WalletMetadata
    
}

open class RustPendingWalletManager:
    RustPendingWalletManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_rustpendingwalletmanager(self.pointer, $0) }
    }
public convenience init(numberOfWords: NumberOfBip39Words) {
    let pointer =
        try! rustCall() {
    uniffi_cove_fn_constructor_rustpendingwalletmanager_new(
        FfiConverterTypeNumberOfBip39Words.lower(numberOfWords),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustpendingwalletmanager(pointer, $0) }
    }

    

    
open func bip39Words() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_bip_39_words(self.uniffiClonePointer(),$0
    )
})
}
    
open func bip39WordsGrouped() -> [[GroupedWord]]  {
    return try!  FfiConverterSequenceSequenceTypeGroupedWord.lift(try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_bip_39_words_grouped(self.uniffiClonePointer(),$0
    )
})
}
    
open func cardIndexes() -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_card_indexes(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Action from the frontend to change the state of the view model
     */
open func dispatch(action: PendingWalletManagerAction)  {try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_dispatch(self.uniffiClonePointer(),
        FfiConverterTypePendingWalletManagerAction.lower(action),$0
    )
}
}
    
open func getState() -> PendingWalletManagerState  {
    return try!  FfiConverterTypePendingWalletManagerState.lift(try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_get_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func listenForUpdates(reconciler: PendingWalletManagerReconciler)  {try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_listen_for_updates(self.uniffiClonePointer(),
        FfiConverterCallbackInterfacePendingWalletManagerReconciler.lower(reconciler),$0
    )
}
}
    
open func numberOfWordsCount() -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_number_of_words_count(self.uniffiClonePointer(),$0
    )
})
}
    
open func saveWallet()throws  -> WalletMetadata  {
    return try  FfiConverterTypeWalletMetadata.lift(try rustCallWithError(FfiConverterTypePendingWalletManagerError.lift) {
    uniffi_cove_fn_method_rustpendingwalletmanager_save_wallet(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRustPendingWalletManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustPendingWalletManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustPendingWalletManager {
        return RustPendingWalletManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustPendingWalletManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustPendingWalletManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustPendingWalletManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustPendingWalletManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> RustPendingWalletManager {
    return try FfiConverterTypeRustPendingWalletManager.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustPendingWalletManager_lower(_ value: RustPendingWalletManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRustPendingWalletManager.lower(value)
}




public protocol RustWalletManagerProtocol : AnyObject {
    
    /**
     * Get address at the given index
     */
    func addressAt(index: UInt32) async throws  -> AddressInfo
    
    func amountInFiat(amount: Amount, currency: FiatCurrency) async throws  -> Double
    
    func balance() async  -> Balance
    
    func balanceInFiat() async throws  -> Double
    
    func buildTransaction(amount: Amount, address: Address) async throws  -> Psbt
    
    func buildTransactionWithFeeRate(amount: Amount, address: Address, feeRate: FeeRate) async throws  -> Psbt
    
    func currentBlockHeight() async throws  -> UInt32
    
    func deleteUnsignedTransaction(txId: TxId) throws 
    
    func deleteWallet() throws 
    
    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: WalletManagerAction) 
    
    func displayAmount(amount: Amount)  -> String
    
    func displayFiatAmount(amount: Double)  -> String
    
    func displaySentAndReceivedAmount(sentAndReceived: SentAndReceived)  -> String
    
    func feeRateOptions() async throws  -> FeeRateOptions
    
    func feeRateOptionsWithTotalFee(feeRateOptions: FeeRateOptions?, amount: Amount, address: Address) async throws  -> FeeRateOptionsWithTotalFee
    
    func fees()  -> FeeResponse?
    
    func fingerprint()  -> String
    
    func forceUpdateHeight() async throws  -> UInt32
    
    func forceWalletScan() async throws 
    
    func getConfirmDetails(amount: Amount, address: Address, feeRate: FeeRate) async throws  -> ConfirmDetails
    
    func getFeeOptions() async throws  -> FeeRateOptions
    
    func getMaxSendAmount(fee: FeeRateOptionWithTotalFee) async throws  -> Amount
    
    func getUnsignedTransactions() throws  -> [UnsignedTransaction]
    
    func listenForUpdates(reconciler: WalletManagerReconciler) 
    
    func markWalletAsVerified() throws 
    
    /**
     * Get the next address for the wallet
     */
    func nextAddress() async throws  -> AddressInfo
    
    func numberOfConfirmations(blockHeight: UInt32) async throws  -> UInt32
    
    func numberOfConfirmationsFmt(blockHeight: UInt32) async throws  -> String
    
    func saveUnsignedTransaction(details: ConfirmDetails) throws 
    
    func sentAndReceivedFiat(sentAndReceived: SentAndReceived) async throws  -> Double
    
    func setWalletMetadata(metadata: WalletMetadata) 
    
    func startWalletScan() async throws 
    
    func switchToDifferentWalletAddressType(walletAddressType: WalletAddressType) async throws 
    
    func transactionDetails(txId: TxId) async throws  -> TransactionDetails
    
    func validateMetadata() 
    
    func walletMetadata()  -> WalletMetadata
    
    func wordValidator() throws  -> WordValidator
    
}

open class RustWalletManager:
    RustWalletManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_rustwalletmanager(self.pointer, $0) }
    }
public convenience init(id: WalletId)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeWalletManagerError.lift) {
    uniffi_cove_fn_constructor_rustwalletmanager_new(
        FfiConverterTypeWalletId.lower(id),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustwalletmanager(pointer, $0) }
    }

    
public static func previewNewWallet() -> RustWalletManager  {
    return try!  FfiConverterTypeRustWalletManager.lift(try! rustCall() {
    uniffi_cove_fn_constructor_rustwalletmanager_preview_new_wallet($0
    )
})
}
    
public static func tryNewFromXpub(xpub: String)throws  -> RustWalletManager  {
    return try  FfiConverterTypeRustWalletManager.lift(try rustCallWithError(FfiConverterTypeWalletManagerError.lift) {
    uniffi_cove_fn_constructor_rustwalletmanager_try_new_from_xpub(
        FfiConverterString.lower(xpub),$0
    )
})
}
    

    
    /**
     * Get address at the given index
     */
open func addressAt(index: UInt32)async throws  -> AddressInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_address_at(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(index)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_pointer,
            completeFunc: ffi_cove_rust_future_complete_pointer,
            freeFunc: ffi_cove_rust_future_free_pointer,
            liftFunc: FfiConverterTypeAddressInfo.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func amountInFiat(amount: Amount, currency: FiatCurrency)async throws  -> Double  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_amount_in_fiat(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAmount.lower(amount),FfiConverterTypeFiatCurrency.lower(currency)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_f64,
            completeFunc: ffi_cove_rust_future_complete_f64,
            freeFunc: ffi_cove_rust_future_free_f64,
            liftFunc: FfiConverterDouble.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func balance()async  -> Balance  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_balance(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeBalance.lift,
            errorHandler: nil
            
        )
}
    
open func balanceInFiat()async throws  -> Double  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_balance_in_fiat(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_f64,
            completeFunc: ffi_cove_rust_future_complete_f64,
            freeFunc: ffi_cove_rust_future_free_f64,
            liftFunc: FfiConverterDouble.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func buildTransaction(amount: Amount, address: Address)async throws  -> Psbt  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_build_transaction(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAmount.lower(amount),FfiConverterTypeAddress.lower(address)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_pointer,
            completeFunc: ffi_cove_rust_future_complete_pointer,
            freeFunc: ffi_cove_rust_future_free_pointer,
            liftFunc: FfiConverterTypePsbt.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func buildTransactionWithFeeRate(amount: Amount, address: Address, feeRate: FeeRate)async throws  -> Psbt  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_build_transaction_with_fee_rate(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAmount.lower(amount),FfiConverterTypeAddress.lower(address),FfiConverterTypeFeeRate.lower(feeRate)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_pointer,
            completeFunc: ffi_cove_rust_future_complete_pointer,
            freeFunc: ffi_cove_rust_future_free_pointer,
            liftFunc: FfiConverterTypePsbt.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func currentBlockHeight()async throws  -> UInt32  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_current_block_height(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u32,
            completeFunc: ffi_cove_rust_future_complete_u32,
            freeFunc: ffi_cove_rust_future_free_u32,
            liftFunc: FfiConverterUInt32.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func deleteUnsignedTransaction(txId: TxId)throws   {try rustCallWithError(FfiConverterTypeWalletManagerError.lift) {
    uniffi_cove_fn_method_rustwalletmanager_delete_unsigned_transaction(self.uniffiClonePointer(),
        FfiConverterTypeTxId.lower(txId),$0
    )
}
}
    
open func deleteWallet()throws   {try rustCallWithError(FfiConverterTypeWalletManagerError.lift) {
    uniffi_cove_fn_method_rustwalletmanager_delete_wallet(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Action from the frontend to change the state of the view model
     */
open func dispatch(action: WalletManagerAction)  {try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_dispatch(self.uniffiClonePointer(),
        FfiConverterTypeWalletManagerAction.lower(action),$0
    )
}
}
    
open func displayAmount(amount: Amount) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_display_amount(self.uniffiClonePointer(),
        FfiConverterTypeAmount.lower(amount),$0
    )
})
}
    
open func displayFiatAmount(amount: Double) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_display_fiat_amount(self.uniffiClonePointer(),
        FfiConverterDouble.lower(amount),$0
    )
})
}
    
open func displaySentAndReceivedAmount(sentAndReceived: SentAndReceived) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_display_sent_and_received_amount(self.uniffiClonePointer(),
        FfiConverterTypeSentAndReceived.lower(sentAndReceived),$0
    )
})
}
    
open func feeRateOptions()async throws  -> FeeRateOptions  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_fee_rate_options(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_pointer,
            completeFunc: ffi_cove_rust_future_complete_pointer,
            freeFunc: ffi_cove_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFeeRateOptions.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func feeRateOptionsWithTotalFee(feeRateOptions: FeeRateOptions?, amount: Amount, address: Address)async throws  -> FeeRateOptionsWithTotalFee  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_fee_rate_options_with_total_fee(
                    self.uniffiClonePointer(),
                    FfiConverterOptionTypeFeeRateOptions.lower(feeRateOptions),FfiConverterTypeAmount.lower(amount),FfiConverterTypeAddress.lower(address)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_pointer,
            completeFunc: ffi_cove_rust_future_complete_pointer,
            freeFunc: ffi_cove_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFeeRateOptionsWithTotalFee.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func fees() -> FeeResponse?  {
    return try!  FfiConverterOptionTypeFeeResponse.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_fees(self.uniffiClonePointer(),$0
    )
})
}
    
open func fingerprint() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_fingerprint(self.uniffiClonePointer(),$0
    )
})
}
    
open func forceUpdateHeight()async throws  -> UInt32  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_force_update_height(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u32,
            completeFunc: ffi_cove_rust_future_complete_u32,
            freeFunc: ffi_cove_rust_future_free_u32,
            liftFunc: FfiConverterUInt32.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func forceWalletScan()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_force_wallet_scan(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func getConfirmDetails(amount: Amount, address: Address, feeRate: FeeRate)async throws  -> ConfirmDetails  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_get_confirm_details(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAmount.lower(amount),FfiConverterTypeAddress.lower(address),FfiConverterTypeFeeRate.lower(feeRate)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_pointer,
            completeFunc: ffi_cove_rust_future_complete_pointer,
            freeFunc: ffi_cove_rust_future_free_pointer,
            liftFunc: FfiConverterTypeConfirmDetails.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func getFeeOptions()async throws  -> FeeRateOptions  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_get_fee_options(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_pointer,
            completeFunc: ffi_cove_rust_future_complete_pointer,
            freeFunc: ffi_cove_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFeeRateOptions.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func getMaxSendAmount(fee: FeeRateOptionWithTotalFee)async throws  -> Amount  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_get_max_send_amount(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFeeRateOptionWithTotalFee.lower(fee)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_pointer,
            completeFunc: ffi_cove_rust_future_complete_pointer,
            freeFunc: ffi_cove_rust_future_free_pointer,
            liftFunc: FfiConverterTypeAmount.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func getUnsignedTransactions()throws  -> [UnsignedTransaction]  {
    return try  FfiConverterSequenceTypeUnsignedTransaction.lift(try rustCallWithError(FfiConverterTypeWalletManagerError.lift) {
    uniffi_cove_fn_method_rustwalletmanager_get_unsigned_transactions(self.uniffiClonePointer(),$0
    )
})
}
    
open func listenForUpdates(reconciler: WalletManagerReconciler)  {try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_listen_for_updates(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceWalletManagerReconciler.lower(reconciler),$0
    )
}
}
    
open func markWalletAsVerified()throws   {try rustCallWithError(FfiConverterTypeWalletManagerError.lift) {
    uniffi_cove_fn_method_rustwalletmanager_mark_wallet_as_verified(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Get the next address for the wallet
     */
open func nextAddress()async throws  -> AddressInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_next_address(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_pointer,
            completeFunc: ffi_cove_rust_future_complete_pointer,
            freeFunc: ffi_cove_rust_future_free_pointer,
            liftFunc: FfiConverterTypeAddressInfo.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func numberOfConfirmations(blockHeight: UInt32)async throws  -> UInt32  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_number_of_confirmations(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(blockHeight)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u32,
            completeFunc: ffi_cove_rust_future_complete_u32,
            freeFunc: ffi_cove_rust_future_free_u32,
            liftFunc: FfiConverterUInt32.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func numberOfConfirmationsFmt(blockHeight: UInt32)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_number_of_confirmations_fmt(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(blockHeight)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func saveUnsignedTransaction(details: ConfirmDetails)throws   {try rustCallWithError(FfiConverterTypeWalletManagerError.lift) {
    uniffi_cove_fn_method_rustwalletmanager_save_unsigned_transaction(self.uniffiClonePointer(),
        FfiConverterTypeConfirmDetails.lower(details),$0
    )
}
}
    
open func sentAndReceivedFiat(sentAndReceived: SentAndReceived)async throws  -> Double  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_sent_and_received_fiat(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSentAndReceived.lower(sentAndReceived)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_f64,
            completeFunc: ffi_cove_rust_future_complete_f64,
            freeFunc: ffi_cove_rust_future_free_f64,
            liftFunc: FfiConverterDouble.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func setWalletMetadata(metadata: WalletMetadata)  {try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_set_wallet_metadata(self.uniffiClonePointer(),
        FfiConverterTypeWalletMetadata.lower(metadata),$0
    )
}
}
    
open func startWalletScan()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_start_wallet_scan(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func switchToDifferentWalletAddressType(walletAddressType: WalletAddressType)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_switch_to_different_wallet_address_type(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWalletAddressType.lower(walletAddressType)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func transactionDetails(txId: TxId)async throws  -> TransactionDetails  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_transaction_details(
                    self.uniffiClonePointer(),
                    FfiConverterTypeTxId.lower(txId)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_pointer,
            completeFunc: ffi_cove_rust_future_complete_pointer,
            freeFunc: ffi_cove_rust_future_free_pointer,
            liftFunc: FfiConverterTypeTransactionDetails.lift,
            errorHandler: FfiConverterTypeWalletManagerError.lift
        )
}
    
open func validateMetadata()  {try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_validate_metadata(self.uniffiClonePointer(),$0
    )
}
}
    
open func walletMetadata() -> WalletMetadata  {
    return try!  FfiConverterTypeWalletMetadata.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_wallet_metadata(self.uniffiClonePointer(),$0
    )
})
}
    
open func wordValidator()throws  -> WordValidator  {
    return try  FfiConverterTypeWordValidator.lift(try rustCallWithError(FfiConverterTypeWalletManagerError.lift) {
    uniffi_cove_fn_method_rustwalletmanager_word_validator(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRustWalletManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustWalletManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustWalletManager {
        return RustWalletManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustWalletManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustWalletManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustWalletManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustWalletManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> RustWalletManager {
    return try FfiConverterTypeRustWalletManager.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustWalletManager_lower(_ value: RustWalletManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRustWalletManager.lower(value)
}




public protocol SeedQrProtocol : AnyObject {
    
    func getWords()  -> [String]
    
    func groupedPlainWords()  -> [[String]]
    
}

open class SeedQr:
    SeedQrProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_seedqr(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_seedqr(pointer, $0) }
    }

    
public static func newFromData(data: Data)throws  -> SeedQr  {
    return try  FfiConverterTypeSeedQr.lift(try rustCallWithError(FfiConverterTypeSeedQrError.lift) {
    uniffi_cove_fn_constructor_seedqr_new_from_data(
        FfiConverterData.lower(data),$0
    )
})
}
    
public static func newFromStr(qr: String)throws  -> SeedQr  {
    return try  FfiConverterTypeSeedQr.lift(try rustCallWithError(FfiConverterTypeSeedQrError.lift) {
    uniffi_cove_fn_constructor_seedqr_new_from_str(
        FfiConverterString.lower(qr),$0
    )
})
}
    

    
open func getWords() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_seedqr_get_words(self.uniffiClonePointer(),$0
    )
})
}
    
open func groupedPlainWords() -> [[String]]  {
    return try!  FfiConverterSequenceSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_seedqr_grouped_plain_words(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSeedQr: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SeedQr

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SeedQr {
        return SeedQr(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SeedQr) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SeedQr {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SeedQr, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeedQr_lift(_ pointer: UnsafeMutableRawPointer) throws -> SeedQr {
    return try FfiConverterTypeSeedQr.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeedQr_lower(_ value: SeedQr) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSeedQr.lower(value)
}




public protocol SentAndReceivedProtocol : AnyObject {
    
    func amount()  -> Amount
    
    func amountFmt(unit: Unit)  -> String
    
    func direction()  -> TransactionDirection
    
    func label()  -> String
    
    func received()  -> Amount
    
    func sent()  -> Amount
    
}

open class SentAndReceived:
    SentAndReceivedProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_sentandreceived(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_sentandreceived(pointer, $0) }
    }

    

    
open func amount() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_sentandreceived_amount(self.uniffiClonePointer(),$0
    )
})
}
    
open func amountFmt(unit: Unit) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_sentandreceived_amount_fmt(self.uniffiClonePointer(),
        FfiConverterTypeUnit.lower(unit),$0
    )
})
}
    
open func direction() -> TransactionDirection  {
    return try!  FfiConverterTypeTransactionDirection.lift(try! rustCall() {
    uniffi_cove_fn_method_sentandreceived_direction(self.uniffiClonePointer(),$0
    )
})
}
    
open func label() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_sentandreceived_label(self.uniffiClonePointer(),$0
    )
})
}
    
open func received() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_sentandreceived_received(self.uniffiClonePointer(),$0
    )
})
}
    
open func sent() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_sentandreceived_sent(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSentAndReceived: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SentAndReceived

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SentAndReceived {
        return SentAndReceived(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SentAndReceived) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SentAndReceived {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SentAndReceived, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSentAndReceived_lift(_ pointer: UnsafeMutableRawPointer) throws -> SentAndReceived {
    return try FfiConverterTypeSentAndReceived.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSentAndReceived_lower(_ value: SentAndReceived) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSentAndReceived.lower(value)
}




public protocol TransactionDetailsProtocol : AnyObject {
    
    func address()  -> Address
    
    func addressSpacedOut()  -> String
    
    func amount()  -> Amount
    
    func amountFiat() async throws  -> Double
    
    func amountFiatFmt() async throws  -> String
    
    func amountFmt(unit: Unit)  -> String
    
    func blockNumber()  -> UInt32?
    
    func blockNumberFmt()  -> String?
    
    func confirmationDateTime()  -> String?
    
    func feeFiatFmt() async throws  -> String
    
    func feeFmt(unit: Unit)  -> String?
    
    func isConfirmed()  -> Bool
    
    func isReceived()  -> Bool
    
    func isSent()  -> Bool
    
    func sentSansFeeFiatFmt() async throws  -> String
    
    func sentSansFeeFmt(unit: Unit)  -> String?
    
    func transactionUrl()  -> String
    
}

open class TransactionDetails:
    TransactionDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_transactiondetails(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_transactiondetails(pointer, $0) }
    }

    
public static func previewConfirmedReceived() -> TransactionDetails  {
    return try!  FfiConverterTypeTransactionDetails.lift(try! rustCall() {
    uniffi_cove_fn_constructor_transactiondetails_preview_confirmed_received($0
    )
})
}
    
public static func previewConfirmedSent() -> TransactionDetails  {
    return try!  FfiConverterTypeTransactionDetails.lift(try! rustCall() {
    uniffi_cove_fn_constructor_transactiondetails_preview_confirmed_sent($0
    )
})
}
    
public static func previewNewConfirmed() -> TransactionDetails  {
    return try!  FfiConverterTypeTransactionDetails.lift(try! rustCall() {
    uniffi_cove_fn_constructor_transactiondetails_preview_new_confirmed($0
    )
})
}
    
public static func previewPendingReceived() -> TransactionDetails  {
    return try!  FfiConverterTypeTransactionDetails.lift(try! rustCall() {
    uniffi_cove_fn_constructor_transactiondetails_preview_pending_received($0
    )
})
}
    
public static func previewPendingSent() -> TransactionDetails  {
    return try!  FfiConverterTypeTransactionDetails.lift(try! rustCall() {
    uniffi_cove_fn_constructor_transactiondetails_preview_pending_sent($0
    )
})
}
    

    
open func address() -> Address  {
    return try!  FfiConverterTypeAddress.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_address(self.uniffiClonePointer(),$0
    )
})
}
    
open func addressSpacedOut() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_address_spaced_out(self.uniffiClonePointer(),$0
    )
})
}
    
open func amount() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_amount(self.uniffiClonePointer(),$0
    )
})
}
    
open func amountFiat()async throws  -> Double  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_transactiondetails_amount_fiat(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_f64,
            completeFunc: ffi_cove_rust_future_complete_f64,
            freeFunc: ffi_cove_rust_future_free_f64,
            liftFunc: FfiConverterDouble.lift,
            errorHandler: FfiConverterTypeTransactionDetailError.lift
        )
}
    
open func amountFiatFmt()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_transactiondetails_amount_fiat_fmt(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeTransactionDetailError.lift
        )
}
    
open func amountFmt(unit: Unit) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_amount_fmt(self.uniffiClonePointer(),
        FfiConverterTypeUnit.lower(unit),$0
    )
})
}
    
open func blockNumber() -> UInt32?  {
    return try!  FfiConverterOptionUInt32.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_block_number(self.uniffiClonePointer(),$0
    )
})
}
    
open func blockNumberFmt() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_block_number_fmt(self.uniffiClonePointer(),$0
    )
})
}
    
open func confirmationDateTime() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_confirmation_date_time(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeFiatFmt()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_transactiondetails_fee_fiat_fmt(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeTransactionDetailError.lift
        )
}
    
open func feeFmt(unit: Unit) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_fee_fmt(self.uniffiClonePointer(),
        FfiConverterTypeUnit.lower(unit),$0
    )
})
}
    
open func isConfirmed() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_is_confirmed(self.uniffiClonePointer(),$0
    )
})
}
    
open func isReceived() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_is_received(self.uniffiClonePointer(),$0
    )
})
}
    
open func isSent() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_is_sent(self.uniffiClonePointer(),$0
    )
})
}
    
open func sentSansFeeFiatFmt()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_transactiondetails_sent_sans_fee_fiat_fmt(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeTransactionDetailError.lift
        )
}
    
open func sentSansFeeFmt(unit: Unit) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_sent_sans_fee_fmt(self.uniffiClonePointer(),
        FfiConverterTypeUnit.lower(unit),$0
    )
})
}
    
open func transactionUrl() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_transaction_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransactionDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionDetails {
        return TransactionDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransactionDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransactionDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransactionDetails {
    return try FfiConverterTypeTransactionDetails.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDetails_lower(_ value: TransactionDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransactionDetails.lower(value)
}




public protocol TxIdProtocol : AnyObject {
    
    func asHashString()  -> String
    
    func isEqual(other: TxId)  -> Bool
    
}

open class TxId:
    TxIdProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_txid(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_txid(pointer, $0) }
    }

    

    
open func asHashString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_txid_as_hash_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func isEqual(other: TxId) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_txid_is_equal(self.uniffiClonePointer(),
        FfiConverterTypeTxId.lower(other),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxId: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxId

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxId {
        return TxId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxId) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxId_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxId {
    return try FfiConverterTypeTxId.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxId_lower(_ value: TxId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxId.lower(value)
}




public protocol TxInProtocol : AnyObject {
    
}

open class TxIn:
    TxInProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_txin(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_txin(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxIn: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxIn

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxIn {
        return TxIn(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxIn) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxIn {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxIn, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxIn_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxIn {
    return try FfiConverterTypeTxIn.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxIn_lower(_ value: TxIn) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxIn.lower(value)
}




public protocol TxOutProtocol : AnyObject {
    
}

open class TxOut:
    TxOutProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_txout(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_txout(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxOut: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxOut

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxOut {
        return TxOut(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxOut) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxOut {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxOut, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOut_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxOut {
    return try FfiConverterTypeTxOut.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOut_lower(_ value: TxOut) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxOut.lower(value)
}




public protocol UnconfirmedTransactionProtocol : AnyObject {
    
    func fiatAmount()  -> FiatAmount?
    
    func id()  -> TxId
    
    func label()  -> String
    
    func lastSeen()  -> UInt64
    
    func sentAndReceived()  -> SentAndReceived
    
}

open class UnconfirmedTransaction:
    UnconfirmedTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_unconfirmedtransaction(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_unconfirmedtransaction(pointer, $0) }
    }

    

    
open func fiatAmount() -> FiatAmount?  {
    return try!  FfiConverterOptionTypeFiatAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_unconfirmedtransaction_fiat_amount(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> TxId  {
    return try!  FfiConverterTypeTxId.lift(try! rustCall() {
    uniffi_cove_fn_method_unconfirmedtransaction_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func label() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_unconfirmedtransaction_label(self.uniffiClonePointer(),$0
    )
})
}
    
open func lastSeen() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_unconfirmedtransaction_last_seen(self.uniffiClonePointer(),$0
    )
})
}
    
open func sentAndReceived() -> SentAndReceived  {
    return try!  FfiConverterTypeSentAndReceived.lift(try! rustCall() {
    uniffi_cove_fn_method_unconfirmedtransaction_sent_and_received(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnconfirmedTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnconfirmedTransaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnconfirmedTransaction {
        return UnconfirmedTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnconfirmedTransaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnconfirmedTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnconfirmedTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnconfirmedTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnconfirmedTransaction {
    return try FfiConverterTypeUnconfirmedTransaction.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnconfirmedTransaction_lower(_ value: UnconfirmedTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnconfirmedTransaction.lower(value)
}




public protocol UnsignedTransactionProtocol : AnyObject {
    
    func details()  -> ConfirmDetails
    
    func id()  -> TxId
    
    func label()  -> String
    
    func sendingAmount()  -> Amount
    
    func spendingAmount()  -> Amount
    
}

open class UnsignedTransaction:
    UnsignedTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_unsignedtransaction(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_unsignedtransaction(pointer, $0) }
    }

    
public static func previewNew() -> UnsignedTransaction  {
    return try!  FfiConverterTypeUnsignedTransaction.lift(try! rustCall() {
    uniffi_cove_fn_constructor_unsignedtransaction_preview_new($0
    )
})
}
    

    
open func details() -> ConfirmDetails  {
    return try!  FfiConverterTypeConfirmDetails.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransaction_details(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> TxId  {
    return try!  FfiConverterTypeTxId.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransaction_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func label() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransaction_label(self.uniffiClonePointer(),$0
    )
})
}
    
open func sendingAmount() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransaction_sending_amount(self.uniffiClonePointer(),$0
    )
})
}
    
open func spendingAmount() -> Amount  {
    return try!  FfiConverterTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransaction_spending_amount(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsignedTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnsignedTransaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedTransaction {
        return UnsignedTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnsignedTransaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnsignedTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedTransaction {
    return try FfiConverterTypeUnsignedTransaction.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransaction_lower(_ value: UnsignedTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnsignedTransaction.lower(value)
}




public protocol UnsignedTransactionRecordProtocol : AnyObject {
    
    func confirmDetails()  -> ConfirmDetails
    
    func createdAt()  -> UInt64
    
    func txId()  -> TxId
    
    func walletId()  -> WalletId
    
}

open class UnsignedTransactionRecord:
    UnsignedTransactionRecordProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_unsignedtransactionrecord(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_unsignedtransactionrecord(pointer, $0) }
    }

    

    
open func confirmDetails() -> ConfirmDetails  {
    return try!  FfiConverterTypeConfirmDetails.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransactionrecord_confirm_details(self.uniffiClonePointer(),$0
    )
})
}
    
open func createdAt() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransactionrecord_created_at(self.uniffiClonePointer(),$0
    )
})
}
    
open func txId() -> TxId  {
    return try!  FfiConverterTypeTxId.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransactionrecord_tx_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func walletId() -> WalletId  {
    return try!  FfiConverterTypeWalletId.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransactionrecord_wallet_id(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsignedTransactionRecord: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnsignedTransactionRecord

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedTransactionRecord {
        return UnsignedTransactionRecord(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnsignedTransactionRecord) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedTransactionRecord {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnsignedTransactionRecord, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransactionRecord_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedTransactionRecord {
    return try FfiConverterTypeUnsignedTransactionRecord.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransactionRecord_lower(_ value: UnsignedTransactionRecord) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnsignedTransactionRecord.lower(value)
}




public protocol UnsignedTransactionsTableProtocol : AnyObject {
    
    func getTx(txId: TxId)  -> UnsignedTransactionRecord?
    
    func getTxThrow(txId: TxId) throws  -> UnsignedTransactionRecord
    
}

open class UnsignedTransactionsTable:
    UnsignedTransactionsTableProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_unsignedtransactionstable(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_unsignedtransactionstable(pointer, $0) }
    }

    

    
open func getTx(txId: TxId) -> UnsignedTransactionRecord?  {
    return try!  FfiConverterOptionTypeUnsignedTransactionRecord.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransactionstable_gettx(self.uniffiClonePointer(),
        FfiConverterTypeTxId.lower(txId),$0
    )
})
}
    
open func getTxThrow(txId: TxId)throws  -> UnsignedTransactionRecord  {
    return try  FfiConverterTypeUnsignedTransactionRecord.lift(try rustCallWithError(FfiConverterTypeUnsignedTransactionsTableError.lift) {
    uniffi_cove_fn_method_unsignedtransactionstable_gettxthrow(self.uniffiClonePointer(),
        FfiConverterTypeTxId.lower(txId),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsignedTransactionsTable: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnsignedTransactionsTable

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedTransactionsTable {
        return UnsignedTransactionsTable(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnsignedTransactionsTable) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedTransactionsTable {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnsignedTransactionsTable, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransactionsTable_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedTransactionsTable {
    return try FfiConverterTypeUnsignedTransactionsTable.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransactionsTable_lower(_ value: UnsignedTransactionsTable) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnsignedTransactionsTable.lower(value)
}




public protocol WalletProtocol : AnyObject {
    
    func id()  -> WalletId
    
}

open class Wallet:
    WalletProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_wallet(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_wallet(pointer, $0) }
    }

    
public static func newFromExport(export: HardwareExport)throws  -> Wallet  {
    return try  FfiConverterTypeWallet.lift(try rustCallWithError(FfiConverterTypeWalletError.lift) {
    uniffi_cove_fn_constructor_wallet_new_from_export(
        FfiConverterTypeHardwareExport.lower(export),$0
    )
})
}
    
public static func newFromXpub(xpub: String)throws  -> Wallet  {
    return try  FfiConverterTypeWallet.lift(try rustCallWithError(FfiConverterTypeWalletError.lift) {
    uniffi_cove_fn_constructor_wallet_new_from_xpub(
        FfiConverterString.lower(xpub),$0
    )
})
}
    
public static func previewNewWallet() -> Wallet  {
    return try!  FfiConverterTypeWallet.lift(try! rustCall() {
    uniffi_cove_fn_constructor_wallet_previewnewwallet($0
    )
})
}
    

    
open func id() -> WalletId  {
    return try!  FfiConverterTypeWalletId.lift(try! rustCall() {
    uniffi_cove_fn_method_wallet_id(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWallet: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Wallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
    return try FfiConverterTypeWallet.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWallet_lower(_ value: Wallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWallet.lower(value)
}




public protocol WalletDataDbProtocol : AnyObject {
    
}

open class WalletDataDb:
    WalletDataDbProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_walletdatadb(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_walletdatadb(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletDataDb: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WalletDataDb

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletDataDb {
        return WalletDataDb(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WalletDataDb) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletDataDb {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WalletDataDb, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletDataDb_lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletDataDb {
    return try FfiConverterTypeWalletDataDb.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletDataDb_lower(_ value: WalletDataDb) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWalletDataDb.lower(value)
}




public protocol WalletKeyProtocol : AnyObject {
    
}

open class WalletKey:
    WalletKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_walletkey(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_walletkey(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WalletKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletKey {
        return WalletKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WalletKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WalletKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletKey {
    return try FfiConverterTypeWalletKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletKey_lower(_ value: WalletKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWalletKey.lower(value)
}




public protocol WalletsTableProtocol : AnyObject {
    
    func all() throws  -> [WalletMetadata]
    
    func isEmpty() throws  -> Bool
    
    func len(network: Network) throws  -> UInt16
    
}

open class WalletsTable:
    WalletsTableProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_walletstable(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_walletstable(pointer, $0) }
    }

    

    
open func all()throws  -> [WalletMetadata]  {
    return try  FfiConverterSequenceTypeWalletMetadata.lift(try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_walletstable_all(self.uniffiClonePointer(),$0
    )
})
}
    
open func isEmpty()throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_walletstable_is_empty(self.uniffiClonePointer(),$0
    )
})
}
    
open func len(network: Network)throws  -> UInt16  {
    return try  FfiConverterUInt16.lift(try rustCallWithError(FfiConverterTypeDatabaseError.lift) {
    uniffi_cove_fn_method_walletstable_len(self.uniffiClonePointer(),
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletsTable: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WalletsTable

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletsTable {
        return WalletsTable(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WalletsTable) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletsTable {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WalletsTable, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletsTable_lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletsTable {
    return try FfiConverterTypeWalletsTable.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletsTable_lower(_ value: WalletsTable) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWalletsTable.lower(value)
}




public protocol WordValidatorProtocol : AnyObject {
    
    func isComplete(wordNumber: UInt8)  -> Bool
    
    func isWordCorrect(word: String, `for`: UInt8)  -> Bool
    
    func possibleWords(`for`: UInt8)  -> [String]
    
}

open class WordValidator:
    WordValidatorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_fn_clone_wordvalidator(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_fn_free_wordvalidator(pointer, $0) }
    }

    
public static func preview(preview: Bool, numberOfWords: NumberOfBip39Words? = nil) -> WordValidator  {
    return try!  FfiConverterTypeWordValidator.lift(try! rustCall() {
    uniffi_cove_fn_constructor_wordvalidator_preview(
        FfiConverterBool.lower(preview),
        FfiConverterOptionTypeNumberOfBip39Words.lower(numberOfWords),$0
    )
})
}
    

    
open func isComplete(wordNumber: UInt8) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_wordvalidator_is_complete(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(wordNumber),$0
    )
})
}
    
open func isWordCorrect(word: String, `for`: UInt8) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_wordvalidator_is_word_correct(self.uniffiClonePointer(),
        FfiConverterString.lower(word),
        FfiConverterUInt8.lower(`for`),$0
    )
})
}
    
open func possibleWords(`for`: UInt8) -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_wordvalidator_possible_words(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(`for`),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWordValidator: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WordValidator

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WordValidator {
        return WordValidator(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WordValidator) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WordValidator {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WordValidator, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordValidator_lift(_ pointer: UnsafeMutableRawPointer) throws -> WordValidator {
    return try FfiConverterTypeWordValidator.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordValidator_lower(_ value: WordValidator) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWordValidator.lower(value)
}


public struct AddressIndex {
    public var lastSeenIndex: UInt8
    public var addressListHash: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastSeenIndex: UInt8, addressListHash: UInt64) {
        self.lastSeenIndex = lastSeenIndex
        self.addressListHash = addressListHash
    }
}



extension AddressIndex: Equatable, Hashable {
    public static func ==(lhs: AddressIndex, rhs: AddressIndex) -> Bool {
        if lhs.lastSeenIndex != rhs.lastSeenIndex {
            return false
        }
        if lhs.addressListHash != rhs.addressListHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastSeenIndex)
        hasher.combine(addressListHash)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressIndex: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressIndex {
        return
            try AddressIndex(
                lastSeenIndex: FfiConverterUInt8.read(from: &buf), 
                addressListHash: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AddressIndex, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.lastSeenIndex, into: &buf)
        FfiConverterUInt64.write(value.addressListHash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressIndex_lift(_ buf: RustBuffer) throws -> AddressIndex {
    return try FfiConverterTypeAddressIndex.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressIndex_lower(_ value: AddressIndex) -> RustBuffer {
    return FfiConverterTypeAddressIndex.lower(value)
}


public struct AppState {
    public var router: Router

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(router: Router) {
        self.router = router
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppState {
        return
            try AppState(
                router: FfiConverterTypeRouter.read(from: &buf)
        )
    }

    public static func write(_ value: AppState, into buf: inout [UInt8]) {
        FfiConverterTypeRouter.write(value.router, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppState_lift(_ buf: RustBuffer) throws -> AppState {
    return try FfiConverterTypeAppState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppState_lower(_ value: AppState) -> RustBuffer {
    return FfiConverterTypeAppState.lower(value)
}


public struct Balance {
    public var immature: Amount
    public var trustedPending: Amount
    public var untrustedPending: Amount
    public var confirmed: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(immature: Amount, trustedPending: Amount, untrustedPending: Amount, confirmed: Amount) {
        self.immature = immature
        self.trustedPending = trustedPending
        self.untrustedPending = untrustedPending
        self.confirmed = confirmed
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Balance {
        return
            try Balance(
                immature: FfiConverterTypeAmount.read(from: &buf), 
                trustedPending: FfiConverterTypeAmount.read(from: &buf), 
                untrustedPending: FfiConverterTypeAmount.read(from: &buf), 
                confirmed: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: Balance, into buf: inout [UInt8]) {
        FfiConverterTypeAmount.write(value.immature, into: &buf)
        FfiConverterTypeAmount.write(value.trustedPending, into: &buf)
        FfiConverterTypeAmount.write(value.untrustedPending, into: &buf)
        FfiConverterTypeAmount.write(value.confirmed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBalance_lift(_ buf: RustBuffer) throws -> Balance {
    return try FfiConverterTypeBalance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBalance_lower(_ value: Balance) -> RustBuffer {
    return FfiConverterTypeBalance.lower(value)
}


public struct BlockSizeLast {
    public var blockHeight: UInt64
    public var lastSeen: TimeInterval

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blockHeight: UInt64, lastSeen: TimeInterval) {
        self.blockHeight = blockHeight
        self.lastSeen = lastSeen
    }
}



extension BlockSizeLast: Equatable, Hashable {
    public static func ==(lhs: BlockSizeLast, rhs: BlockSizeLast) -> Bool {
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.lastSeen != rhs.lastSeen {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blockHeight)
        hasher.combine(lastSeen)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlockSizeLast: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockSizeLast {
        return
            try BlockSizeLast(
                blockHeight: FfiConverterUInt64.read(from: &buf), 
                lastSeen: FfiConverterDuration.read(from: &buf)
        )
    }

    public static func write(_ value: BlockSizeLast, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.blockHeight, into: &buf)
        FfiConverterDuration.write(value.lastSeen, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockSizeLast_lift(_ buf: RustBuffer) throws -> BlockSizeLast {
    return try FfiConverterTypeBlockSizeLast.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockSizeLast_lower(_ value: BlockSizeLast) -> RustBuffer {
    return FfiConverterTypeBlockSizeLast.lower(value)
}


public struct ConfirmedDetails {
    public var blockNumber: UInt32
    public var confirmationTime: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blockNumber: UInt32, confirmationTime: UInt64) {
        self.blockNumber = blockNumber
        self.confirmationTime = confirmationTime
    }
}



extension ConfirmedDetails: Equatable, Hashable {
    public static func ==(lhs: ConfirmedDetails, rhs: ConfirmedDetails) -> Bool {
        if lhs.blockNumber != rhs.blockNumber {
            return false
        }
        if lhs.confirmationTime != rhs.confirmationTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blockNumber)
        hasher.combine(confirmationTime)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmedDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmedDetails {
        return
            try ConfirmedDetails(
                blockNumber: FfiConverterUInt32.read(from: &buf), 
                confirmationTime: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ConfirmedDetails, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.blockNumber, into: &buf)
        FfiConverterUInt64.write(value.confirmationTime, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmedDetails_lift(_ buf: RustBuffer) throws -> ConfirmedDetails {
    return try FfiConverterTypeConfirmedDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmedDetails_lower(_ value: ConfirmedDetails) -> RustBuffer {
    return FfiConverterTypeConfirmedDetails.lower(value)
}


public struct FeeResponse {
    public var fastestFee: UInt64
    public var halfHourFee: UInt64
    public var hourFee: UInt64
    public var economyFee: UInt64
    public var minimumFee: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fastestFee: UInt64, halfHourFee: UInt64, hourFee: UInt64, economyFee: UInt64, minimumFee: UInt64) {
        self.fastestFee = fastestFee
        self.halfHourFee = halfHourFee
        self.hourFee = hourFee
        self.economyFee = economyFee
        self.minimumFee = minimumFee
    }
}



extension FeeResponse: Equatable, Hashable {
    public static func ==(lhs: FeeResponse, rhs: FeeResponse) -> Bool {
        if lhs.fastestFee != rhs.fastestFee {
            return false
        }
        if lhs.halfHourFee != rhs.halfHourFee {
            return false
        }
        if lhs.hourFee != rhs.hourFee {
            return false
        }
        if lhs.economyFee != rhs.economyFee {
            return false
        }
        if lhs.minimumFee != rhs.minimumFee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fastestFee)
        hasher.combine(halfHourFee)
        hasher.combine(hourFee)
        hasher.combine(economyFee)
        hasher.combine(minimumFee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeResponse {
        return
            try FeeResponse(
                fastestFee: FfiConverterUInt64.read(from: &buf), 
                halfHourFee: FfiConverterUInt64.read(from: &buf), 
                hourFee: FfiConverterUInt64.read(from: &buf), 
                economyFee: FfiConverterUInt64.read(from: &buf), 
                minimumFee: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FeeResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.fastestFee, into: &buf)
        FfiConverterUInt64.write(value.halfHourFee, into: &buf)
        FfiConverterUInt64.write(value.hourFee, into: &buf)
        FfiConverterUInt64.write(value.economyFee, into: &buf)
        FfiConverterUInt64.write(value.minimumFee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeResponse_lift(_ buf: RustBuffer) throws -> FeeResponse {
    return try FfiConverterTypeFeeResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeResponse_lower(_ value: FeeResponse) -> RustBuffer {
    return FfiConverterTypeFeeResponse.lower(value)
}


public struct FiatAmount {
    public var amount: Double
    public var currency: FiatCurrency

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Double, currency: FiatCurrency) {
        self.amount = amount
        self.currency = currency
    }
}



extension FiatAmount: Equatable, Hashable {
    public static func ==(lhs: FiatAmount, rhs: FiatAmount) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(currency)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatAmount {
        return
            try FiatAmount(
                amount: FfiConverterDouble.read(from: &buf), 
                currency: FfiConverterTypeFiatCurrency.read(from: &buf)
        )
    }

    public static func write(_ value: FiatAmount, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.amount, into: &buf)
        FfiConverterTypeFiatCurrency.write(value.currency, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatAmount_lift(_ buf: RustBuffer) throws -> FiatAmount {
    return try FfiConverterTypeFiatAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatAmount_lower(_ value: FiatAmount) -> RustBuffer {
    return FfiConverterTypeFiatAmount.lower(value)
}


public struct FoundAddress {
    public var type: WalletAddressType
    public var firstAddress: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: WalletAddressType, firstAddress: String) {
        self.type = type
        self.firstAddress = firstAddress
    }
}



extension FoundAddress: Equatable, Hashable {
    public static func ==(lhs: FoundAddress, rhs: FoundAddress) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.firstAddress != rhs.firstAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(firstAddress)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFoundAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FoundAddress {
        return
            try FoundAddress(
                type: FfiConverterTypeWalletAddressType.read(from: &buf), 
                firstAddress: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FoundAddress, into buf: inout [UInt8]) {
        FfiConverterTypeWalletAddressType.write(value.type, into: &buf)
        FfiConverterString.write(value.firstAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFoundAddress_lift(_ buf: RustBuffer) throws -> FoundAddress {
    return try FfiConverterTypeFoundAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFoundAddress_lower(_ value: FoundAddress) -> RustBuffer {
    return FfiConverterTypeFoundAddress.lower(value)
}


public struct GroupedWord {
    public var number: UInt8
    public var word: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(number: UInt8, word: String) {
        self.number = number
        self.word = word
    }
}



extension GroupedWord: Equatable, Hashable {
    public static func ==(lhs: GroupedWord, rhs: GroupedWord) -> Bool {
        if lhs.number != rhs.number {
            return false
        }
        if lhs.word != rhs.word {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(number)
        hasher.combine(word)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroupedWord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GroupedWord {
        return
            try GroupedWord(
                number: FfiConverterUInt8.read(from: &buf), 
                word: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GroupedWord, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.number, into: &buf)
        FfiConverterString.write(value.word, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupedWord_lift(_ buf: RustBuffer) throws -> GroupedWord {
    return try FfiConverterTypeGroupedWord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupedWord_lower(_ value: GroupedWord) -> RustBuffer {
    return FfiConverterTypeGroupedWord.lower(value)
}


public struct ImportWalletManagerState {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension ImportWalletManagerState: Equatable, Hashable {
    public static func ==(lhs: ImportWalletManagerState, rhs: ImportWalletManagerState) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportWalletManagerState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportWalletManagerState {
        return
            ImportWalletManagerState()
    }

    public static func write(_ value: ImportWalletManagerState, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerState_lift(_ buf: RustBuffer) throws -> ImportWalletManagerState {
    return try FfiConverterTypeImportWalletManagerState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerState_lower(_ value: ImportWalletManagerState) -> RustBuffer {
    return FfiConverterTypeImportWalletManagerState.lower(value)
}


public struct InternalOnlyMetadata {
    public var addressIndex: AddressIndex?
    public var lastScanFinished: TimeInterval?
    public var lastHeightFetched: BlockSizeLast?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addressIndex: AddressIndex?, lastScanFinished: TimeInterval?, lastHeightFetched: BlockSizeLast?) {
        self.addressIndex = addressIndex
        self.lastScanFinished = lastScanFinished
        self.lastHeightFetched = lastHeightFetched
    }
}



extension InternalOnlyMetadata: Equatable, Hashable {
    public static func ==(lhs: InternalOnlyMetadata, rhs: InternalOnlyMetadata) -> Bool {
        if lhs.addressIndex != rhs.addressIndex {
            return false
        }
        if lhs.lastScanFinished != rhs.lastScanFinished {
            return false
        }
        if lhs.lastHeightFetched != rhs.lastHeightFetched {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addressIndex)
        hasher.combine(lastScanFinished)
        hasher.combine(lastHeightFetched)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInternalOnlyMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InternalOnlyMetadata {
        return
            try InternalOnlyMetadata(
                addressIndex: FfiConverterOptionTypeAddressIndex.read(from: &buf), 
                lastScanFinished: FfiConverterOptionDuration.read(from: &buf), 
                lastHeightFetched: FfiConverterOptionTypeBlockSizeLast.read(from: &buf)
        )
    }

    public static func write(_ value: InternalOnlyMetadata, into buf: inout [UInt8]) {
        FfiConverterOptionTypeAddressIndex.write(value.addressIndex, into: &buf)
        FfiConverterOptionDuration.write(value.lastScanFinished, into: &buf)
        FfiConverterOptionTypeBlockSizeLast.write(value.lastHeightFetched, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInternalOnlyMetadata_lift(_ buf: RustBuffer) throws -> InternalOnlyMetadata {
    return try FfiConverterTypeInternalOnlyMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInternalOnlyMetadata_lower(_ value: InternalOnlyMetadata) -> RustBuffer {
    return FfiConverterTypeInternalOnlyMetadata.lower(value)
}


public struct MessageInfo {
    /**
     * The payload length of the message, including the header info
     */
    public var fullMessageLength: UInt16
    /**
     * The payload length of the message, reported in the info header
     * This is the length of the payload, without the header info
     */
    public var payloadLength: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The payload length of the message, including the header info
         */fullMessageLength: UInt16, 
        /**
         * The payload length of the message, reported in the info header
         * This is the length of the payload, without the header info
         */payloadLength: UInt16) {
        self.fullMessageLength = fullMessageLength
        self.payloadLength = payloadLength
    }
}



extension MessageInfo: Equatable, Hashable {
    public static func ==(lhs: MessageInfo, rhs: MessageInfo) -> Bool {
        if lhs.fullMessageLength != rhs.fullMessageLength {
            return false
        }
        if lhs.payloadLength != rhs.payloadLength {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fullMessageLength)
        hasher.combine(payloadLength)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageInfo {
        return
            try MessageInfo(
                fullMessageLength: FfiConverterUInt16.read(from: &buf), 
                payloadLength: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: MessageInfo, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.fullMessageLength, into: &buf)
        FfiConverterUInt16.write(value.payloadLength, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageInfo_lift(_ buf: RustBuffer) throws -> MessageInfo {
    return try FfiConverterTypeMessageInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageInfo_lower(_ value: MessageInfo) -> RustBuffer {
    return FfiConverterTypeMessageInfo.lower(value)
}


public struct NdefHeader {
    public var messageBegin: Bool
    public var messageEnd: Bool
    public var chunked: Bool
    public var shortRecord: Bool
    public var hasIdLength: Bool
    public var typeNameFormat: NdefType
    public var typeLength: UInt8
    public var payloadLength: UInt32
    public var idLength: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(messageBegin: Bool, messageEnd: Bool, chunked: Bool, shortRecord: Bool, hasIdLength: Bool, typeNameFormat: NdefType, typeLength: UInt8, payloadLength: UInt32, idLength: UInt8?) {
        self.messageBegin = messageBegin
        self.messageEnd = messageEnd
        self.chunked = chunked
        self.shortRecord = shortRecord
        self.hasIdLength = hasIdLength
        self.typeNameFormat = typeNameFormat
        self.typeLength = typeLength
        self.payloadLength = payloadLength
        self.idLength = idLength
    }
}



extension NdefHeader: Equatable, Hashable {
    public static func ==(lhs: NdefHeader, rhs: NdefHeader) -> Bool {
        if lhs.messageBegin != rhs.messageBegin {
            return false
        }
        if lhs.messageEnd != rhs.messageEnd {
            return false
        }
        if lhs.chunked != rhs.chunked {
            return false
        }
        if lhs.shortRecord != rhs.shortRecord {
            return false
        }
        if lhs.hasIdLength != rhs.hasIdLength {
            return false
        }
        if lhs.typeNameFormat != rhs.typeNameFormat {
            return false
        }
        if lhs.typeLength != rhs.typeLength {
            return false
        }
        if lhs.payloadLength != rhs.payloadLength {
            return false
        }
        if lhs.idLength != rhs.idLength {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messageBegin)
        hasher.combine(messageEnd)
        hasher.combine(chunked)
        hasher.combine(shortRecord)
        hasher.combine(hasIdLength)
        hasher.combine(typeNameFormat)
        hasher.combine(typeLength)
        hasher.combine(payloadLength)
        hasher.combine(idLength)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNdefHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NdefHeader {
        return
            try NdefHeader(
                messageBegin: FfiConverterBool.read(from: &buf), 
                messageEnd: FfiConverterBool.read(from: &buf), 
                chunked: FfiConverterBool.read(from: &buf), 
                shortRecord: FfiConverterBool.read(from: &buf), 
                hasIdLength: FfiConverterBool.read(from: &buf), 
                typeNameFormat: FfiConverterTypeNdefType.read(from: &buf), 
                typeLength: FfiConverterUInt8.read(from: &buf), 
                payloadLength: FfiConverterUInt32.read(from: &buf), 
                idLength: FfiConverterOptionUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: NdefHeader, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.messageBegin, into: &buf)
        FfiConverterBool.write(value.messageEnd, into: &buf)
        FfiConverterBool.write(value.chunked, into: &buf)
        FfiConverterBool.write(value.shortRecord, into: &buf)
        FfiConverterBool.write(value.hasIdLength, into: &buf)
        FfiConverterTypeNdefType.write(value.typeNameFormat, into: &buf)
        FfiConverterUInt8.write(value.typeLength, into: &buf)
        FfiConverterUInt32.write(value.payloadLength, into: &buf)
        FfiConverterOptionUInt8.write(value.idLength, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNdefHeader_lift(_ buf: RustBuffer) throws -> NdefHeader {
    return try FfiConverterTypeNdefHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNdefHeader_lower(_ value: NdefHeader) -> RustBuffer {
    return FfiConverterTypeNdefHeader.lower(value)
}


public struct NdefRecord {
    public var header: NdefHeader
    public var type: Data
    public var id: Data?
    public var payload: NdefPayload

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(header: NdefHeader, type: Data, id: Data?, payload: NdefPayload) {
        self.header = header
        self.type = type
        self.id = id
        self.payload = payload
    }
}



extension NdefRecord: Equatable, Hashable {
    public static func ==(lhs: NdefRecord, rhs: NdefRecord) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.payload != rhs.payload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(type)
        hasher.combine(id)
        hasher.combine(payload)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNdefRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NdefRecord {
        return
            try NdefRecord(
                header: FfiConverterTypeNdefHeader.read(from: &buf), 
                type: FfiConverterData.read(from: &buf), 
                id: FfiConverterOptionData.read(from: &buf), 
                payload: FfiConverterTypeNdefPayload.read(from: &buf)
        )
    }

    public static func write(_ value: NdefRecord, into buf: inout [UInt8]) {
        FfiConverterTypeNdefHeader.write(value.header, into: &buf)
        FfiConverterData.write(value.type, into: &buf)
        FfiConverterOptionData.write(value.id, into: &buf)
        FfiConverterTypeNdefPayload.write(value.payload, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNdefRecord_lift(_ buf: RustBuffer) throws -> NdefRecord {
    return try FfiConverterTypeNdefRecord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNdefRecord_lower(_ value: NdefRecord) -> RustBuffer {
    return FfiConverterTypeNdefRecord.lower(value)
}


public struct Node {
    public var name: String
    public var network: Network
    public var apiType: ApiType
    public var url: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, network: Network, apiType: ApiType, url: String) {
        self.name = name
        self.network = network
        self.apiType = apiType
        self.url = url
    }
}



extension Node: Equatable, Hashable {
    public static func ==(lhs: Node, rhs: Node) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.apiType != rhs.apiType {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(network)
        hasher.combine(apiType)
        hasher.combine(url)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNode: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Node {
        return
            try Node(
                name: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                apiType: FfiConverterTypeApiType.read(from: &buf), 
                url: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Node, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterTypeApiType.write(value.apiType, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNode_lift(_ buf: RustBuffer) throws -> Node {
    return try FfiConverterTypeNode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNode_lower(_ value: Node) -> RustBuffer {
    return FfiConverterTypeNode.lower(value)
}


public struct ParsingContext {
    public var messageInfo: MessageInfo
    public var needed: UInt16
    public var firstBlockHash: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(messageInfo: MessageInfo, needed: UInt16, firstBlockHash: String?) {
        self.messageInfo = messageInfo
        self.needed = needed
        self.firstBlockHash = firstBlockHash
    }
}



extension ParsingContext: Equatable, Hashable {
    public static func ==(lhs: ParsingContext, rhs: ParsingContext) -> Bool {
        if lhs.messageInfo != rhs.messageInfo {
            return false
        }
        if lhs.needed != rhs.needed {
            return false
        }
        if lhs.firstBlockHash != rhs.firstBlockHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messageInfo)
        hasher.combine(needed)
        hasher.combine(firstBlockHash)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParsingContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsingContext {
        return
            try ParsingContext(
                messageInfo: FfiConverterTypeMessageInfo.read(from: &buf), 
                needed: FfiConverterUInt16.read(from: &buf), 
                firstBlockHash: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ParsingContext, into buf: inout [UInt8]) {
        FfiConverterTypeMessageInfo.write(value.messageInfo, into: &buf)
        FfiConverterUInt16.write(value.needed, into: &buf)
        FfiConverterOptionString.write(value.firstBlockHash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsingContext_lift(_ buf: RustBuffer) throws -> ParsingContext {
    return try FfiConverterTypeParsingContext.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsingContext_lower(_ value: ParsingContext) -> RustBuffer {
    return FfiConverterTypeParsingContext.lower(value)
}


public struct ParsingMessage {
    public var messageInfo: MessageInfo
    public var leftOverBytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(messageInfo: MessageInfo, leftOverBytes: Data) {
        self.messageInfo = messageInfo
        self.leftOverBytes = leftOverBytes
    }
}



extension ParsingMessage: Equatable, Hashable {
    public static func ==(lhs: ParsingMessage, rhs: ParsingMessage) -> Bool {
        if lhs.messageInfo != rhs.messageInfo {
            return false
        }
        if lhs.leftOverBytes != rhs.leftOverBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messageInfo)
        hasher.combine(leftOverBytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParsingMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsingMessage {
        return
            try ParsingMessage(
                messageInfo: FfiConverterTypeMessageInfo.read(from: &buf), 
                leftOverBytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: ParsingMessage, into buf: inout [UInt8]) {
        FfiConverterTypeMessageInfo.write(value.messageInfo, into: &buf)
        FfiConverterData.write(value.leftOverBytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsingMessage_lift(_ buf: RustBuffer) throws -> ParsingMessage {
    return try FfiConverterTypeParsingMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsingMessage_lower(_ value: ParsingMessage) -> RustBuffer {
    return FfiConverterTypeParsingMessage.lower(value)
}


public struct PendingDetails {
    public var lastSeen: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastSeen: UInt64) {
        self.lastSeen = lastSeen
    }
}



extension PendingDetails: Equatable, Hashable {
    public static func ==(lhs: PendingDetails, rhs: PendingDetails) -> Bool {
        if lhs.lastSeen != rhs.lastSeen {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastSeen)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingDetails {
        return
            try PendingDetails(
                lastSeen: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PendingDetails, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.lastSeen, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingDetails_lift(_ buf: RustBuffer) throws -> PendingDetails {
    return try FfiConverterTypePendingDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingDetails_lower(_ value: PendingDetails) -> RustBuffer {
    return FfiConverterTypePendingDetails.lower(value)
}


public struct PendingWalletManagerState {
    public var numberOfWords: NumberOfBip39Words
    public var wallet: PendingWallet

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numberOfWords: NumberOfBip39Words, wallet: PendingWallet) {
        self.numberOfWords = numberOfWords
        self.wallet = wallet
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingWalletManagerState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletManagerState {
        return
            try PendingWalletManagerState(
                numberOfWords: FfiConverterTypeNumberOfBip39Words.read(from: &buf), 
                wallet: FfiConverterTypePendingWallet.read(from: &buf)
        )
    }

    public static func write(_ value: PendingWalletManagerState, into buf: inout [UInt8]) {
        FfiConverterTypeNumberOfBip39Words.write(value.numberOfWords, into: &buf)
        FfiConverterTypePendingWallet.write(value.wallet, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerState_lift(_ buf: RustBuffer) throws -> PendingWalletManagerState {
    return try FfiConverterTypePendingWalletManagerState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerState_lower(_ value: PendingWalletManagerState) -> RustBuffer {
    return FfiConverterTypePendingWalletManagerState.lower(value)
}


public struct PriceResponse {
    public var time: UInt64
    public var usd: UInt64
    public var eur: UInt64
    public var gbp: UInt64
    public var cad: UInt64
    public var chf: UInt64
    public var aud: UInt64
    public var jpy: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(time: UInt64, usd: UInt64, eur: UInt64, gbp: UInt64, cad: UInt64, chf: UInt64, aud: UInt64, jpy: UInt64) {
        self.time = time
        self.usd = usd
        self.eur = eur
        self.gbp = gbp
        self.cad = cad
        self.chf = chf
        self.aud = aud
        self.jpy = jpy
    }
}



extension PriceResponse: Equatable, Hashable {
    public static func ==(lhs: PriceResponse, rhs: PriceResponse) -> Bool {
        if lhs.time != rhs.time {
            return false
        }
        if lhs.usd != rhs.usd {
            return false
        }
        if lhs.eur != rhs.eur {
            return false
        }
        if lhs.gbp != rhs.gbp {
            return false
        }
        if lhs.cad != rhs.cad {
            return false
        }
        if lhs.chf != rhs.chf {
            return false
        }
        if lhs.aud != rhs.aud {
            return false
        }
        if lhs.jpy != rhs.jpy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(time)
        hasher.combine(usd)
        hasher.combine(eur)
        hasher.combine(gbp)
        hasher.combine(cad)
        hasher.combine(chf)
        hasher.combine(aud)
        hasher.combine(jpy)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePriceResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PriceResponse {
        return
            try PriceResponse(
                time: FfiConverterUInt64.read(from: &buf), 
                usd: FfiConverterUInt64.read(from: &buf), 
                eur: FfiConverterUInt64.read(from: &buf), 
                gbp: FfiConverterUInt64.read(from: &buf), 
                cad: FfiConverterUInt64.read(from: &buf), 
                chf: FfiConverterUInt64.read(from: &buf), 
                aud: FfiConverterUInt64.read(from: &buf), 
                jpy: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PriceResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.time, into: &buf)
        FfiConverterUInt64.write(value.usd, into: &buf)
        FfiConverterUInt64.write(value.eur, into: &buf)
        FfiConverterUInt64.write(value.gbp, into: &buf)
        FfiConverterUInt64.write(value.cad, into: &buf)
        FfiConverterUInt64.write(value.chf, into: &buf)
        FfiConverterUInt64.write(value.aud, into: &buf)
        FfiConverterUInt64.write(value.jpy, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePriceResponse_lift(_ buf: RustBuffer) throws -> PriceResponse {
    return try FfiConverterTypePriceResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePriceResponse_lower(_ value: PriceResponse) -> RustBuffer {
    return FfiConverterTypePriceResponse.lower(value)
}


public struct Rgb {
    public var r: UInt8
    public var g: UInt8
    public var b: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(r: UInt8, g: UInt8, b: UInt8) {
        self.r = r
        self.g = g
        self.b = b
    }
}



extension Rgb: Equatable, Hashable {
    public static func ==(lhs: Rgb, rhs: Rgb) -> Bool {
        if lhs.r != rhs.r {
            return false
        }
        if lhs.g != rhs.g {
            return false
        }
        if lhs.b != rhs.b {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(r)
        hasher.combine(g)
        hasher.combine(b)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRgb: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Rgb {
        return
            try Rgb(
                r: FfiConverterUInt8.read(from: &buf), 
                g: FfiConverterUInt8.read(from: &buf), 
                b: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Rgb, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.r, into: &buf)
        FfiConverterUInt8.write(value.g, into: &buf)
        FfiConverterUInt8.write(value.b, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRgb_lift(_ buf: RustBuffer) throws -> Rgb {
    return try FfiConverterTypeRgb.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRgb_lower(_ value: Rgb) -> RustBuffer {
    return FfiConverterTypeRgb.lower(value)
}


public struct Router {
    public var app: FfiApp
    public var `default`: Route
    public var routes: [Route]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(app: FfiApp, `default`: Route, routes: [Route]) {
        self.app = app
        self.`default` = `default`
        self.routes = routes
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRouter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Router {
        return
            try Router(
                app: FfiConverterTypeFfiApp.read(from: &buf), 
                default: FfiConverterTypeRoute.read(from: &buf), 
                routes: FfiConverterSequenceTypeRoute.read(from: &buf)
        )
    }

    public static func write(_ value: Router, into buf: inout [UInt8]) {
        FfiConverterTypeFfiApp.write(value.app, into: &buf)
        FfiConverterTypeRoute.write(value.`default`, into: &buf)
        FfiConverterSequenceTypeRoute.write(value.routes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRouter_lift(_ buf: RustBuffer) throws -> Router {
    return try FfiConverterTypeRouter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRouter_lower(_ value: Router) -> RustBuffer {
    return FfiConverterTypeRouter.lower(value)
}


public struct ScanningInfo {
    public var addressType: WalletAddressType
    public var count: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addressType: WalletAddressType, count: UInt32) {
        self.addressType = addressType
        self.count = count
    }
}



extension ScanningInfo: Equatable, Hashable {
    public static func ==(lhs: ScanningInfo, rhs: ScanningInfo) -> Bool {
        if lhs.addressType != rhs.addressType {
            return false
        }
        if lhs.count != rhs.count {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addressType)
        hasher.combine(count)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScanningInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScanningInfo {
        return
            try ScanningInfo(
                addressType: FfiConverterTypeWalletAddressType.read(from: &buf), 
                count: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ScanningInfo, into buf: inout [UInt8]) {
        FfiConverterTypeWalletAddressType.write(value.addressType, into: &buf)
        FfiConverterUInt32.write(value.count, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanningInfo_lift(_ buf: RustBuffer) throws -> ScanningInfo {
    return try FfiConverterTypeScanningInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanningInfo_lower(_ value: ScanningInfo) -> RustBuffer {
    return FfiConverterTypeScanningInfo.lower(value)
}


public struct TextPayload {
    public var format: TextPayloadFormat
    public var language: String
    public var text: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(format: TextPayloadFormat, language: String, text: String) {
        self.format = format
        self.language = language
        self.text = text
    }
}



extension TextPayload: Equatable, Hashable {
    public static func ==(lhs: TextPayload, rhs: TextPayload) -> Bool {
        if lhs.format != rhs.format {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(format)
        hasher.combine(language)
        hasher.combine(text)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTextPayload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TextPayload {
        return
            try TextPayload(
                format: FfiConverterTypeTextPayloadFormat.read(from: &buf), 
                language: FfiConverterString.read(from: &buf), 
                text: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TextPayload, into buf: inout [UInt8]) {
        FfiConverterTypeTextPayloadFormat.write(value.format, into: &buf)
        FfiConverterString.write(value.language, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTextPayload_lift(_ buf: RustBuffer) throws -> TextPayload {
    return try FfiConverterTypeTextPayload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTextPayload_lower(_ value: TextPayload) -> RustBuffer {
    return FfiConverterTypeTextPayload.lower(value)
}


public struct WalletMetadata {
    public var id: WalletId
    public var name: String
    public var color: WalletColor
    public var verified: Bool
    public var network: Network
    public var performedFullScan: Bool
    public var masterFingerprint: Fingerprint?
    public var selectedUnit: Unit
    public var selectedFiatCurrency: FiatCurrency
    public var sensitiveVisible: Bool
    public var detailsExpanded: Bool
    public var walletType: WalletType
    public var discoveryState: DiscoveryState
    public var addressType: WalletAddressType
    public var fiatOrBtc: FiatOrBtc
    public var `internal`: InternalOnlyMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: WalletId, name: String, color: WalletColor, verified: Bool, network: Network, performedFullScan: Bool, masterFingerprint: Fingerprint?, selectedUnit: Unit, selectedFiatCurrency: FiatCurrency, sensitiveVisible: Bool, detailsExpanded: Bool, walletType: WalletType, discoveryState: DiscoveryState, addressType: WalletAddressType, fiatOrBtc: FiatOrBtc, `internal`: InternalOnlyMetadata) {
        self.id = id
        self.name = name
        self.color = color
        self.verified = verified
        self.network = network
        self.performedFullScan = performedFullScan
        self.masterFingerprint = masterFingerprint
        self.selectedUnit = selectedUnit
        self.selectedFiatCurrency = selectedFiatCurrency
        self.sensitiveVisible = sensitiveVisible
        self.detailsExpanded = detailsExpanded
        self.walletType = walletType
        self.discoveryState = discoveryState
        self.addressType = addressType
        self.fiatOrBtc = fiatOrBtc
        self.`internal` = `internal`
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletMetadata {
        return
            try WalletMetadata(
                id: FfiConverterTypeWalletId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                color: FfiConverterTypeWalletColor.read(from: &buf), 
                verified: FfiConverterBool.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                performedFullScan: FfiConverterBool.read(from: &buf), 
                masterFingerprint: FfiConverterOptionTypeFingerprint.read(from: &buf), 
                selectedUnit: FfiConverterTypeUnit.read(from: &buf), 
                selectedFiatCurrency: FfiConverterTypeFiatCurrency.read(from: &buf), 
                sensitiveVisible: FfiConverterBool.read(from: &buf), 
                detailsExpanded: FfiConverterBool.read(from: &buf), 
                walletType: FfiConverterTypeWalletType.read(from: &buf), 
                discoveryState: FfiConverterTypeDiscoveryState.read(from: &buf), 
                addressType: FfiConverterTypeWalletAddressType.read(from: &buf), 
                fiatOrBtc: FfiConverterTypeFiatOrBtc.read(from: &buf), 
                internal: FfiConverterTypeInternalOnlyMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: WalletMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeWalletId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeWalletColor.write(value.color, into: &buf)
        FfiConverterBool.write(value.verified, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterBool.write(value.performedFullScan, into: &buf)
        FfiConverterOptionTypeFingerprint.write(value.masterFingerprint, into: &buf)
        FfiConverterTypeUnit.write(value.selectedUnit, into: &buf)
        FfiConverterTypeFiatCurrency.write(value.selectedFiatCurrency, into: &buf)
        FfiConverterBool.write(value.sensitiveVisible, into: &buf)
        FfiConverterBool.write(value.detailsExpanded, into: &buf)
        FfiConverterTypeWalletType.write(value.walletType, into: &buf)
        FfiConverterTypeDiscoveryState.write(value.discoveryState, into: &buf)
        FfiConverterTypeWalletAddressType.write(value.addressType, into: &buf)
        FfiConverterTypeFiatOrBtc.write(value.fiatOrBtc, into: &buf)
        FfiConverterTypeInternalOnlyMetadata.write(value.`internal`, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletMetadata_lift(_ buf: RustBuffer) throws -> WalletMetadata {
    return try FfiConverterTypeWalletMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletMetadata_lower(_ value: WalletMetadata) -> RustBuffer {
    return FfiConverterTypeWalletMetadata.lower(value)
}


public enum AddressError {

    
    
    case NoOutputs
    case ScriptError(String
    )
    case InvalidAddress
    case UnsupportedNetwork
    case WrongNetwork(current: Network
    )
    case EmptyAddress
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressError: FfiConverterRustBuffer {
    typealias SwiftType = AddressError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NoOutputs
        case 2: return .ScriptError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidAddress
        case 4: return .UnsupportedNetwork
        case 5: return .WrongNetwork(
            current: try FfiConverterTypeNetwork.read(from: &buf)
            )
        case 6: return .EmptyAddress

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .NoOutputs:
            writeInt(&buf, Int32(1))
        
        
        case let .ScriptError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InvalidAddress:
            writeInt(&buf, Int32(3))
        
        
        case .UnsupportedNetwork:
            writeInt(&buf, Int32(4))
        
        
        case let .WrongNetwork(current):
            writeInt(&buf, Int32(5))
            FfiConverterTypeNetwork.write(current, into: &buf)
            
        
        case .EmptyAddress:
            writeInt(&buf, Int32(6))
        
        }
    }
}


extension AddressError: Equatable, Hashable {}

extension AddressError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ApiType {
    
    case esplora
    case electrum
    case rpc
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeApiType: FfiConverterRustBuffer {
    typealias SwiftType = ApiType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApiType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .esplora
        
        case 2: return .electrum
        
        case 3: return .rpc
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ApiType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .esplora:
            writeInt(&buf, Int32(1))
        
        
        case .electrum:
            writeInt(&buf, Int32(2))
        
        
        case .rpc:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApiType_lift(_ buf: RustBuffer) throws -> ApiType {
    return try FfiConverterTypeApiType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApiType_lower(_ value: ApiType) -> RustBuffer {
    return FfiConverterTypeApiType.lower(value)
}



extension ApiType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AppAction {
    
    case updateRoute(routes: [Route]
    )
    case changeNetwork(network: Network
    )
    case changeColorScheme(ColorSchemeSelection
    )
    case setSelectedNode(Node
    )
    case updateFiatPrices
    case updateFees
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppAction: FfiConverterRustBuffer {
    typealias SwiftType = AppAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .updateRoute(routes: try FfiConverterSequenceTypeRoute.read(from: &buf)
        )
        
        case 2: return .changeNetwork(network: try FfiConverterTypeNetwork.read(from: &buf)
        )
        
        case 3: return .changeColorScheme(try FfiConverterTypeColorSchemeSelection.read(from: &buf)
        )
        
        case 4: return .setSelectedNode(try FfiConverterTypeNode.read(from: &buf)
        )
        
        case 5: return .updateFiatPrices
        
        case 6: return .updateFees
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AppAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .updateRoute(routes):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoute.write(routes, into: &buf)
            
        
        case let .changeNetwork(network):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNetwork.write(network, into: &buf)
            
        
        case let .changeColorScheme(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeColorSchemeSelection.write(v1, into: &buf)
            
        
        case let .setSelectedNode(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeNode.write(v1, into: &buf)
            
        
        case .updateFiatPrices:
            writeInt(&buf, Int32(5))
        
        
        case .updateFees:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppAction_lift(_ buf: RustBuffer) throws -> AppAction {
    return try FfiConverterTypeAppAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppAction_lower(_ value: AppAction) -> RustBuffer {
    return FfiConverterTypeAppAction.lower(value)
}





public enum AppError {

    
    
    case PricesError(String
    )
    case FeesError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppError: FfiConverterRustBuffer {
    typealias SwiftType = AppError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .PricesError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .FeesError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AppError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .PricesError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .FeesError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension AppError: Equatable, Hashable {}

extension AppError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AppStateReconcileMessage {
    
    case defaultRouteChanged(Route,[Route]
    )
    case routeUpdated([Route]
    )
    case databaseUpdated
    case colorSchemeChanged(ColorSchemeSelection
    )
    case selectedNodeChanged(Node
    )
    case fiatPricesChanged(PriceResponse
    )
    case feesChanged(FeeResponse
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppStateReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = AppStateReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppStateReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .defaultRouteChanged(try FfiConverterTypeRoute.read(from: &buf), try FfiConverterSequenceTypeRoute.read(from: &buf)
        )
        
        case 2: return .routeUpdated(try FfiConverterSequenceTypeRoute.read(from: &buf)
        )
        
        case 3: return .databaseUpdated
        
        case 4: return .colorSchemeChanged(try FfiConverterTypeColorSchemeSelection.read(from: &buf)
        )
        
        case 5: return .selectedNodeChanged(try FfiConverterTypeNode.read(from: &buf)
        )
        
        case 6: return .fiatPricesChanged(try FfiConverterTypePriceResponse.read(from: &buf)
        )
        
        case 7: return .feesChanged(try FfiConverterTypeFeeResponse.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AppStateReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .defaultRouteChanged(v1,v2):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRoute.write(v1, into: &buf)
            FfiConverterSequenceTypeRoute.write(v2, into: &buf)
            
        
        case let .routeUpdated(v1):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeRoute.write(v1, into: &buf)
            
        
        case .databaseUpdated:
            writeInt(&buf, Int32(3))
        
        
        case let .colorSchemeChanged(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeColorSchemeSelection.write(v1, into: &buf)
            
        
        case let .selectedNodeChanged(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeNode.write(v1, into: &buf)
            
        
        case let .fiatPricesChanged(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypePriceResponse.write(v1, into: &buf)
            
        
        case let .feesChanged(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeFeeResponse.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppStateReconcileMessage_lift(_ buf: RustBuffer) throws -> AppStateReconcileMessage {
    return try FfiConverterTypeAppStateReconcileMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppStateReconcileMessage_lower(_ value: AppStateReconcileMessage) -> RustBuffer {
    return FfiConverterTypeAppStateReconcileMessage.lower(value)
}





public enum Bip39Error {

    
    
    /**
     * Mnemonic has a word count that is not a multiple of 6, found {0}.
     */
    case BadWordCount(UInt32
    )
    /**
     * Mnemonic contains an unknown word at index {0}.
     */
    case UnknownWord(UInt32
    )
    /**
     * Entropy was not a multiple of 32 bits or between 128-256n bits in length.
     */
    case BadEntropyBitCount(UInt32
    )
    /**
     * The mnemonic has an invalid checksum.
     */
    case InvalidChecksum
    /**
     * The mnemonic can be interpreted as multiple languages.
     * Use the helper methods of the inner struct to inspect
     * which languages are possible.
     */
    case AmbiguousLanguages
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip39Error: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BadWordCount(
            try FfiConverterUInt32.read(from: &buf)
            )
        case 2: return .UnknownWord(
            try FfiConverterUInt32.read(from: &buf)
            )
        case 3: return .BadEntropyBitCount(
            try FfiConverterUInt32.read(from: &buf)
            )
        case 4: return .InvalidChecksum
        case 5: return .AmbiguousLanguages

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Error, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BadWordCount(v1):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(v1, into: &buf)
            
        
        case let .UnknownWord(v1):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(v1, into: &buf)
            
        
        case let .BadEntropyBitCount(v1):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(v1, into: &buf)
            
        
        case .InvalidChecksum:
            writeInt(&buf, Int32(4))
        
        
        case .AmbiguousLanguages:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension Bip39Error: Equatable, Hashable {}

extension Bip39Error: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum BitcoinTransactionError {

    
    
    case HexDecodeError(String
    )
    case ParseTransactionError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinTransactionError: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinTransactionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinTransactionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .HexDecodeError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .ParseTransactionError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BitcoinTransactionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .HexDecodeError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ParseTransactionError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension BitcoinTransactionError: Equatable, Hashable {}

extension BitcoinTransactionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ColdWalletRoute {
    
    case qrCode
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeColdWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = ColdWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ColdWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .qrCode
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ColdWalletRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case .qrCode:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColdWalletRoute_lift(_ buf: RustBuffer) throws -> ColdWalletRoute {
    return try FfiConverterTypeColdWalletRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColdWalletRoute_lower(_ value: ColdWalletRoute) -> RustBuffer {
    return FfiConverterTypeColdWalletRoute.lower(value)
}



extension ColdWalletRoute: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ColorSchemeSelection {
    
    case light
    case dark
    case system
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeColorSchemeSelection: FfiConverterRustBuffer {
    typealias SwiftType = ColorSchemeSelection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ColorSchemeSelection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .light
        
        case 2: return .dark
        
        case 3: return .system
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ColorSchemeSelection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .light:
            writeInt(&buf, Int32(1))
        
        
        case .dark:
            writeInt(&buf, Int32(2))
        
        
        case .system:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColorSchemeSelection_lift(_ buf: RustBuffer) throws -> ColorSchemeSelection {
    return try FfiConverterTypeColorSchemeSelection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColorSchemeSelection_lower(_ value: ColorSchemeSelection) -> RustBuffer {
    return FfiConverterTypeColorSchemeSelection.lower(value)
}



extension ColorSchemeSelection: Equatable, Hashable {}




public enum ConfirmDetailsError {

    
    
    case QrCodeCreation(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmDetailsError: FfiConverterRustBuffer {
    typealias SwiftType = ConfirmDetailsError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmDetailsError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .QrCodeCreation(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConfirmDetailsError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .QrCodeCreation(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension ConfirmDetailsError: Equatable, Hashable {}

extension ConfirmDetailsError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum DatabaseError {

    
    
    case DatabaseAccess(String
    )
    case TableAccess(String
    )
    case Wallets(WalletTableError
    )
    case GlobalFlag(GlobalFlagTableError
    )
    case GlobalConfig(GlobalConfigTableError
    )
    case GlobalCache(GlobalCacheTableError
    )
    case UnsignedTransactions(UnsignedTransactionsTableError
    )
    case Serialization(SerdeError
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDatabaseError: FfiConverterRustBuffer {
    typealias SwiftType = DatabaseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatabaseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DatabaseAccess(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .TableAccess(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Wallets(
            try FfiConverterTypeWalletTableError.read(from: &buf)
            )
        case 4: return .GlobalFlag(
            try FfiConverterTypeGlobalFlagTableError.read(from: &buf)
            )
        case 5: return .GlobalConfig(
            try FfiConverterTypeGlobalConfigTableError.read(from: &buf)
            )
        case 6: return .GlobalCache(
            try FfiConverterTypeGlobalCacheTableError.read(from: &buf)
            )
        case 7: return .UnsignedTransactions(
            try FfiConverterTypeUnsignedTransactionsTableError.read(from: &buf)
            )
        case 8: return .Serialization(
            try FfiConverterTypeSerdeError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DatabaseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .DatabaseAccess(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .TableAccess(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Wallets(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletTableError.write(v1, into: &buf)
            
        
        case let .GlobalFlag(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeGlobalFlagTableError.write(v1, into: &buf)
            
        
        case let .GlobalConfig(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeGlobalConfigTableError.write(v1, into: &buf)
            
        
        case let .GlobalCache(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeGlobalCacheTableError.write(v1, into: &buf)
            
        
        case let .UnsignedTransactions(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeUnsignedTransactionsTableError.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeSerdeError.write(v1, into: &buf)
            
        }
    }
}


extension DatabaseError: Equatable, Hashable {}

extension DatabaseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum DescriptorError {

    
    
    case InvalidDescriptor(String
    )
    case MissingKeys
    case TooManyKeys(UInt32
    )
    case InvalidDescriptorParse(String
    )
    case MissingDescriptor
    case MissingXpub
    case MissingDerivationPath
    case MissingScriptType
    case MissingFingerprint
    case InvalidXpub(String
    )
    case UnableToParseXpub(String
    )
    case NoXpubInDescriptor
    case SinglePubkeyNotSupported
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorError: FfiConverterRustBuffer {
    typealias SwiftType = DescriptorError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidDescriptor(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .MissingKeys
        case 3: return .TooManyKeys(
            try FfiConverterUInt32.read(from: &buf)
            )
        case 4: return .InvalidDescriptorParse(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .MissingDescriptor
        case 6: return .MissingXpub
        case 7: return .MissingDerivationPath
        case 8: return .MissingScriptType
        case 9: return .MissingFingerprint
        case 10: return .InvalidXpub(
            try FfiConverterString.read(from: &buf)
            )
        case 11: return .UnableToParseXpub(
            try FfiConverterString.read(from: &buf)
            )
        case 12: return .NoXpubInDescriptor
        case 13: return .SinglePubkeyNotSupported

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DescriptorError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidDescriptor(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .MissingKeys:
            writeInt(&buf, Int32(2))
        
        
        case let .TooManyKeys(v1):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(v1, into: &buf)
            
        
        case let .InvalidDescriptorParse(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .MissingDescriptor:
            writeInt(&buf, Int32(5))
        
        
        case .MissingXpub:
            writeInt(&buf, Int32(6))
        
        
        case .MissingDerivationPath:
            writeInt(&buf, Int32(7))
        
        
        case .MissingScriptType:
            writeInt(&buf, Int32(8))
        
        
        case .MissingFingerprint:
            writeInt(&buf, Int32(9))
        
        
        case let .InvalidXpub(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .UnableToParseXpub(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .NoXpubInDescriptor:
            writeInt(&buf, Int32(12))
        
        
        case .SinglePubkeyNotSupported:
            writeInt(&buf, Int32(13))
        
        }
    }
}


extension DescriptorError: Equatable, Hashable {}

extension DescriptorError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DiscoveryState {
    
    case single
    case startedJson(FoundJson
    )
    case startedMnemonic
    case foundAddressesFromJson([FoundAddress],FoundJson
    )
    case foundAddressesFromMnemonic([FoundAddress]
    )
    case noneFound
    case choseAdressType
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDiscoveryState: FfiConverterRustBuffer {
    typealias SwiftType = DiscoveryState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DiscoveryState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .single
        
        case 2: return .startedJson(try FfiConverterTypeFoundJson.read(from: &buf)
        )
        
        case 3: return .startedMnemonic
        
        case 4: return .foundAddressesFromJson(try FfiConverterSequenceTypeFoundAddress.read(from: &buf), try FfiConverterTypeFoundJson.read(from: &buf)
        )
        
        case 5: return .foundAddressesFromMnemonic(try FfiConverterSequenceTypeFoundAddress.read(from: &buf)
        )
        
        case 6: return .noneFound
        
        case 7: return .choseAdressType
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DiscoveryState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .single:
            writeInt(&buf, Int32(1))
        
        
        case let .startedJson(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFoundJson.write(v1, into: &buf)
            
        
        case .startedMnemonic:
            writeInt(&buf, Int32(3))
        
        
        case let .foundAddressesFromJson(v1,v2):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeFoundAddress.write(v1, into: &buf)
            FfiConverterTypeFoundJson.write(v2, into: &buf)
            
        
        case let .foundAddressesFromMnemonic(v1):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeFoundAddress.write(v1, into: &buf)
            
        
        case .noneFound:
            writeInt(&buf, Int32(6))
        
        
        case .choseAdressType:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDiscoveryState_lift(_ buf: RustBuffer) throws -> DiscoveryState {
    return try FfiConverterTypeDiscoveryState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDiscoveryState_lower(_ value: DiscoveryState) -> RustBuffer {
    return FfiConverterTypeDiscoveryState.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FeeSpeed {
    
    case fast
    case medium
    case slow
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeSpeed: FfiConverterRustBuffer {
    typealias SwiftType = FeeSpeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSpeed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fast
        
        case 2: return .medium
        
        case 3: return .slow
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FeeSpeed, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fast:
            writeInt(&buf, Int32(1))
        
        
        case .medium:
            writeInt(&buf, Int32(2))
        
        
        case .slow:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSpeed_lift(_ buf: RustBuffer) throws -> FeeSpeed {
    return try FfiConverterTypeFeeSpeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSpeed_lower(_ value: FeeSpeed) -> RustBuffer {
    return FfiConverterTypeFeeSpeed.lower(value)
}



extension FeeSpeed: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiColor {
    
    case red(FfiOpacity
    )
    case blue(FfiOpacity
    )
    case green(FfiOpacity
    )
    case yellow(FfiOpacity
    )
    case orange(FfiOpacity
    )
    case purple(FfiOpacity
    )
    case pink(FfiOpacity
    )
    case white(FfiOpacity
    )
    case black(FfiOpacity
    )
    case gray(FfiOpacity
    )
    case coolGray(FfiOpacity
    )
    case custom(Rgb,FfiOpacity
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiColor: FfiConverterRustBuffer {
    typealias SwiftType = FfiColor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiColor {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .red(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 2: return .blue(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 3: return .green(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 4: return .yellow(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 5: return .orange(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 6: return .purple(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 7: return .pink(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 8: return .white(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 9: return .black(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 10: return .gray(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 11: return .coolGray(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 12: return .custom(try FfiConverterTypeRgb.read(from: &buf), try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiColor, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .red(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .blue(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .green(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .yellow(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .orange(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .purple(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .pink(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .white(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .black(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .gray(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .coolGray(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .custom(v1,v2):
            writeInt(&buf, Int32(12))
            FfiConverterTypeRgb.write(v1, into: &buf)
            FfiConverterTypeFfiOpacity.write(v2, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColor_lift(_ buf: RustBuffer) throws -> FfiColor {
    return try FfiConverterTypeFfiColor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColor_lower(_ value: FfiColor) -> RustBuffer {
    return FfiConverterTypeFfiColor.lower(value)
}



extension FfiColor: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiColorScheme {
    
    case light
    case dark
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiColorScheme: FfiConverterRustBuffer {
    typealias SwiftType = FfiColorScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiColorScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .light
        
        case 2: return .dark
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiColorScheme, into buf: inout [UInt8]) {
        switch value {
        
        
        case .light:
            writeInt(&buf, Int32(1))
        
        
        case .dark:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColorScheme_lift(_ buf: RustBuffer) throws -> FfiColorScheme {
    return try FfiConverterTypeFfiColorScheme.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColorScheme_lower(_ value: FfiColorScheme) -> RustBuffer {
    return FfiConverterTypeFfiColorScheme.lower(value)
}



extension FfiColorScheme: Equatable, Hashable {}




public enum FiatAmountError {

    
    
    /**
     * Unable to convert to fiat amount, prices client unavailable {0}
     */
    case PricesUnavailable(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatAmountError: FfiConverterRustBuffer {
    typealias SwiftType = FiatAmountError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatAmountError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .PricesUnavailable(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatAmountError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .PricesUnavailable(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension FiatAmountError: Equatable, Hashable {}

extension FiatAmountError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FiatCurrency {
    
    case usd
    case eur
    case gbp
    case cad
    case chf
    case aud
    case jpy
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = FiatCurrency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .usd
        
        case 2: return .eur
        
        case 3: return .gbp
        
        case 4: return .cad
        
        case 5: return .chf
        
        case 6: return .aud
        
        case 7: return .jpy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        switch value {
        
        
        case .usd:
            writeInt(&buf, Int32(1))
        
        
        case .eur:
            writeInt(&buf, Int32(2))
        
        
        case .gbp:
            writeInt(&buf, Int32(3))
        
        
        case .cad:
            writeInt(&buf, Int32(4))
        
        
        case .chf:
            writeInt(&buf, Int32(5))
        
        
        case .aud:
            writeInt(&buf, Int32(6))
        
        
        case .jpy:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}



extension FiatCurrency: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FiatOrBtc {
    
    case btc
    case fiat
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatOrBtc: FfiConverterRustBuffer {
    typealias SwiftType = FiatOrBtc

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatOrBtc {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .btc
        
        case 2: return .fiat
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatOrBtc, into buf: inout [UInt8]) {
        switch value {
        
        
        case .btc:
            writeInt(&buf, Int32(1))
        
        
        case .fiat:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatOrBtc_lift(_ buf: RustBuffer) throws -> FiatOrBtc {
    return try FfiConverterTypeFiatOrBtc.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatOrBtc_lower(_ value: FiatOrBtc) -> RustBuffer {
    return FfiConverterTypeFiatOrBtc.lower(value)
}



extension FiatOrBtc: Equatable, Hashable {}




public enum FileHandlerError {

    
    
    /**
     * File not found
     */
    case FileNotFound
    /**
     * Unable to open file {0}
     */
    case OpenFile(String
    )
    /**
     * Unable to to read file {0}
     */
    case ReadFile(String
    )
    /**
     * File is not a recognized format: {0:?}
     */
    case NotRecognizedFormat(MultiFormatError
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileHandlerError: FfiConverterRustBuffer {
    typealias SwiftType = FileHandlerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileHandlerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .FileNotFound
        case 2: return .OpenFile(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .ReadFile(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .NotRecognizedFormat(
            try FfiConverterTypeMultiFormatError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FileHandlerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .FileNotFound:
            writeInt(&buf, Int32(1))
        
        
        case let .OpenFile(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ReadFile(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NotRecognizedFormat(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeMultiFormatError.write(v1, into: &buf)
            
        }
    }
}


extension FileHandlerError: Equatable, Hashable {}

extension FileHandlerError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum FingerprintError {

    
    
    case WalletNotFound
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFingerprintError: FfiConverterRustBuffer {
    typealias SwiftType = FingerprintError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FingerprintError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .WalletNotFound

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FingerprintError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .WalletNotFound:
            writeInt(&buf, Int32(1))
        
        }
    }
}


extension FingerprintError: Equatable, Hashable {}

extension FingerprintError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum GlobalCacheTableError {

    
    
    case Save(String
    )
    case Read(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalCacheTableError: FfiConverterRustBuffer {
    typealias SwiftType = GlobalCacheTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalCacheTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Save(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Read(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalCacheTableError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Save(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Read(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension GlobalCacheTableError: Equatable, Hashable {}

extension GlobalCacheTableError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GlobalConfigKey {
    
    case selectedWalletId
    case selectedNetwork
    case selectedNode(Network
    )
    case colorScheme
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalConfigKey: FfiConverterRustBuffer {
    typealias SwiftType = GlobalConfigKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalConfigKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .selectedWalletId
        
        case 2: return .selectedNetwork
        
        case 3: return .selectedNode(try FfiConverterTypeNetwork.read(from: &buf)
        )
        
        case 4: return .colorScheme
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalConfigKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case .selectedWalletId:
            writeInt(&buf, Int32(1))
        
        
        case .selectedNetwork:
            writeInt(&buf, Int32(2))
        
        
        case let .selectedNode(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNetwork.write(v1, into: &buf)
            
        
        case .colorScheme:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfigKey_lift(_ buf: RustBuffer) throws -> GlobalConfigKey {
    return try FfiConverterTypeGlobalConfigKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfigKey_lower(_ value: GlobalConfigKey) -> RustBuffer {
    return FfiConverterTypeGlobalConfigKey.lower(value)
}



extension GlobalConfigKey: Equatable, Hashable {}




public enum GlobalConfigTableError {

    
    
    case Save(String
    )
    case Read(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalConfigTableError: FfiConverterRustBuffer {
    typealias SwiftType = GlobalConfigTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalConfigTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Save(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Read(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalConfigTableError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Save(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Read(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension GlobalConfigTableError: Equatable, Hashable {}

extension GlobalConfigTableError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GlobalFlagKey {
    
    case completedOnboarding
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalFlagKey: FfiConverterRustBuffer {
    typealias SwiftType = GlobalFlagKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalFlagKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .completedOnboarding
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalFlagKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case .completedOnboarding:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalFlagKey_lift(_ buf: RustBuffer) throws -> GlobalFlagKey {
    return try FfiConverterTypeGlobalFlagKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalFlagKey_lower(_ value: GlobalFlagKey) -> RustBuffer {
    return FfiConverterTypeGlobalFlagKey.lower(value)
}



extension GlobalFlagKey: Equatable, Hashable {}




public enum GlobalFlagTableError {

    
    
    case Save(String
    )
    case Read(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalFlagTableError: FfiConverterRustBuffer {
    typealias SwiftType = GlobalFlagTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalFlagTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Save(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Read(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalFlagTableError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Save(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Read(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension GlobalFlagTableError: Equatable, Hashable {}

extension GlobalFlagTableError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HotWalletRoute {
    
    case select
    case create(NumberOfBip39Words
    )
    case `import`(NumberOfBip39Words,ImportType
    )
    case verifyWords(WalletId
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHotWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = HotWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HotWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .select
        
        case 2: return .create(try FfiConverterTypeNumberOfBip39Words.read(from: &buf)
        )
        
        case 3: return .`import`(try FfiConverterTypeNumberOfBip39Words.read(from: &buf), try FfiConverterTypeImportType.read(from: &buf)
        )
        
        case 4: return .verifyWords(try FfiConverterTypeWalletId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HotWalletRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case .select:
            writeInt(&buf, Int32(1))
        
        
        case let .create(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
            
        
        case let .`import`(v1,v2):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
            FfiConverterTypeImportType.write(v2, into: &buf)
            
        
        case let .verifyWords(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHotWalletRoute_lift(_ buf: RustBuffer) throws -> HotWalletRoute {
    return try FfiConverterTypeHotWalletRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHotWalletRoute_lower(_ value: HotWalletRoute) -> RustBuffer {
    return FfiConverterTypeHotWalletRoute.lower(value)
}



extension HotWalletRoute: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ImportType {
    
    case manual
    case nfc
    case qr
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportType: FfiConverterRustBuffer {
    typealias SwiftType = ImportType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .manual
        
        case 2: return .nfc
        
        case 3: return .qr
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .manual:
            writeInt(&buf, Int32(1))
        
        
        case .nfc:
            writeInt(&buf, Int32(2))
        
        
        case .qr:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportType_lift(_ buf: RustBuffer) throws -> ImportType {
    return try FfiConverterTypeImportType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportType_lower(_ value: ImportType) -> RustBuffer {
    return FfiConverterTypeImportType.lower(value)
}



extension ImportType: Equatable, Hashable {}




public enum ImportWalletError {

    
    
    case WalletImportError(String
    )
    case InvalidWordGroup(String
    )
    case KeychainError(KeychainError
    )
    case WalletAlreadyExists(WalletId
    )
    case DatabaseError(DatabaseError
    )
    case BdkError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportWalletError: FfiConverterRustBuffer {
    typealias SwiftType = ImportWalletError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportWalletError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .WalletImportError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidWordGroup(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .KeychainError(
            try FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 4: return .WalletAlreadyExists(
            try FfiConverterTypeWalletId.read(from: &buf)
            )
        case 5: return .DatabaseError(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 6: return .BdkError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportWalletError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .WalletImportError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidWordGroup(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .KeychainError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeKeychainError.write(v1, into: &buf)
            
        
        case let .WalletAlreadyExists(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        
        case let .DatabaseError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        
        case let .BdkError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension ImportWalletError: Equatable, Hashable {}

extension ImportWalletError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ImportWalletManagerAction {
    
    case noOp
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportWalletManagerAction: FfiConverterRustBuffer {
    typealias SwiftType = ImportWalletManagerAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportWalletManagerAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .noOp
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportWalletManagerAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .noOp:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerAction_lift(_ buf: RustBuffer) throws -> ImportWalletManagerAction {
    return try FfiConverterTypeImportWalletManagerAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerAction_lower(_ value: ImportWalletManagerAction) -> RustBuffer {
    return FfiConverterTypeImportWalletManagerAction.lower(value)
}



extension ImportWalletManagerAction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ImportWalletManagerReconcileMessage {
    
    case noOp
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportWalletManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = ImportWalletManagerReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportWalletManagerReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .noOp
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportWalletManagerReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case .noOp:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerReconcileMessage_lift(_ buf: RustBuffer) throws -> ImportWalletManagerReconcileMessage {
    return try FfiConverterTypeImportWalletManagerReconcileMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerReconcileMessage_lower(_ value: ImportWalletManagerReconcileMessage) -> RustBuffer {
    return FfiConverterTypeImportWalletManagerReconcileMessage.lower(value)
}



extension ImportWalletManagerReconcileMessage: Equatable, Hashable {}




public enum KeychainError {

    
    
    case Save
    case Delete
    case ParseSavedValue(String
    )
    case Encrypt(String
    )
    case Decrypt(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeychainError: FfiConverterRustBuffer {
    typealias SwiftType = KeychainError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeychainError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Save
        case 2: return .Delete
        case 3: return .ParseSavedValue(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Encrypt(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Decrypt(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeychainError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Save:
            writeInt(&buf, Int32(1))
        
        
        case .Delete:
            writeInt(&buf, Int32(2))
        
        
        case let .ParseSavedValue(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Encrypt(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Decrypt(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension KeychainError: Equatable, Hashable {}

extension KeychainError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum MnemonicError {

    
    
    case GetWalletKeychain(KeychainError
    )
    case NotAvailable(WalletId
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonicError: FfiConverterRustBuffer {
    typealias SwiftType = MnemonicError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .GetWalletKeychain(
            try FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 2: return .NotAvailable(
            try FfiConverterTypeWalletId.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MnemonicError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .GetWalletKeychain(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeKeychainError.write(v1, into: &buf)
            
        
        case let .NotAvailable(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        }
    }
}


extension MnemonicError: Equatable, Hashable {}

extension MnemonicError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum MnemonicParseError {

    
    
    case InvalidMnemonic(String,String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonicParseError: FfiConverterRustBuffer {
    typealias SwiftType = MnemonicParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidMnemonic(
            try FfiConverterString.read(from: &buf), 
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MnemonicParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidMnemonic(v1,v2):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            FfiConverterString.write(v2, into: &buf)
            
        }
    }
}


extension MnemonicParseError: Equatable, Hashable {}

extension MnemonicParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MultiFormat {
    
    case address(AddressWithNetwork
    )
    case hardwareExport(HardwareExport
    )
    case mnemonic(Mnemonic
    )
    case transaction(BitcoinTransaction
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMultiFormat: FfiConverterRustBuffer {
    typealias SwiftType = MultiFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .address(try FfiConverterTypeAddressWithNetwork.read(from: &buf)
        )
        
        case 2: return .hardwareExport(try FfiConverterTypeHardwareExport.read(from: &buf)
        )
        
        case 3: return .mnemonic(try FfiConverterTypeMnemonic.read(from: &buf)
        )
        
        case 4: return .transaction(try FfiConverterTypeBitcoinTransaction.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MultiFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .address(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddressWithNetwork.write(v1, into: &buf)
            
        
        case let .hardwareExport(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeHardwareExport.write(v1, into: &buf)
            
        
        case let .mnemonic(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMnemonic.write(v1, into: &buf)
            
        
        case let .transaction(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBitcoinTransaction.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiFormat_lift(_ buf: RustBuffer) throws -> MultiFormat {
    return try FfiConverterTypeMultiFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiFormat_lower(_ value: MultiFormat) -> RustBuffer {
    return FfiConverterTypeMultiFormat.lower(value)
}





public enum MultiFormatError {

    
    
    case InvalidSeedQr(SeedQrError
    )
    /**
     * Address is not supported for any network
     */
    case UnsupportedNetworkAddress
    /**
     * Not a valid format, we only support addresses, SeedQr, mnemonic and xpubs
     */
    case UnrecognizedFormat
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMultiFormatError: FfiConverterRustBuffer {
    typealias SwiftType = MultiFormatError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiFormatError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidSeedQr(
            try FfiConverterTypeSeedQrError.read(from: &buf)
            )
        case 2: return .UnsupportedNetworkAddress
        case 3: return .UnrecognizedFormat

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MultiFormatError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidSeedQr(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSeedQrError.write(v1, into: &buf)
            
        
        case .UnsupportedNetworkAddress:
            writeInt(&buf, Int32(2))
        
        
        case .UnrecognizedFormat:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension MultiFormatError: Equatable, Hashable {}

extension MultiFormatError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum MultiQrError {

    
    
    case CannotAddPartToSingleQr
    case CannotAddPartToSeedQr
    case ParseError(String
    )
    case InvalidUtf8
    case NotYetAvailable
    case CannotAddBinaryDataToBbqr
    case BbqrDidNotContainSeedWords(String
    )
    case InvalidSeedQr(SeedQrError
    )
    case InvalidPlainTextQr(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMultiQrError: FfiConverterRustBuffer {
    typealias SwiftType = MultiQrError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiQrError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CannotAddPartToSingleQr
        case 2: return .CannotAddPartToSeedQr
        case 3: return .ParseError(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .InvalidUtf8
        case 5: return .NotYetAvailable
        case 6: return .CannotAddBinaryDataToBbqr
        case 7: return .BbqrDidNotContainSeedWords(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .InvalidSeedQr(
            try FfiConverterTypeSeedQrError.read(from: &buf)
            )
        case 9: return .InvalidPlainTextQr(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MultiQrError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .CannotAddPartToSingleQr:
            writeInt(&buf, Int32(1))
        
        
        case .CannotAddPartToSeedQr:
            writeInt(&buf, Int32(2))
        
        
        case let .ParseError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InvalidUtf8:
            writeInt(&buf, Int32(4))
        
        
        case .NotYetAvailable:
            writeInt(&buf, Int32(5))
        
        
        case .CannotAddBinaryDataToBbqr:
            writeInt(&buf, Int32(6))
        
        
        case let .BbqrDidNotContainSeedWords(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidSeedQr(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeSeedQrError.write(v1, into: &buf)
            
        
        case let .InvalidPlainTextQr(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension MultiQrError: Equatable, Hashable {}

extension MultiQrError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MultiQrScanResult {
    
    case seedQr(SeedQr
    )
    case single(String
    )
    case completedBBqr(BbqrJoined
    )
    case inProgressBBqr(UInt32
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMultiQrScanResult: FfiConverterRustBuffer {
    typealias SwiftType = MultiQrScanResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiQrScanResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .seedQr(try FfiConverterTypeSeedQr.read(from: &buf)
        )
        
        case 2: return .single(try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .completedBBqr(try FfiConverterTypeBbqrJoined.read(from: &buf)
        )
        
        case 4: return .inProgressBBqr(try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MultiQrScanResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .seedQr(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSeedQr.write(v1, into: &buf)
            
        
        case let .single(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .completedBBqr(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBbqrJoined.write(v1, into: &buf)
            
        
        case let .inProgressBBqr(v1):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiQrScanResult_lift(_ buf: RustBuffer) throws -> MultiQrScanResult {
    return try FfiConverterTypeMultiQrScanResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiQrScanResult_lower(_ value: MultiQrScanResult) -> RustBuffer {
    return FfiConverterTypeMultiQrScanResult.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NdefPayload {
    
    case text(TextPayload
    )
    case data(Data
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNdefPayload: FfiConverterRustBuffer {
    typealias SwiftType = NdefPayload

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NdefPayload {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(try FfiConverterTypeTextPayload.read(from: &buf)
        )
        
        case 2: return .data(try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NdefPayload, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTextPayload.write(v1, into: &buf)
            
        
        case let .data(v1):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNdefPayload_lift(_ buf: RustBuffer) throws -> NdefPayload {
    return try FfiConverterTypeNdefPayload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNdefPayload_lower(_ value: NdefPayload) -> RustBuffer {
    return FfiConverterTypeNdefPayload.lower(value)
}



extension NdefPayload: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NdefType {
    
    case empty
    case wellKnown
    case mime
    case absoluteUri
    case external
    case unknown
    case unchanged
    case reserved
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNdefType: FfiConverterRustBuffer {
    typealias SwiftType = NdefType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NdefType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .empty
        
        case 2: return .wellKnown
        
        case 3: return .mime
        
        case 4: return .absoluteUri
        
        case 5: return .external
        
        case 6: return .unknown
        
        case 7: return .unchanged
        
        case 8: return .reserved
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NdefType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .empty:
            writeInt(&buf, Int32(1))
        
        
        case .wellKnown:
            writeInt(&buf, Int32(2))
        
        
        case .mime:
            writeInt(&buf, Int32(3))
        
        
        case .absoluteUri:
            writeInt(&buf, Int32(4))
        
        
        case .external:
            writeInt(&buf, Int32(5))
        
        
        case .unknown:
            writeInt(&buf, Int32(6))
        
        
        case .unchanged:
            writeInt(&buf, Int32(7))
        
        
        case .reserved:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNdefType_lift(_ buf: RustBuffer) throws -> NdefType {
    return try FfiConverterTypeNdefType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNdefType_lower(_ value: NdefType) -> RustBuffer {
    return FfiConverterTypeNdefType.lower(value)
}



extension NdefType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    
    case bitcoin
    case testnet
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}



extension Network: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NewWalletRoute {
    
    case select
    case hotWallet(HotWalletRoute
    )
    case coldWallet(ColdWalletRoute
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNewWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = NewWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .select
        
        case 2: return .hotWallet(try FfiConverterTypeHotWalletRoute.read(from: &buf)
        )
        
        case 3: return .coldWallet(try FfiConverterTypeColdWalletRoute.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NewWalletRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case .select:
            writeInt(&buf, Int32(1))
        
        
        case let .hotWallet(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeHotWalletRoute.write(v1, into: &buf)
            
        
        case let .coldWallet(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeColdWalletRoute.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewWalletRoute_lift(_ buf: RustBuffer) throws -> NewWalletRoute {
    return try FfiConverterTypeNewWalletRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewWalletRoute_lower(_ value: NewWalletRoute) -> RustBuffer {
    return FfiConverterTypeNewWalletRoute.lower(value)
}



extension NewWalletRoute: Equatable, Hashable {}




public enum NfcReaderError {

    
    
    /**
     * Error parsing the NDEF message
     */
    case ParsingError(String
    )
    /**
     * Not enough data to parse, need atleast enough to parse the message info
     */
    case NotEnoughData
    /**
     * Trying to parse a message that has already been parsed
     */
    case AlreadyParsed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNfcReaderError: FfiConverterRustBuffer {
    typealias SwiftType = NfcReaderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NfcReaderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ParsingError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .NotEnoughData
        case 3: return .AlreadyParsed

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NfcReaderError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ParsingError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .NotEnoughData:
            writeInt(&buf, Int32(2))
        
        
        case .AlreadyParsed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension NfcReaderError: Equatable, Hashable {}

extension NfcReaderError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NodeSelection {
    
    case preset(Node
    )
    case custom(Node
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeSelection: FfiConverterRustBuffer {
    typealias SwiftType = NodeSelection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeSelection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .preset(try FfiConverterTypeNode.read(from: &buf)
        )
        
        case 2: return .custom(try FfiConverterTypeNode.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeSelection, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .preset(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNode.write(v1, into: &buf)
            
        
        case let .custom(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNode.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeSelection_lift(_ buf: RustBuffer) throws -> NodeSelection {
    return try FfiConverterTypeNodeSelection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeSelection_lower(_ value: NodeSelection) -> RustBuffer {
    return FfiConverterTypeNodeSelection.lower(value)
}



extension NodeSelection: Equatable, Hashable {}




public enum NodeSelectorError {

    
    
    case NodeNotFound(String
    )
    case SetSelectedNodeError(String
    )
    case NodeAccessError(String
    )
    case ParseNodeUrlError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeSelectorError: FfiConverterRustBuffer {
    typealias SwiftType = NodeSelectorError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeSelectorError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NodeNotFound(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .SetSelectedNodeError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .NodeAccessError(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .ParseNodeUrlError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeSelectorError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .NodeNotFound(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SetSelectedNodeError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NodeAccessError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ParseNodeUrlError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension NodeSelectorError: Equatable, Hashable {}

extension NodeSelectorError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NumberOfBip39Words {
    
    case twelve
    case twentyFour
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNumberOfBip39Words: FfiConverterRustBuffer {
    typealias SwiftType = NumberOfBip39Words

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NumberOfBip39Words {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .twelve
        
        case 2: return .twentyFour
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NumberOfBip39Words, into buf: inout [UInt8]) {
        switch value {
        
        
        case .twelve:
            writeInt(&buf, Int32(1))
        
        
        case .twentyFour:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNumberOfBip39Words_lift(_ buf: RustBuffer) throws -> NumberOfBip39Words {
    return try FfiConverterTypeNumberOfBip39Words.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNumberOfBip39Words_lower(_ value: NumberOfBip39Words) -> RustBuffer {
    return FfiConverterTypeNumberOfBip39Words.lower(value)
}



extension NumberOfBip39Words: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ParseResult {
    
    /**
     * Completed The message is a NDEF message
     */
    case complete(MessageInfo,[NdefRecord]
    )
    /**
     * Incomplete, need more data to parse the message
     */
    case incomplete(ParsingMessage
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParseResult: FfiConverterRustBuffer {
    typealias SwiftType = ParseResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .complete(try FfiConverterTypeMessageInfo.read(from: &buf), try FfiConverterSequenceTypeNdefRecord.read(from: &buf)
        )
        
        case 2: return .incomplete(try FfiConverterTypeParsingMessage.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParseResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .complete(v1,v2):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMessageInfo.write(v1, into: &buf)
            FfiConverterSequenceTypeNdefRecord.write(v2, into: &buf)
            
        
        case let .incomplete(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeParsingMessage.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseResult_lift(_ buf: RustBuffer) throws -> ParseResult {
    return try FfiConverterTypeParseResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseResult_lower(_ value: ParseResult) -> RustBuffer {
    return FfiConverterTypeParseResult.lower(value)
}



extension ParseResult: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ParserState {
    
    case notStarted
    case parsing(ParsingContext
    )
    case complete
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParserState: FfiConverterRustBuffer {
    typealias SwiftType = ParserState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParserState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notStarted
        
        case 2: return .parsing(try FfiConverterTypeParsingContext.read(from: &buf)
        )
        
        case 3: return .complete
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParserState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notStarted:
            writeInt(&buf, Int32(1))
        
        
        case let .parsing(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeParsingContext.write(v1, into: &buf)
            
        
        case .complete:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParserState_lift(_ buf: RustBuffer) throws -> ParserState {
    return try FfiConverterTypeParserState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParserState_lower(_ value: ParserState) -> RustBuffer {
    return FfiConverterTypeParserState.lower(value)
}



extension ParserState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingOrConfirmed {
    
    case pending(PendingDetails
    )
    case confirmed(ConfirmedDetails
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingOrConfirmed: FfiConverterRustBuffer {
    typealias SwiftType = PendingOrConfirmed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingOrConfirmed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending(try FfiConverterTypePendingDetails.read(from: &buf)
        )
        
        case 2: return .confirmed(try FfiConverterTypeConfirmedDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingOrConfirmed, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pending(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypePendingDetails.write(v1, into: &buf)
            
        
        case let .confirmed(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeConfirmedDetails.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingOrConfirmed_lift(_ buf: RustBuffer) throws -> PendingOrConfirmed {
    return try FfiConverterTypePendingOrConfirmed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingOrConfirmed_lower(_ value: PendingOrConfirmed) -> RustBuffer {
    return FfiConverterTypePendingOrConfirmed.lower(value)
}



extension PendingOrConfirmed: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingWalletManagerAction {
    
    case updateWords(NumberOfBip39Words
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingWalletManagerAction: FfiConverterRustBuffer {
    typealias SwiftType = PendingWalletManagerAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletManagerAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .updateWords(try FfiConverterTypeNumberOfBip39Words.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingWalletManagerAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .updateWords(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerAction_lift(_ buf: RustBuffer) throws -> PendingWalletManagerAction {
    return try FfiConverterTypePendingWalletManagerAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerAction_lower(_ value: PendingWalletManagerAction) -> RustBuffer {
    return FfiConverterTypePendingWalletManagerAction.lower(value)
}



extension PendingWalletManagerAction: Equatable, Hashable {}




public enum PendingWalletManagerError {

    
    
    case BdkError(String
    )
    case WalletCreationError(WalletCreationError
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingWalletManagerError: FfiConverterRustBuffer {
    typealias SwiftType = PendingWalletManagerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletManagerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BdkError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .WalletCreationError(
            try FfiConverterTypeWalletCreationError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingWalletManagerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BdkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .WalletCreationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletCreationError.write(v1, into: &buf)
            
        }
    }
}


extension PendingWalletManagerError: Equatable, Hashable {}

extension PendingWalletManagerError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingWalletManagerReconcileMessage {
    
    case words(NumberOfBip39Words
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingWalletManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = PendingWalletManagerReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletManagerReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .words(try FfiConverterTypeNumberOfBip39Words.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingWalletManagerReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .words(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerReconcileMessage_lift(_ buf: RustBuffer) throws -> PendingWalletManagerReconcileMessage {
    return try FfiConverterTypePendingWalletManagerReconcileMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerReconcileMessage_lower(_ value: PendingWalletManagerReconcileMessage) -> RustBuffer {
    return FfiConverterTypePendingWalletManagerReconcileMessage.lower(value)
}



extension PendingWalletManagerReconcileMessage: Equatable, Hashable {}




public enum PsbtError {

    
    
    /**
     * Missing UTXO
     */
    case MissingUtxo
    /**
     * Negative fee.
     */
    case NegativeFee
    /**
     * Fee overflow.
     */
    case FeeOverflow
    /**
     * Other PSBT error {0}
     */
    case Other(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbtError: FfiConverterRustBuffer {
    typealias SwiftType = PsbtError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PsbtError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingUtxo
        case 2: return .NegativeFee
        case 3: return .FeeOverflow
        case 4: return .Other(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PsbtError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .MissingUtxo:
            writeInt(&buf, Int32(1))
        
        
        case .NegativeFee:
            writeInt(&buf, Int32(2))
        
        
        case .FeeOverflow:
            writeInt(&buf, Int32(3))
        
        
        case let .Other(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension PsbtError: Equatable, Hashable {}

extension PsbtError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum ResumeError {

    
    
    /**
     * Blocks do not match
     *
     * The starting block of the new message is not the same as the one in the old message
     */
    case BlocksDoNotMatch
    /**
     * The reader had already parsed the message
     */
    case AlreadyParsed
    /**
     * Parsing error, error getting message info: {0}
     */
    case ParsingError(String
    )
    /**
     * Block size mismatch, expected {expected}, got {actual}
     *
     * The bytes passed in needs to be a multiple of crate::cove_nfc::BYTES_PER_BLOCK
     * The bytes passed in needs to be the same size as the bytes in the old message (NUMBER_OF_BLOCKS_PER_CHUNK * BYTES_PER_BLOCK)
     */
    case BlockSizeMismatch(expected: UInt16, actual: UInt16
    )
    /**
     * Unable to get first block hash
     */
    case UnableToGetFirstBlockHash
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResumeError: FfiConverterRustBuffer {
    typealias SwiftType = ResumeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResumeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BlocksDoNotMatch
        case 2: return .AlreadyParsed
        case 3: return .ParsingError(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .BlockSizeMismatch(
            expected: try FfiConverterUInt16.read(from: &buf), 
            actual: try FfiConverterUInt16.read(from: &buf)
            )
        case 5: return .UnableToGetFirstBlockHash

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResumeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .BlocksDoNotMatch:
            writeInt(&buf, Int32(1))
        
        
        case .AlreadyParsed:
            writeInt(&buf, Int32(2))
        
        
        case let .ParsingError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .BlockSizeMismatch(expected,actual):
            writeInt(&buf, Int32(4))
            FfiConverterUInt16.write(expected, into: &buf)
            FfiConverterUInt16.write(actual, into: &buf)
            
        
        case .UnableToGetFirstBlockHash:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension ResumeError: Equatable, Hashable {}

extension ResumeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Route {
    
    case loadAndReset(resetTo: [BoxedRoute], afterMillis: UInt32
    )
    case listWallets
    case selectedWallet(WalletId
    )
    case walletSettings(WalletId
    )
    case newWallet(NewWalletRoute
    )
    case settings
    case secretWords(WalletId
    )
    case transactionDetails(id: WalletId, details: TransactionDetails
    )
    case send(SendRoute
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoute: FfiConverterRustBuffer {
    typealias SwiftType = Route

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Route {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .loadAndReset(resetTo: try FfiConverterSequenceTypeBoxedRoute.read(from: &buf), afterMillis: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 2: return .listWallets
        
        case 3: return .selectedWallet(try FfiConverterTypeWalletId.read(from: &buf)
        )
        
        case 4: return .walletSettings(try FfiConverterTypeWalletId.read(from: &buf)
        )
        
        case 5: return .newWallet(try FfiConverterTypeNewWalletRoute.read(from: &buf)
        )
        
        case 6: return .settings
        
        case 7: return .secretWords(try FfiConverterTypeWalletId.read(from: &buf)
        )
        
        case 8: return .transactionDetails(id: try FfiConverterTypeWalletId.read(from: &buf), details: try FfiConverterTypeTransactionDetails.read(from: &buf)
        )
        
        case 9: return .send(try FfiConverterTypeSendRoute.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Route, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .loadAndReset(resetTo,afterMillis):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeBoxedRoute.write(resetTo, into: &buf)
            FfiConverterUInt32.write(afterMillis, into: &buf)
            
        
        case .listWallets:
            writeInt(&buf, Int32(2))
        
        
        case let .selectedWallet(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        
        case let .walletSettings(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        
        case let .newWallet(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeNewWalletRoute.write(v1, into: &buf)
            
        
        case .settings:
            writeInt(&buf, Int32(6))
        
        
        case let .secretWords(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        
        case let .transactionDetails(id,details):
            writeInt(&buf, Int32(8))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterTypeTransactionDetails.write(details, into: &buf)
            
        
        case let .send(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeSendRoute.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoute_lift(_ buf: RustBuffer) throws -> Route {
    return try FfiConverterTypeRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoute_lower(_ value: Route) -> RustBuffer {
    return FfiConverterTypeRoute.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ScanState {
    
    case notStarted
    case scanning(ScanningInfo
    )
    case completed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScanState: FfiConverterRustBuffer {
    typealias SwiftType = ScanState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScanState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notStarted
        
        case 2: return .scanning(try FfiConverterTypeScanningInfo.read(from: &buf)
        )
        
        case 3: return .completed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScanState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notStarted:
            writeInt(&buf, Int32(1))
        
        
        case let .scanning(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeScanningInfo.write(v1, into: &buf)
            
        
        case .completed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanState_lift(_ buf: RustBuffer) throws -> ScanState {
    return try FfiConverterTypeScanState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanState_lower(_ value: ScanState) -> RustBuffer {
    return FfiConverterTypeScanState.lower(value)
}



extension ScanState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ScannerResponse {
    
    case foundAddresses([FoundAddress]
    )
    case noneFound
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScannerResponse: FfiConverterRustBuffer {
    typealias SwiftType = ScannerResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScannerResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .foundAddresses(try FfiConverterSequenceTypeFoundAddress.read(from: &buf)
        )
        
        case 2: return .noneFound
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScannerResponse, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .foundAddresses(v1):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeFoundAddress.write(v1, into: &buf)
            
        
        case .noneFound:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScannerResponse_lift(_ buf: RustBuffer) throws -> ScannerResponse {
    return try FfiConverterTypeScannerResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScannerResponse_lower(_ value: ScannerResponse) -> RustBuffer {
    return FfiConverterTypeScannerResponse.lower(value)
}



extension ScannerResponse: Equatable, Hashable {}




public enum SeedQrError {

    
    
    case ContainsNonNumericChars
    case IndexOutOfBounds(UInt16
    )
    case IncorrectWordLength(UInt16
    )
    case InvalidMnemonic(Bip39Error
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSeedQrError: FfiConverterRustBuffer {
    typealias SwiftType = SeedQrError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SeedQrError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ContainsNonNumericChars
        case 2: return .IndexOutOfBounds(
            try FfiConverterUInt16.read(from: &buf)
            )
        case 3: return .IncorrectWordLength(
            try FfiConverterUInt16.read(from: &buf)
            )
        case 4: return .InvalidMnemonic(
            try FfiConverterTypeBip39Error.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SeedQrError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .ContainsNonNumericChars:
            writeInt(&buf, Int32(1))
        
        
        case let .IndexOutOfBounds(v1):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(v1, into: &buf)
            
        
        case let .IncorrectWordLength(v1):
            writeInt(&buf, Int32(3))
            FfiConverterUInt16.write(v1, into: &buf)
            
        
        case let .InvalidMnemonic(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBip39Error.write(v1, into: &buf)
            
        }
    }
}


extension SeedQrError: Equatable, Hashable {}

extension SeedQrError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendRoute {
    
    case setAmount(id: WalletId, address: Address?, amount: Amount?
    )
    case hardwareExport(id: WalletId, details: ConfirmDetails
    )
    case confirm(id: WalletId, details: ConfirmDetails
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendRoute: FfiConverterRustBuffer {
    typealias SwiftType = SendRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .setAmount(id: try FfiConverterTypeWalletId.read(from: &buf), address: try FfiConverterOptionTypeAddress.read(from: &buf), amount: try FfiConverterOptionTypeAmount.read(from: &buf)
        )
        
        case 2: return .hardwareExport(id: try FfiConverterTypeWalletId.read(from: &buf), details: try FfiConverterTypeConfirmDetails.read(from: &buf)
        )
        
        case 3: return .confirm(id: try FfiConverterTypeWalletId.read(from: &buf), details: try FfiConverterTypeConfirmDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .setAmount(id,address,amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterOptionTypeAddress.write(address, into: &buf)
            FfiConverterOptionTypeAmount.write(amount, into: &buf)
            
        
        case let .hardwareExport(id,details):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterTypeConfirmDetails.write(details, into: &buf)
            
        
        case let .confirm(id,details):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterTypeConfirmDetails.write(details, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendRoute_lift(_ buf: RustBuffer) throws -> SendRoute {
    return try FfiConverterTypeSendRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendRoute_lower(_ value: SendRoute) -> RustBuffer {
    return FfiConverterTypeSendRoute.lower(value)
}





public enum SerdeError {

    
    
    case SerializationError(String
    )
    case DeserializationError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSerdeError: FfiConverterRustBuffer {
    typealias SwiftType = SerdeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SerdeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SerializationError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .DeserializationError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SerdeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SerializationError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .DeserializationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension SerdeError: Equatable, Hashable {}

extension SerdeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum StringOrData {
    
    case string(String
    )
    case data(Data
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStringOrData: FfiConverterRustBuffer {
    typealias SwiftType = StringOrData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StringOrData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .string(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .data(try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StringOrData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .string(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .data(v1):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStringOrData_lift(_ buf: RustBuffer) throws -> StringOrData {
    return try FfiConverterTypeStringOrData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStringOrData_lower(_ value: StringOrData) -> RustBuffer {
    return FfiConverterTypeStringOrData.lower(value)
}



extension StringOrData: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TextPayloadFormat {
    
    case utf8
    case utf16
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTextPayloadFormat: FfiConverterRustBuffer {
    typealias SwiftType = TextPayloadFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TextPayloadFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .utf8
        
        case 2: return .utf16
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TextPayloadFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .utf8:
            writeInt(&buf, Int32(1))
        
        
        case .utf16:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTextPayloadFormat_lift(_ buf: RustBuffer) throws -> TextPayloadFormat {
    return try FfiConverterTypeTextPayloadFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTextPayloadFormat_lower(_ value: TextPayloadFormat) -> RustBuffer {
    return FfiConverterTypeTextPayloadFormat.lower(value)
}



extension TextPayloadFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Transaction {
    
    case confirmed(ConfirmedTransaction
    )
    case unconfirmed(UnconfirmedTransaction
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = Transaction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transaction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .confirmed(try FfiConverterTypeConfirmedTransaction.read(from: &buf)
        )
        
        case 2: return .unconfirmed(try FfiConverterTypeUnconfirmedTransaction.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Transaction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .confirmed(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeConfirmedTransaction.write(v1, into: &buf)
            
        
        case let .unconfirmed(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUnconfirmedTransaction.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lift(_ buf: RustBuffer) throws -> Transaction {
    return try FfiConverterTypeTransaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lower(_ value: Transaction) -> RustBuffer {
    return FfiConverterTypeTransaction.lower(value)
}





public enum TransactionDetailError {

    
    
    case Fee(String
    )
    case FeeRate(String
    )
    case Address(AddressError
    )
    case FiatAmount(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionDetailError: FfiConverterRustBuffer {
    typealias SwiftType = TransactionDetailError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDetailError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Fee(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .FeeRate(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Address(
            try FfiConverterTypeAddressError.read(from: &buf)
            )
        case 4: return .FiatAmount(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionDetailError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Fee(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .FeeRate(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Address(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAddressError.write(v1, into: &buf)
            
        
        case let .FiatAmount(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension TransactionDetailError: Equatable, Hashable {}

extension TransactionDetailError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionDirection {
    
    case incoming
    case outgoing
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionDirection: FfiConverterRustBuffer {
    typealias SwiftType = TransactionDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .incoming
        
        case 2: return .outgoing
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .incoming:
            writeInt(&buf, Int32(1))
        
        
        case .outgoing:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDirection_lift(_ buf: RustBuffer) throws -> TransactionDirection {
    return try FfiConverterTypeTransactionDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDirection_lower(_ value: TransactionDirection) -> RustBuffer {
    return FfiConverterTypeTransactionDirection.lower(value)
}



extension TransactionDirection: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionState {
    
    case pending
    case confirmed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionState: FfiConverterRustBuffer {
    typealias SwiftType = TransactionState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending
        
        case 2: return .confirmed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pending:
            writeInt(&buf, Int32(1))
        
        
        case .confirmed:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionState_lift(_ buf: RustBuffer) throws -> TransactionState {
    return try FfiConverterTypeTransactionState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionState_lower(_ value: TransactionState) -> RustBuffer {
    return FfiConverterTypeTransactionState.lower(value)
}



extension TransactionState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Unit {
    
    case btc
    case sat
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnit: FfiConverterRustBuffer {
    typealias SwiftType = Unit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .btc
        
        case 2: return .sat
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Unit, into buf: inout [UInt8]) {
        switch value {
        
        
        case .btc:
            writeInt(&buf, Int32(1))
        
        
        case .sat:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnit_lift(_ buf: RustBuffer) throws -> Unit {
    return try FfiConverterTypeUnit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnit_lower(_ value: Unit) -> RustBuffer {
    return FfiConverterTypeUnit.lower(value)
}



extension Unit: Equatable, Hashable {}




public enum UnsignedTransactionsTableError {

    
    
    case Save(String
    )
    case Read(String
    )
    case NoRecordFound
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsignedTransactionsTableError: FfiConverterRustBuffer {
    typealias SwiftType = UnsignedTransactionsTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedTransactionsTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Save(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Read(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .NoRecordFound

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UnsignedTransactionsTableError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Save(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Read(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .NoRecordFound:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension UnsignedTransactionsTableError: Equatable, Hashable {}

extension UnsignedTransactionsTableError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletAddressType {
    
    case nativeSegwit
    case wrappedSegwit
    case legacy
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletAddressType: FfiConverterRustBuffer {
    typealias SwiftType = WalletAddressType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletAddressType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nativeSegwit
        
        case 2: return .wrappedSegwit
        
        case 3: return .legacy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletAddressType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nativeSegwit:
            writeInt(&buf, Int32(1))
        
        
        case .wrappedSegwit:
            writeInt(&buf, Int32(2))
        
        
        case .legacy:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletAddressType_lift(_ buf: RustBuffer) throws -> WalletAddressType {
    return try FfiConverterTypeWalletAddressType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletAddressType_lower(_ value: WalletAddressType) -> RustBuffer {
    return FfiConverterTypeWalletAddressType.lower(value)
}



extension WalletAddressType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletColor {
    
    case red
    case blue
    case green
    case yellow
    case orange
    case purple
    case pink
    case custom(r: UInt8, g: UInt8, b: UInt8
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletColor: FfiConverterRustBuffer {
    typealias SwiftType = WalletColor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletColor {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .red
        
        case 2: return .blue
        
        case 3: return .green
        
        case 4: return .yellow
        
        case 5: return .orange
        
        case 6: return .purple
        
        case 7: return .pink
        
        case 8: return .custom(r: try FfiConverterUInt8.read(from: &buf), g: try FfiConverterUInt8.read(from: &buf), b: try FfiConverterUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletColor, into buf: inout [UInt8]) {
        switch value {
        
        
        case .red:
            writeInt(&buf, Int32(1))
        
        
        case .blue:
            writeInt(&buf, Int32(2))
        
        
        case .green:
            writeInt(&buf, Int32(3))
        
        
        case .yellow:
            writeInt(&buf, Int32(4))
        
        
        case .orange:
            writeInt(&buf, Int32(5))
        
        
        case .purple:
            writeInt(&buf, Int32(6))
        
        
        case .pink:
            writeInt(&buf, Int32(7))
        
        
        case let .custom(r,g,b):
            writeInt(&buf, Int32(8))
            FfiConverterUInt8.write(r, into: &buf)
            FfiConverterUInt8.write(g, into: &buf)
            FfiConverterUInt8.write(b, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletColor_lift(_ buf: RustBuffer) throws -> WalletColor {
    return try FfiConverterTypeWalletColor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletColor_lower(_ value: WalletColor) -> RustBuffer {
    return FfiConverterTypeWalletColor.lower(value)
}



extension WalletColor: Equatable, Hashable {}




public enum WalletCreationError {

    
    
    case Bdk(String
    )
    case Keychain(KeychainError
    )
    case Database(DatabaseError
    )
    case Persist(String
    )
    case Import(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletCreationError: FfiConverterRustBuffer {
    typealias SwiftType = WalletCreationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletCreationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Bdk(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Keychain(
            try FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 3: return .Database(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 4: return .Persist(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Import(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletCreationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Bdk(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Keychain(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeKeychainError.write(v1, into: &buf)
            
        
        case let .Database(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        
        case let .Persist(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Import(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension WalletCreationError: Equatable, Hashable {}

extension WalletCreationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum WalletDataError {

    
    
    case DatabaseAccess(id: WalletId, error: String
    )
    case TableAccess(id: WalletId, error: String
    )
    /**
     * Unable to read: {0}
     */
    case Read(String
    )
    /**
     * Unable to save: {0}
     */
    case Save(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletDataError: FfiConverterRustBuffer {
    typealias SwiftType = WalletDataError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletDataError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DatabaseAccess(
            id: try FfiConverterTypeWalletId.read(from: &buf), 
            error: try FfiConverterString.read(from: &buf)
            )
        case 2: return .TableAccess(
            id: try FfiConverterTypeWalletId.read(from: &buf), 
            error: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Read(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Save(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletDataError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .DatabaseAccess(id,error):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterString.write(error, into: &buf)
            
        
        case let .TableAccess(id,error):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterString.write(error, into: &buf)
            
        
        case let .Read(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Save(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension WalletDataError: Equatable, Hashable {}

extension WalletDataError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletDataKey {
    
    case scanState(WalletAddressType
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletDataKey: FfiConverterRustBuffer {
    typealias SwiftType = WalletDataKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletDataKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .scanState(try FfiConverterTypeWalletAddressType.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletDataKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .scanState(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletAddressType.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletDataKey_lift(_ buf: RustBuffer) throws -> WalletDataKey {
    return try FfiConverterTypeWalletDataKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletDataKey_lower(_ value: WalletDataKey) -> RustBuffer {
    return FfiConverterTypeWalletDataKey.lower(value)
}



extension WalletDataKey: Equatable, Hashable {}




public enum WalletError {

    
    
    case BdkError(String
    )
    case UnsupportedWallet(String
    )
    case PersistError(String
    )
    case LoadError(String
    )
    case KeychainError(KeychainError
    )
    case DatabaseError(DatabaseError
    )
    case WalletNotFound
    case MetadataNotFound
    case ParseXpubError(XpubError
    )
    case WalletAlreadyExists(WalletId
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletError: FfiConverterRustBuffer {
    typealias SwiftType = WalletError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BdkError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .UnsupportedWallet(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .PersistError(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .LoadError(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .KeychainError(
            try FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 6: return .DatabaseError(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 7: return .WalletNotFound
        case 8: return .MetadataNotFound
        case 9: return .ParseXpubError(
            try FfiConverterTypeXpubError.read(from: &buf)
            )
        case 10: return .WalletAlreadyExists(
            try FfiConverterTypeWalletId.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BdkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .UnsupportedWallet(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .PersistError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .LoadError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .KeychainError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeKeychainError.write(v1, into: &buf)
            
        
        case let .DatabaseError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        
        case .WalletNotFound:
            writeInt(&buf, Int32(7))
        
        
        case .MetadataNotFound:
            writeInt(&buf, Int32(8))
        
        
        case let .ParseXpubError(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeXpubError.write(v1, into: &buf)
            
        
        case let .WalletAlreadyExists(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        }
    }
}


extension WalletError: Equatable, Hashable {}

extension WalletError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletErrorAlert {
    
    case nodeConnectionFailed(String
    )
    case noBalance
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletErrorAlert: FfiConverterRustBuffer {
    typealias SwiftType = WalletErrorAlert

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletErrorAlert {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nodeConnectionFailed(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .noBalance
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletErrorAlert, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .nodeConnectionFailed(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .noBalance:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletErrorAlert_lift(_ buf: RustBuffer) throws -> WalletErrorAlert {
    return try FfiConverterTypeWalletErrorAlert.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletErrorAlert_lower(_ value: WalletErrorAlert) -> RustBuffer {
    return FfiConverterTypeWalletErrorAlert.lower(value)
}



extension WalletErrorAlert: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletLoadState {
    
    case loading
    case scanning([Transaction]
    )
    case loaded([Transaction]
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletLoadState: FfiConverterRustBuffer {
    typealias SwiftType = WalletLoadState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletLoadState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .loading
        
        case 2: return .scanning(try FfiConverterSequenceTypeTransaction.read(from: &buf)
        )
        
        case 3: return .loaded(try FfiConverterSequenceTypeTransaction.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletLoadState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .loading:
            writeInt(&buf, Int32(1))
        
        
        case let .scanning(v1):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)
            
        
        case let .loaded(v1):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletLoadState_lift(_ buf: RustBuffer) throws -> WalletLoadState {
    return try FfiConverterTypeWalletLoadState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletLoadState_lower(_ value: WalletLoadState) -> RustBuffer {
    return FfiConverterTypeWalletLoadState.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletManagerAction {
    
    case updateName(String
    )
    case updateColor(WalletColor
    )
    case updateUnit(Unit
    )
    case updateFiatCurrency(FiatCurrency
    )
    case updateFiatOrBtc(FiatOrBtc
    )
    case toggleSensitiveVisibility
    case toggleDetailsExpanded
    case toggleFiatOrBtc
    case toggleFiatBtcPrimarySecondary
    case selectCurrentWalletAddressType
    case selectDifferentWalletAddressType(WalletAddressType
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletManagerAction: FfiConverterRustBuffer {
    typealias SwiftType = WalletManagerAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletManagerAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .updateName(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .updateColor(try FfiConverterTypeWalletColor.read(from: &buf)
        )
        
        case 3: return .updateUnit(try FfiConverterTypeUnit.read(from: &buf)
        )
        
        case 4: return .updateFiatCurrency(try FfiConverterTypeFiatCurrency.read(from: &buf)
        )
        
        case 5: return .updateFiatOrBtc(try FfiConverterTypeFiatOrBtc.read(from: &buf)
        )
        
        case 6: return .toggleSensitiveVisibility
        
        case 7: return .toggleDetailsExpanded
        
        case 8: return .toggleFiatOrBtc
        
        case 9: return .toggleFiatBtcPrimarySecondary
        
        case 10: return .selectCurrentWalletAddressType
        
        case 11: return .selectDifferentWalletAddressType(try FfiConverterTypeWalletAddressType.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletManagerAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .updateName(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .updateColor(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletColor.write(v1, into: &buf)
            
        
        case let .updateUnit(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUnit.write(v1, into: &buf)
            
        
        case let .updateFiatCurrency(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeFiatCurrency.write(v1, into: &buf)
            
        
        case let .updateFiatOrBtc(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFiatOrBtc.write(v1, into: &buf)
            
        
        case .toggleSensitiveVisibility:
            writeInt(&buf, Int32(6))
        
        
        case .toggleDetailsExpanded:
            writeInt(&buf, Int32(7))
        
        
        case .toggleFiatOrBtc:
            writeInt(&buf, Int32(8))
        
        
        case .toggleFiatBtcPrimarySecondary:
            writeInt(&buf, Int32(9))
        
        
        case .selectCurrentWalletAddressType:
            writeInt(&buf, Int32(10))
        
        
        case let .selectDifferentWalletAddressType(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeWalletAddressType.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletManagerAction_lift(_ buf: RustBuffer) throws -> WalletManagerAction {
    return try FfiConverterTypeWalletManagerAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletManagerAction_lower(_ value: WalletManagerAction) -> RustBuffer {
    return FfiConverterTypeWalletManagerAction.lower(value)
}



extension WalletManagerAction: Equatable, Hashable {}




public enum WalletManagerError {

    
    
    case GetSelectedWalletError(String
    )
    case WalletDoesNotExist
    case SecretRetrievalError(KeychainError
    )
    case MarkWalletAsVerifiedError(DatabaseError
    )
    case LoadWalletError(WalletError
    )
    case NodeConnectionFailed(String
    )
    case WalletScanError(String
    )
    case TransactionsRetrievalError(String
    )
    case WalletBalanceError(String
    )
    case NextAddressError(String
    )
    case GetHeightError
    case TransactionDetailsError(String
    )
    case ActorNotFound
    case UnableToSwitch(WalletAddressType,String
    )
    case FiatError(String
    )
    case FeesError(String
    )
    case BuildTxError(String
    )
    case InsufficientFunds(String
    )
    case GetConfirmDetailsError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletManagerError: FfiConverterRustBuffer {
    typealias SwiftType = WalletManagerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletManagerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .GetSelectedWalletError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .WalletDoesNotExist
        case 3: return .SecretRetrievalError(
            try FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 4: return .MarkWalletAsVerifiedError(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 5: return .LoadWalletError(
            try FfiConverterTypeWalletError.read(from: &buf)
            )
        case 6: return .NodeConnectionFailed(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .WalletScanError(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .TransactionsRetrievalError(
            try FfiConverterString.read(from: &buf)
            )
        case 9: return .WalletBalanceError(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .NextAddressError(
            try FfiConverterString.read(from: &buf)
            )
        case 11: return .GetHeightError
        case 12: return .TransactionDetailsError(
            try FfiConverterString.read(from: &buf)
            )
        case 13: return .ActorNotFound
        case 14: return .UnableToSwitch(
            try FfiConverterTypeWalletAddressType.read(from: &buf), 
            try FfiConverterString.read(from: &buf)
            )
        case 15: return .FiatError(
            try FfiConverterString.read(from: &buf)
            )
        case 16: return .FeesError(
            try FfiConverterString.read(from: &buf)
            )
        case 17: return .BuildTxError(
            try FfiConverterString.read(from: &buf)
            )
        case 18: return .InsufficientFunds(
            try FfiConverterString.read(from: &buf)
            )
        case 19: return .GetConfirmDetailsError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletManagerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .GetSelectedWalletError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .WalletDoesNotExist:
            writeInt(&buf, Int32(2))
        
        
        case let .SecretRetrievalError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeKeychainError.write(v1, into: &buf)
            
        
        case let .MarkWalletAsVerifiedError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        
        case let .LoadWalletError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeWalletError.write(v1, into: &buf)
            
        
        case let .NodeConnectionFailed(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .WalletScanError(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .TransactionsRetrievalError(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .WalletBalanceError(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NextAddressError(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .GetHeightError:
            writeInt(&buf, Int32(11))
        
        
        case let .TransactionDetailsError(v1):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .ActorNotFound:
            writeInt(&buf, Int32(13))
        
        
        case let .UnableToSwitch(v1,v2):
            writeInt(&buf, Int32(14))
            FfiConverterTypeWalletAddressType.write(v1, into: &buf)
            FfiConverterString.write(v2, into: &buf)
            
        
        case let .FiatError(v1):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .FeesError(v1):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .BuildTxError(v1):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InsufficientFunds(v1):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .GetConfirmDetailsError(v1):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension WalletManagerError: Equatable, Hashable {}

extension WalletManagerError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletManagerReconcileMessage {
    
    case startedWalletScan
    case availableTransactions([Transaction]
    )
    case scanComplete([Transaction]
    )
    case nodeConnectionFailed(String
    )
    case walletMetadataChanged(WalletMetadata
    )
    case walletBalanceChanged(Balance
    )
    case walletError(WalletManagerError
    )
    case unknownError(String
    )
    case walletScannerResponse(ScannerResponse
    )
    case unsignedTransactionsChanged
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = WalletManagerReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletManagerReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .startedWalletScan
        
        case 2: return .availableTransactions(try FfiConverterSequenceTypeTransaction.read(from: &buf)
        )
        
        case 3: return .scanComplete(try FfiConverterSequenceTypeTransaction.read(from: &buf)
        )
        
        case 4: return .nodeConnectionFailed(try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .walletMetadataChanged(try FfiConverterTypeWalletMetadata.read(from: &buf)
        )
        
        case 6: return .walletBalanceChanged(try FfiConverterTypeBalance.read(from: &buf)
        )
        
        case 7: return .walletError(try FfiConverterTypeWalletManagerError.read(from: &buf)
        )
        
        case 8: return .unknownError(try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .walletScannerResponse(try FfiConverterTypeScannerResponse.read(from: &buf)
        )
        
        case 10: return .unsignedTransactionsChanged
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletManagerReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case .startedWalletScan:
            writeInt(&buf, Int32(1))
        
        
        case let .availableTransactions(v1):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)
            
        
        case let .scanComplete(v1):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)
            
        
        case let .nodeConnectionFailed(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .walletMetadataChanged(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeWalletMetadata.write(v1, into: &buf)
            
        
        case let .walletBalanceChanged(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeBalance.write(v1, into: &buf)
            
        
        case let .walletError(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeWalletManagerError.write(v1, into: &buf)
            
        
        case let .unknownError(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .walletScannerResponse(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeScannerResponse.write(v1, into: &buf)
            
        
        case .unsignedTransactionsChanged:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletManagerReconcileMessage_lift(_ buf: RustBuffer) throws -> WalletManagerReconcileMessage {
    return try FfiConverterTypeWalletManagerReconcileMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletManagerReconcileMessage_lower(_ value: WalletManagerReconcileMessage) -> RustBuffer {
    return FfiConverterTypeWalletManagerReconcileMessage.lower(value)
}





public enum WalletScannerError {

    
    
    /**
     * No address types to scan
     */
    case NoAddressTypes
    /**
     * Unable to create wallet
     */
    case WalletCreationError(WalletError
    )
    /**
     * No mnemonic available for id {0}
     */
    case NoMnemonicAvailable(WalletId
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletScannerError: FfiConverterRustBuffer {
    typealias SwiftType = WalletScannerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletScannerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NoAddressTypes
        case 2: return .WalletCreationError(
            try FfiConverterTypeWalletError.read(from: &buf)
            )
        case 3: return .NoMnemonicAvailable(
            try FfiConverterTypeWalletId.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletScannerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .NoAddressTypes:
            writeInt(&buf, Int32(1))
        
        
        case let .WalletCreationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletError.write(v1, into: &buf)
            
        
        case let .NoMnemonicAvailable(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        }
    }
}


extension WalletScannerError: Equatable, Hashable {}

extension WalletScannerError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum WalletTableError {

    
    
    case SaveError(String
    )
    case ReadError(String
    )
    case WalletAlreadyExists
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletTableError: FfiConverterRustBuffer {
    typealias SwiftType = WalletTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SaveError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .ReadError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .WalletAlreadyExists

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletTableError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SaveError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ReadError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .WalletAlreadyExists:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension WalletTableError: Equatable, Hashable {}

extension WalletTableError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletType {
    
    case hot
    case cold
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletType: FfiConverterRustBuffer {
    typealias SwiftType = WalletType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hot
        
        case 2: return .cold
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .hot:
            writeInt(&buf, Int32(1))
        
        
        case .cold:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletType_lift(_ buf: RustBuffer) throws -> WalletType {
    return try FfiConverterTypeWalletType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletType_lower(_ value: WalletType) -> RustBuffer {
    return FfiConverterTypeWalletType.lower(value)
}



extension WalletType: Equatable, Hashable {}




public enum XpubError {

    
    
    case InvalidDescriptor(DescriptorError
    )
    case InvalidJson(String
    )
    case InvalidDescriptorInJson
    case JsonNoDecriptor
    case MissingXpub(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeXpubError: FfiConverterRustBuffer {
    typealias SwiftType = XpubError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> XpubError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidDescriptor(
            try FfiConverterTypeDescriptorError.read(from: &buf)
            )
        case 2: return .InvalidJson(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidDescriptorInJson
        case 4: return .JsonNoDecriptor
        case 5: return .MissingXpub(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: XpubError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidDescriptor(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDescriptorError.write(v1, into: &buf)
            
        
        case let .InvalidJson(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InvalidDescriptorInJson:
            writeInt(&buf, Int32(3))
        
        
        case .JsonNoDecriptor:
            writeInt(&buf, Int32(4))
        
        
        case let .MissingXpub(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension XpubError: Equatable, Hashable {}

extension XpubError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




public protocol DeviceAccess : AnyObject {
    
    func timezone()  -> String
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceDeviceAccess {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceDeviceAccess] = [UniffiVTableCallbackInterfaceDeviceAccess(
        timezone: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceDeviceAccess.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.timezone(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceDeviceAccess.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface DeviceAccess: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitDeviceAccess() {
    uniffi_cove_fn_init_callback_vtable_deviceaccess(UniffiCallbackInterfaceDeviceAccess.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceDeviceAccess {
    fileprivate static let handleMap = UniffiHandleMap<DeviceAccess>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceDeviceAccess : FfiConverter {
    typealias SwiftType = DeviceAccess
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol FfiReconcile : AnyObject {
    
    /**
     * Essentially a callback to the frontend
     */
    func reconcile(message: AppStateReconcileMessage) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiReconcile {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiReconcile] = [UniffiVTableCallbackInterfaceFfiReconcile(
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceFfiReconcile.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcile(
                     message: try FfiConverterTypeAppStateReconcileMessage.lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceFfiReconcile.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiReconcile: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiReconcile() {
    uniffi_cove_fn_init_callback_vtable_ffireconcile(UniffiCallbackInterfaceFfiReconcile.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceFfiReconcile {
    fileprivate static let handleMap = UniffiHandleMap<FfiReconcile>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceFfiReconcile : FfiConverter {
    typealias SwiftType = FfiReconcile
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol ImportWalletManagerReconciler : AnyObject {
    
    /**
     * Tells the frontend to reconcile the view model changes
     */
    func reconcile(message: ImportWalletManagerReconcileMessage) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceImportWalletManagerReconciler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceImportWalletManagerReconciler] = [UniffiVTableCallbackInterfaceImportWalletManagerReconciler(
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceImportWalletManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcile(
                     message: try FfiConverterTypeImportWalletManagerReconcileMessage.lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceImportWalletManagerReconciler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ImportWalletManagerReconciler: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitImportWalletManagerReconciler() {
    uniffi_cove_fn_init_callback_vtable_importwalletmanagerreconciler(UniffiCallbackInterfaceImportWalletManagerReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceImportWalletManagerReconciler {
    fileprivate static let handleMap = UniffiHandleMap<ImportWalletManagerReconciler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceImportWalletManagerReconciler : FfiConverter {
    typealias SwiftType = ImportWalletManagerReconciler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol KeychainAccess : AnyObject {
    
    func save(key: String, value: String) throws 
    
    func get(key: String)  -> String?
    
    func delete(key: String)  -> Bool
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceKeychainAccess {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceKeychainAccess] = [UniffiVTableCallbackInterfaceKeychainAccess(
        save: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            value: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceKeychainAccess.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.save(
                     key: try FfiConverterString.lift(key),
                     value: try FfiConverterString.lift(value)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeKeychainError.lower
            )
        },
        get: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String? in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceKeychainAccess.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.get(
                     key: try FfiConverterString.lift(key)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        delete: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceKeychainAccess.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.delete(
                     key: try FfiConverterString.lift(key)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceKeychainAccess.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface KeychainAccess: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitKeychainAccess() {
    uniffi_cove_fn_init_callback_vtable_keychainaccess(UniffiCallbackInterfaceKeychainAccess.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceKeychainAccess {
    fileprivate static let handleMap = UniffiHandleMap<KeychainAccess>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceKeychainAccess : FfiConverter {
    typealias SwiftType = KeychainAccess
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol PendingWalletManagerReconciler : AnyObject {
    
    /**
     * Tells the frontend to reconcile the view model changes
     */
    func reconcile(message: PendingWalletManagerReconcileMessage) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePendingWalletManagerReconciler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfacePendingWalletManagerReconciler] = [UniffiVTableCallbackInterfacePendingWalletManagerReconciler(
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePendingWalletManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcile(
                     message: try FfiConverterTypePendingWalletManagerReconcileMessage.lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfacePendingWalletManagerReconciler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PendingWalletManagerReconciler: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitPendingWalletManagerReconciler() {
    uniffi_cove_fn_init_callback_vtable_pendingwalletmanagerreconciler(UniffiCallbackInterfacePendingWalletManagerReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfacePendingWalletManagerReconciler {
    fileprivate static let handleMap = UniffiHandleMap<PendingWalletManagerReconciler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfacePendingWalletManagerReconciler : FfiConverter {
    typealias SwiftType = PendingWalletManagerReconciler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol WalletManagerReconciler : AnyObject {
    
    /**
     * Tells the frontend to reconcile the view model changes
     */
    func reconcile(message: WalletManagerReconcileMessage) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceWalletManagerReconciler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceWalletManagerReconciler] = [UniffiVTableCallbackInterfaceWalletManagerReconciler(
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceWalletManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcile(
                     message: try FfiConverterTypeWalletManagerReconcileMessage.lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceWalletManagerReconciler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface WalletManagerReconciler: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitWalletManagerReconciler() {
    uniffi_cove_fn_init_callback_vtable_walletmanagerreconciler(UniffiCallbackInterfaceWalletManagerReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceWalletManagerReconciler {
    fileprivate static let handleMap = UniffiHandleMap<WalletManagerReconciler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceWalletManagerReconciler : FfiConverter {
    typealias SwiftType = WalletManagerReconciler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDuration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDuration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFeeRateOptions: FfiConverterRustBuffer {
    typealias SwiftType = FeeRateOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeeRateOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeRateOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFingerprint: FfiConverterRustBuffer {
    typealias SwiftType = Fingerprint?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFingerprint.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFingerprint.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUnsignedTransactionRecord: FfiConverterRustBuffer {
    typealias SwiftType = UnsignedTransactionRecord?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUnsignedTransactionRecord.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUnsignedTransactionRecord.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAddressIndex: FfiConverterRustBuffer {
    typealias SwiftType = AddressIndex?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAddressIndex.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAddressIndex.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBlockSizeLast: FfiConverterRustBuffer {
    typealias SwiftType = BlockSizeLast?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBlockSizeLast.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBlockSizeLast.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFeeResponse: FfiConverterRustBuffer {
    typealias SwiftType = FeeResponse?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeeResponse.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeResponse.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFiatAmount: FfiConverterRustBuffer {
    typealias SwiftType = FiatAmount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFiatAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFiatAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMessageInfo: FfiConverterRustBuffer {
    typealias SwiftType = MessageInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessageInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessageInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeNumberOfBip39Words: FfiConverterRustBuffer {
    typealias SwiftType = NumberOfBip39Words?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNumberOfBip39Words.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNumberOfBip39Words.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRoute: FfiConverterRustBuffer {
    typealias SwiftType = Route?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoute.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoute.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeWalletId: FfiConverterRustBuffer {
    typealias SwiftType = WalletId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBoxedRoute: FfiConverterRustBuffer {
    typealias SwiftType = [BoxedRoute]

    public static func write(_ value: [BoxedRoute], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBoxedRoute.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BoxedRoute] {
        let len: Int32 = try readInt(&buf)
        var seq = [BoxedRoute]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBoxedRoute.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUnsignedTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [UnsignedTransaction]

    public static func write(_ value: [UnsignedTransaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnsignedTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UnsignedTransaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [UnsignedTransaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnsignedTransaction.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFoundAddress: FfiConverterRustBuffer {
    typealias SwiftType = [FoundAddress]

    public static func write(_ value: [FoundAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFoundAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FoundAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [FoundAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFoundAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGroupedWord: FfiConverterRustBuffer {
    typealias SwiftType = [GroupedWord]

    public static func write(_ value: [GroupedWord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGroupedWord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GroupedWord] {
        let len: Int32 = try readInt(&buf)
        var seq = [GroupedWord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGroupedWord.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNdefRecord: FfiConverterRustBuffer {
    typealias SwiftType = [NdefRecord]

    public static func write(_ value: [NdefRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNdefRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NdefRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [NdefRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNdefRecord.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWalletMetadata: FfiConverterRustBuffer {
    typealias SwiftType = [WalletMetadata]

    public static func write(_ value: [WalletMetadata], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletMetadata.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletMetadata] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletMetadata]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWalletMetadata.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeColorSchemeSelection: FfiConverterRustBuffer {
    typealias SwiftType = [ColorSchemeSelection]

    public static func write(_ value: [ColorSchemeSelection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeColorSchemeSelection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ColorSchemeSelection] {
        let len: Int32 = try readInt(&buf)
        var seq = [ColorSchemeSelection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeColorSchemeSelection.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [Network]

    public static func write(_ value: [Network], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Network] {
        let len: Int32 = try readInt(&buf)
        var seq = [Network]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNetwork.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNodeSelection: FfiConverterRustBuffer {
    typealias SwiftType = [NodeSelection]

    public static func write(_ value: [NodeSelection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeSelection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeSelection] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeSelection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNodeSelection.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRoute: FfiConverterRustBuffer {
    typealias SwiftType = [Route]

    public static func write(_ value: [Route], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoute.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Route] {
        let len: Int32 = try readInt(&buf)
        var seq = [Route]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoute.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [Transaction]

    public static func write(_ value: [Transaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Transaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Transaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransaction.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUnit: FfiConverterRustBuffer {
    typealias SwiftType = [Unit]

    public static func write(_ value: [Unit], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnit.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Unit] {
        let len: Int32 = try readInt(&buf)
        var seq = [Unit]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnit.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]

    public static func write(_ value: [[String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceTypeGroupedWord: FfiConverterRustBuffer {
    typealias SwiftType = [[GroupedWord]]

    public static func write(_ value: [[GroupedWord]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypeGroupedWord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[GroupedWord]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[GroupedWord]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceTypeGroupedWord.read(from: &buf))
        }
        return seq
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias FfiOpacity = UInt8

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiOpacity: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiOpacity {
        return try FfiConverterUInt8.read(from: &buf)
    }

    public static func write(_ value: FfiOpacity, into buf: inout [UInt8]) {
        return FfiConverterUInt8.write(value, into: &buf)
    }

    public static func lift(_ value: UInt8) throws -> FfiOpacity {
        return try FfiConverterUInt8.lift(value)
    }

    public static func lower(_ value: FfiOpacity) -> UInt8 {
        return FfiConverterUInt8.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiOpacity_lift(_ value: UInt8) throws -> FfiOpacity {
    return try FfiConverterTypeFfiOpacity.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiOpacity_lower(_ value: FfiOpacity) -> UInt8 {
    return FfiConverterTypeFfiOpacity.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletId = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: WalletId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> WalletId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: WalletId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletId_lift(_ value: RustBuffer) throws -> WalletId {
    return try FfiConverterTypeWalletId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletId_lower(_ value: WalletId) -> RustBuffer {
    return FfiConverterTypeWalletId.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
public func addressIsEqual(lhs: Address, rhs: Address) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_address_is_equal(
        FfiConverterTypeAddress.lower(lhs),
        FfiConverterTypeAddress.lower(rhs),$0
    )
})
}
public func addressIsValid(address: String)throws   {try rustCallWithError(FfiConverterTypeAddressError.lift) {
    uniffi_cove_fn_func_address_is_valid(
        FfiConverterString.lower(address),$0
    )
}
}
public func addressIsValidForNetwork(address: String, network: Network)throws   {try rustCallWithError(FfiConverterTypeAddressError.lift) {
    uniffi_cove_fn_func_address_is_valid_for_network(
        FfiConverterString.lower(address),
        FfiConverterTypeNetwork.lower(network),$0
    )
}
}
public func addressStringSpacedOut(address: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_address_string_spaced_out(
        FfiConverterString.lower(address),$0
    )
})
}
public func allColorSchemes() -> [ColorSchemeSelection]  {
    return try!  FfiConverterSequenceTypeColorSchemeSelection.lift(try! rustCall() {
    uniffi_cove_fn_func_all_color_schemes($0
    )
})
}
public func allNetworks() -> [Network]  {
    return try!  FfiConverterSequenceTypeNetwork.lift(try! rustCall() {
    uniffi_cove_fn_func_all_networks($0
    )
})
}
public func allUnits() -> [Unit]  {
    return try!  FfiConverterSequenceTypeUnit.lift(try! rustCall() {
    uniffi_cove_fn_func_all_units($0
    )
})
}
public func balanceZero() -> Balance  {
    return try!  FfiConverterTypeBalance.lift(try! rustCall() {
    uniffi_cove_fn_func_balance_zero($0
    )
})
}
public func colorSchemeSelectionCapitalizedString(colorScheme: ColorSchemeSelection) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_color_scheme_selection_capitalized_string(
        FfiConverterTypeColorSchemeSelection.lower(colorScheme),$0
    )
})
}
public func defaultNodeSelection() -> NodeSelection  {
    return try!  FfiConverterTypeNodeSelection.lift(try! rustCall() {
    uniffi_cove_fn_func_default_node_selection($0
    )
})
}
public func discoveryStateIsEqual(lhs: DiscoveryState, rhs: DiscoveryState) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_discovery_state_is_equal(
        FfiConverterTypeDiscoveryState.lower(lhs),
        FfiConverterTypeDiscoveryState.lower(rhs),$0
    )
})
}
public func feeSpeedDuration(feeSpeed: FeeSpeed) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_fee_speed_duration(
        FfiConverterTypeFeeSpeed.lower(feeSpeed),$0
    )
})
}
public func feeSpeedToCircleColor(feeSpeed: FeeSpeed) -> FfiColor  {
    return try!  FfiConverterTypeFfiColor.lift(try! rustCall() {
    uniffi_cove_fn_func_fee_speed_to_circle_color(
        FfiConverterTypeFeeSpeed.lower(feeSpeed),$0
    )
})
}
public func feeSpeedToString(feeSpeed: FeeSpeed) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_fee_speed_to_string(
        FfiConverterTypeFeeSpeed.lower(feeSpeed),$0
    )
})
}
public func fiatAmountPreviewNew() -> FiatAmount  {
    return try!  FfiConverterTypeFiatAmount.lift(try! rustCall() {
    uniffi_cove_fn_func_fiat_amount_preview_new($0
    )
})
}
public func groupedPlainWordsOf(mnemonic: String, groups: UInt8)throws  -> [[String]]  {
    return try  FfiConverterSequenceSequenceString.lift(try rustCallWithError(FfiConverterTypeMnemonicParseError.lift) {
    uniffi_cove_fn_func_grouped_plain_words_of(
        FfiConverterString.lower(mnemonic),
        FfiConverterUInt8.lower(groups),$0
    )
})
}
public func hashRoute(route: Route) -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_func_hash_route(
        FfiConverterTypeRoute.lower(route),$0
    )
})
}
public func isRouteEqual(route: Route, routeToCheck: Route) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_is_route_equal(
        FfiConverterTypeRoute.lower(route),
        FfiConverterTypeRoute.lower(routeToCheck),$0
    )
})
}
public func networkToString(network: Network) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_network_to_string(
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
public func nodeSelectionToNode(node: NodeSelection) -> Node  {
    return try!  FfiConverterTypeNode.lift(try! rustCall() {
    uniffi_cove_fn_func_node_selection_to_node(
        FfiConverterTypeNodeSelection.lower(node),$0
    )
})
}
public func numberOfWordsInGroups(me: NumberOfBip39Words, of: UInt8) -> [[String]]  {
    return try!  FfiConverterSequenceSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_func_number_of_words_in_groups(
        FfiConverterTypeNumberOfBip39Words.lower(me),
        FfiConverterUInt8.lower(of),$0
    )
})
}
public func numberOfWordsToWordCount(me: NumberOfBip39Words) -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_cove_fn_func_number_of_words_to_word_count(
        FfiConverterTypeNumberOfBip39Words.lower(me),$0
    )
})
}
public func previewNewLegacyFoundAddress() -> FoundAddress  {
    return try!  FfiConverterTypeFoundAddress.lift(try! rustCall() {
    uniffi_cove_fn_func_preview_new_legacy_found_address($0
    )
})
}
public func previewNewWrappedFoundAddress() -> FoundAddress  {
    return try!  FfiConverterTypeFoundAddress.lift(try! rustCall() {
    uniffi_cove_fn_func_preview_new_wrapped_found_address($0
    )
})
}
public func stringOrDataTryIntoMultiFormat(stringOrData: StringOrData)throws  -> MultiFormat  {
    return try  FfiConverterTypeMultiFormat.lift(try rustCallWithError(FfiConverterTypeMultiFormatError.lift) {
    uniffi_cove_fn_func_string_or_data_try_into_multi_format(
        FfiConverterTypeStringOrData.lower(stringOrData),$0
    )
})
}
public func transactionPreviewConfirmedNew() -> Transaction  {
    return try!  FfiConverterTypeTransaction.lift(try! rustCall() {
    uniffi_cove_fn_func_transaction_preview_confirmed_new($0
    )
})
}
public func transactionPreviewUnconfirmedNew() -> Transaction  {
    return try!  FfiConverterTypeTransaction.lift(try! rustCall() {
    uniffi_cove_fn_func_transaction_preview_unconfirmed_new($0
    )
})
}
public func transactionsPreviewNew(confirmed: UInt8, unconfirmed: UInt8) -> [Transaction]  {
    return try!  FfiConverterSequenceTypeTransaction.lift(try! rustCall() {
    uniffi_cove_fn_func_transactions_preview_new(
        FfiConverterUInt8.lower(confirmed),
        FfiConverterUInt8.lower(unconfirmed),$0
    )
})
}
public func unitToString(unit: Unit) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_unit_to_string(
        FfiConverterTypeUnit.lower(unit),$0
    )
})
}
public func updatePricesIfNeeded()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_func_update_prices_if_needed(
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
public func walletAddressTypeLessThan(lhs: WalletAddressType, rhs: WalletAddressType) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_wallet_address_type_less_than(
        FfiConverterTypeWalletAddressType.lower(lhs),
        FfiConverterTypeWalletAddressType.lower(rhs),$0
    )
})
}
public func walletAddressTypeToString(walletAddressType: WalletAddressType) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_wallet_address_type_to_string(
        FfiConverterTypeWalletAddressType.lower(walletAddressType),$0
    )
})
}
public func walletMetadataPreview() -> WalletMetadata  {
    return try!  FfiConverterTypeWalletMetadata.lift(try! rustCall() {
    uniffi_cove_fn_func_wallet_metadata_preview($0
    )
})
}
public func walletStateIsEqual(lhs: WalletLoadState, rhs: WalletLoadState) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_wallet_state_is_equal(
        FfiConverterTypeWalletLoadState.lower(lhs),
        FfiConverterTypeWalletLoadState.lower(rhs),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_cove_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_cove_checksum_func_address_is_equal() != 63981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_address_is_valid() != 22920) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_address_is_valid_for_network() != 41522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_address_string_spaced_out() != 60902) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_all_color_schemes() != 24835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_all_networks() != 30650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_all_units() != 36925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_balance_zero() != 63807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_color_scheme_selection_capitalized_string() != 42247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_default_node_selection() != 14665) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_discovery_state_is_equal() != 12390) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_fee_speed_duration() != 28599) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_fee_speed_to_circle_color() != 46076) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_fee_speed_to_string() != 21405) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_fiat_amount_preview_new() != 6422) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_grouped_plain_words_of() != 45802) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_hash_route() != 32817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_is_route_equal() != 25732) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_network_to_string() != 60660) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_node_selection_to_node() != 57209) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_number_of_words_in_groups() != 14214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_number_of_words_to_word_count() != 24846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_preview_new_legacy_found_address() != 36773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_preview_new_wrapped_found_address() != 57500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_string_or_data_try_into_multi_format() != 34953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_transaction_preview_confirmed_new() != 43706) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_transaction_preview_unconfirmed_new() != 49725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_transactions_preview_new() != 60166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_unit_to_string() != 63080) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_update_prices_if_needed() != 27986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_wallet_address_type_less_than() != 14566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_wallet_address_type_to_string() != 36064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_wallet_metadata_preview() != 1229) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_wallet_state_is_equal() != 27037) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_address_spaced_out() != 29461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_address_string() != 10597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_addressinfo_address() != 59376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_addressinfo_adress_string() != 41627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_addressinfo_index() != 45529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_addresswithnetwork_address() != 33477) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_addresswithnetwork_amount() != 23019) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_addresswithnetwork_network() != 64145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_amount_as_btc() != 7531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_amount_as_sats() != 62969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_amount_btc_string() != 21387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_amount_btc_string_with_unit() != 10939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_amount_fmt_string_with_unit() != 14497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_amount_sats_string() != 36019) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_amount_sats_string_with_unit() != 34409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_autocomplete_autocomplete() != 4748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_autocomplete_is_valid_word() != 18021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bbqrjoinresult_final_result() != 44157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bbqrjoinresult_is_complete() != 4119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bbqrjoinresult_parts_left() != 39828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bbqrjoined_get_grouped_words() != 36018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bbqrjoined_get_seed_words() != 64693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39autocomplete_autocomplete() != 21847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39autocomplete_is_valid_word() != 19081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39wordspecificautocomplete_autocomplete() != 34680) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39wordspecificautocomplete_is_bip39_word() != 59249) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39wordspecificautocomplete_is_valid_word() != 4400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bitcointransaction_normalize_tx_id() != 15620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bitcointransaction_tx_id() != 39904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bitcointransaction_tx_id_hash() != 59940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_boxedroute_route() != 26050) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_fee_rate() != 32230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_fee_total() != 15069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_id() != 46525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_id_hash() != 11280) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_is_equal() != 16719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_normalized_id() != 32961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_psbt_bytes() != 48686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_psbt_to_bbqr() != 44579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_psbt_to_hex() != 3021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_sending_amount() != 58788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_sending_to() != 43075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmdetails_spending_amount() != 62205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_block_height() != 62845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_block_height_fmt() != 22839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_confirmed_at() != 21481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_confirmed_at_fmt() != 28835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_confirmed_at_fmt_with_time() != 36703) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_fiat_amount() != 31522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_id() != 63537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_label() != 17010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_sent_and_received() != 3525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_database_global_config() != 4476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_database_unsigned_transactions() != 8913) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_database_wallets() != 38115) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerate_sat_per_vb() != 31119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoption_duration() != 58541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoption_fee_rate() != 56298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoption_fee_speed() != 22536) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoption_is_equal() != 48538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoption_sat_per_vb() != 60748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptionwithtotalfee_duration() != 26593) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptionwithtotalfee_fee_rate() != 14029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptionwithtotalfee_fee_rate_options() != 29806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptionwithtotalfee_fee_speed() != 32155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptionwithtotalfee_is_equal() != 47764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptionwithtotalfee_sat_per_vb() != 40506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptionwithtotalfee_total_fee() != 40202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptions_fast() != 29009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptions_medium() != 5747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptions_slow() != 58269) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptionswithtotalfee_fast() != 15779) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptionswithtotalfee_fee_rate_options() != 7503) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptionswithtotalfee_medium() != 444) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_feerateoptionswithtotalfee_slow() != 1762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_dispatch() != 48712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_fees() != 44559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_go_to_selected_wallet() != 36820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_has_wallets() != 3792) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_init_on_start() != 44630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_listen_for_updates() != 48795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_load_and_reset_default_route() != 16043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_load_and_reset_default_route_after() != 14335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_network() != 26747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_num_wallets() != 28903) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_prices() != 58350) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_reset_default_route_to() != 40613) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_reset_nested_routes_to() != 13093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_select_wallet() != 31318) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_state() != 19551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffinfcreader_data_from_records() != 32962) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffinfcreader_is_resumeable() != 21759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffinfcreader_is_started() != 956) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffinfcreader_message_info() != 7402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffinfcreader_parse() != 39581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffinfcreader_string_from_record() != 60818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_filehandler_read() != 31508) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_fingerprint_as_lowercase() != 25321) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_fingerprint_as_uppercase() != 11522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_clear_selected_wallet() != 22146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_color_scheme() != 18859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_delete() != 13364) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_get() != 52128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_select_wallet() != 52001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_selected_network() != 7657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_selected_node() != 31353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_selected_wallet() != 51568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_set() != 31033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_set_color_scheme() != 24086) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_set_selected_network() != 34312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_set_selected_node() != 35090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalflagtable_get() != 42810) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalflagtable_set() != 23016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalflagtable_toggle_bool_config() != 12062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_headericonpresenter_background_color() != 61819) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_headericonpresenter_icon_color() != 52203) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_headericonpresenter_ring_color() != 23010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_mnemonic_all_words() != 45039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_mnemonic_words() != 35319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_multiqr_add_part() != 11179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_multiqr_get_grouped_words() != 21029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_multiqr_handle_scan_result() != 3857) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_multiqr_is_bbqr() != 22296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_multiqr_is_seed_qr() != 10256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_multiqr_total_parts() != 51119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ndefrecordreader_id() != 37849) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ndefrecordreader_type_() != 27060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nfcconst_bytes_per_block() != 35854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nfcconst_number_of_blocks_per_chunk() != 48258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nfcconst_total_bytes_per_chunk() != 41799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_check_and_save_node() != 48519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_check_selected_node() != 19872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_node_list() != 23402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_parse_custom_node() != 54190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_select_preset_node() != 36330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_selected_node() != 29849) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_psbt_fee() != 37973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_psbt_tx_id() != 61047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_psbt_weight() != 5696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_cold_wallet_import() != 14120) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_hot_wallet() != 7846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_hot_wallet_import_from_scan() != 63262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_is_same_parent_route() != 43168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_load_and_reset_nested_to() != 36095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_load_and_reset_to() != 41201) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_load_and_reset_to_after() != 39743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_new_hot_wallet() != 51032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_new_wallet_select() != 21343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_qr_import() != 17980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_secret_words() != 64915) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_send() != 62083) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_send_confirm() != 14299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_send_hardware_export() != 34735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_send_set_amount() != 33578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustimportwalletmanager_dispatch() != 61781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustimportwalletmanager_import_wallet() != 11259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustimportwalletmanager_listen_for_updates() != 20416) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_bip_39_words() != 45973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_bip_39_words_grouped() != 16310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_card_indexes() != 62341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_dispatch() != 51484) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_get_state() != 18821) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_listen_for_updates() != 33763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_number_of_words_count() != 15545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_save_wallet() != 15246) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_address_at() != 57955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_amount_in_fiat() != 65443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_balance() != 39936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_balance_in_fiat() != 47457) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_build_transaction() != 34456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_build_transaction_with_fee_rate() != 2979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_current_block_height() != 4472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_delete_unsigned_transaction() != 27903) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_delete_wallet() != 52855) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_dispatch() != 24198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_display_amount() != 60340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_display_fiat_amount() != 44877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_display_sent_and_received_amount() != 30476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_fee_rate_options() != 58900) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_fee_rate_options_with_total_fee() != 43269) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_fees() != 1824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_fingerprint() != 63952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_force_update_height() != 23832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_force_wallet_scan() != 18975) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_get_confirm_details() != 38134) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_get_fee_options() != 9964) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_get_max_send_amount() != 18292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_get_unsigned_transactions() != 63072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_listen_for_updates() != 14977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_mark_wallet_as_verified() != 7383) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_next_address() != 51147) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_number_of_confirmations() != 50545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_number_of_confirmations_fmt() != 58278) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_save_unsigned_transaction() != 14349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_sent_and_received_fiat() != 6901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_set_wallet_metadata() != 43968) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_start_wallet_scan() != 17019) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_switch_to_different_wallet_address_type() != 22577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_transaction_details() != 26168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_validate_metadata() != 50071) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_wallet_metadata() != 65131) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_word_validator() != 64012) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_seedqr_get_words() != 64188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_seedqr_grouped_plain_words() != 35569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_sentandreceived_amount() != 29581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_sentandreceived_amount_fmt() != 55767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_sentandreceived_direction() != 63307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_sentandreceived_label() != 28947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_sentandreceived_received() != 12400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_sentandreceived_sent() != 29124) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_address() != 31151) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_address_spaced_out() != 61966) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_amount() != 16978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_amount_fiat() != 34436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_amount_fiat_fmt() != 60211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_amount_fmt() != 3569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_block_number() != 61262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_block_number_fmt() != 52006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_confirmation_date_time() != 54859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_fee_fiat_fmt() != 62198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_fee_fmt() != 46565) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_is_confirmed() != 54031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_is_received() != 54839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_is_sent() != 7556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_sent_sans_fee_fiat_fmt() != 62275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_sent_sans_fee_fmt() != 54855) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_transaction_url() != 12235) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_txid_as_hash_string() != 50846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_txid_is_equal() != 5460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unconfirmedtransaction_fiat_amount() != 59016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unconfirmedtransaction_id() != 59175) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unconfirmedtransaction_label() != 12913) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unconfirmedtransaction_last_seen() != 29089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unconfirmedtransaction_sent_and_received() != 24593) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransaction_details() != 5504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransaction_id() != 29504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransaction_label() != 12609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransaction_sending_amount() != 15688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransaction_spending_amount() != 36292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionrecord_confirm_details() != 25286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionrecord_created_at() != 62407) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionrecord_tx_id() != 61639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionrecord_wallet_id() != 32815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionstable_gettx() != 8611) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionstable_gettxthrow() != 32085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wallet_id() != 39072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_walletstable_all() != 19569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_walletstable_is_empty() != 57763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_walletstable_len() != 35149) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordvalidator_is_complete() != 18257) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordvalidator_is_word_correct() != 39689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordvalidator_possible_words() != 25098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_address_from_string() != 47046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_address_preview_new() != 14015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_addresswithnetwork_new() != 36898) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_amount_from_sat() != 58319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_amount_one_btc() != 59586) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_amount_one_sat() != 58118) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_bip39autocomplete_new() != 41839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_bip39wordspecificautocomplete_new() != 49814) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_bitcointransaction_new() != 54397) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_bitcointransaction_tryfromdata() != 16116) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_boxedroute_new() != 62486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_confirmdetails_preview_new() != 31485) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_database_new() != 41458) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_device_new() != 52650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_feerate_from_sat_per_vb() != 58499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_feerateoption_new() != 49009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_feerateoptions_preview_new() != 9368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_feerateoptionswithtotalfee_preview_new() != 15548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_ffiapp_new() != 11955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_ffinfcreader_new() != 27409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_filehandler_new() != 50695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_fingerprint_new() != 20831) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_headericonpresenter_new() != 10425) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_keychain_new() != 34449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_mnemonic_new() != 56597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_mnemonic_preview() != 3882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_multiqr_new_from_string() != 2028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_multiqr_try_new() != 18617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_multiqr_try_new_from_data() != 36957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_ndefrecordreader_new() != 36791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_nfcconst_new() != 22455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_nodeselector_new() != 61659) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_psbt_new() != 25544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_routefactory_new() != 4959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustimportwalletmanager_new() != 63844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustpendingwalletmanager_new() != 12185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustwalletmanager_new() != 53982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustwalletmanager_preview_new_wallet() != 14132) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustwalletmanager_try_new_from_xpub() != 28304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_seedqr_new_from_data() != 13640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_seedqr_new_from_str() != 6520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_transactiondetails_preview_confirmed_received() != 6979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_transactiondetails_preview_confirmed_sent() != 20500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_transactiondetails_preview_new_confirmed() != 2385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_transactiondetails_preview_pending_received() != 1731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_transactiondetails_preview_pending_sent() != 378) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_unsignedtransaction_preview_new() != 1909) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_wallet_new_from_export() != 11192) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_wallet_new_from_xpub() != 31726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_wallet_previewnewwallet() != 56877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_wordvalidator_preview() != 53831) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_deviceaccess_timezone() != 16696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffireconcile_reconcile() != 54238) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_importwalletmanagerreconciler_reconcile() != 37305) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_keychainaccess_save() != 63039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_keychainaccess_get() != 3155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_keychainaccess_delete() != 11466) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_pendingwalletmanagerreconciler_reconcile() != 39280) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_walletmanagerreconciler_reconcile() != 1495) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAutoComplete()
    uniffiCallbackInitDeviceAccess()
    uniffiCallbackInitFfiReconcile()
    uniffiCallbackInitImportWalletManagerReconciler()
    uniffiCallbackInitKeychainAccess()
    uniffiCallbackInitPendingWalletManagerReconciler()
    uniffiCallbackInitWalletManagerReconciler()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all